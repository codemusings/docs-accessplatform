<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>JDO Identity</title>
    </properties>

    <body>
        <section name="JDO Identity">
            <p>
                All JDO-enabled persistable classes need to have an "identity" to be able to identify an object for retrieval and relationships. 
                There are three types of identity defineable using JDO. These are
            </p>
            <ul>
                <li><a href="#datastore">Datastore Identity</a> : a surrogate column is added to the persistence of the persistable type, and objects of this type are identified by
                    the class plus the value in this surrogate column.</li>
                <li><a href="#application">Application Identity</a> : a field, or several fields of the persistable type are assigned as being (part of) the primary key.</li>
                <li><a href="#nondurable">Nondurable Identity</a> : the persistable type has no identity as such, so the only way to lookup objects of this type would be
                    via query for values of specific fields. This is useful for storing things like log messages etc.</li>
            </ul>
            <p>
                A further complication is where you use <i>application identity</i> but one of the fields forming the primary key is a relation field. This is known
                as <a href="#compound">Compound Identity</a>.
            </p>
        </section>

        <section name="Datastore Identity">
            <a name="datastore"/>
            <p>
                With <b>datastore identity</b> you are leaving the assignment of id's to DataNucleus and your class will 
                <b>not</b> have a field for this identity - it will be added to the datastore representation by DataNucleus. 
                It is, to all extents and purposes a <i>surrogate key</i> that will have its own column in the 
                datastore. To specify that a class is to use <b>datastore identity</b> with JDO, you add the 
                following to the MetaData for the class.
            </p>
            <source><![CDATA[
<class name="MyClass" identity-type="datastore">
...
</class>]]></source>
            <p>or using JDO annotations</p>
            <source><![CDATA[
@PersistenceCapable(identityType=IdentityType.DATASTORE)
public class MyClass
{
    ...
}]]></source>
            <p>
                So you are specifying the <b>identity-type</b> as <i>datastore</i>. You don't need to add this 
                because <i>datastore</i> is the default, so in the absence of any value, it will be assumed to be 
                'datastore'.
            </p>
            <table class="infoTable"><tr>
                <td><img src="../images/lightbulb.png" border="0"/></td>
                <td>
                    <b>When you have an inheritance hierarchy, you should specify the identity type in the 
                    <u>base</u> class for the inheritance tree. This is then used for all persistent classes in the tree.</b>
                </td>
            </tr></table>
            <br/>

            <subsection name="Generating identities">
                <img src="../images/jdo2.gif" alt=""/>
                <p>
                    By choosing <b>datastore identity</b> you are handing the process of identity generation to the 
                    JDO implementation. This does not mean that you haven't got any control over how it does this. 
                    JDO 2 defines many ways of generating these identities and DataNucleus supports all of these and 
                    provides some more of its own besides.
                </p>
                <p>
                    Defining which one to use is a simple matter of adding a MetaData element to your classes 
                    definition, like this
                </p>
                <source><![CDATA[
<class name="MyClass" identity-type="datastore">
    <datastore-identity strategy="sequence" sequence="MY_SEQUENCE"/>
    ...
</class>


<class name="MyClass" identity-type="datastore">
    <datastore-identity strategy="identity"/>
    ...
</class>]]></source>
                <p>
                    or using annotations, for example
                </p>
                <source>
@PersistenceCapable
@DatastoreIdentity(strategy="sequence", sequence="MY_SEQUENCE")
public class MyClass
{
    ...
}</source>
                <p>
                    Some of the datastore identity strategies require additional attributes, but the specification is
                    straightforward.
                </p>
                <p>See also :-</p>
                <ul>
                    <li><a href="value_generation.html">Identity Generation Guide</a> - strategies for generating ids</li>
                    <li><a href="metadata_xml.html#datastore-identity">MetaData reference for &lt;datastore-identity&gt; element</a></li>
                    <li><a href="annotations.html#DatastoreIdentity">Annotations reference for @DatastoreIdentity</a></li>
                </ul>
                <br/>
            </subsection>

            <subsection name="Datastore Identity : Accessing the Identity">
                <p>
                    When using <b>datastore identity</b>, the class has no associated field so you can't just access a field of the class to see its identity.
                    If you need a field to be able to access the identity then you should be using<a href="#application">application identity</a>. 
                    There are, however, ways to get the identity for the datastore identity case, if you have the object.
                </p>
                <source>Object id = pm.getObjectId(obj);</source>
                <source>Object id = JDOHelper.getObjectId(obj);</source>
                <p>
                    You should be aware however that the "identity" is in a complicated form, and is not available as a simple integer value for example. 
                    Again, if you want an identity of that form then you should use <a href="#application">application identity</a>
                </p>
                <br/>
            </subsection>

            <subsection name="Datastore Identity : Implementation">
                <p>
                    When implementing <b>datastore identity</b> all JDO implementations have to provide a public 
                    class that represents this identity. If you call <i>pm.getObjectId(...)</i> for a class using 
                    datastore identity you will be passed an object which, in the case of DataNucleus will be of type 
                    <i>org.datanucleus.identity.OIDImpl</i>. If you were to call "toString()" on this object you would 
                    get something like 
                </p>
                <source>
1[OID]mydomain.MyClass
This is made up of :-
    1 = identity number of this object
    class-name</source>
                <p>
                    <b>The definition of this datastore identity is JDO implementation dependent. As a result you 
                        should not use the <i>org.datanucleus.identity.OID</i> class in your application if you want to 
                        remain implementation independent</b>
                </p>
                <p>
                    <img src="../images/nucleus_plugin.gif" border="0" alt=""/>
                    DataNucleus allows you the luxury of being able to 
                    <a href="../extensions/datastoreidentity.html">provide your own datastore identity class</a> 
                    so you can have whatever formatting you want for identities.
                </p>
                <br/>
            </subsection>

            <subsection name="Datastore Identity : Accessing objects by Identity">
                <p>
                    If you have the JDO identity then you can access the object with that identity like this
                </p>
                <source>Object obj = pm.getObjectById(id);</source>
                <p>
                    You can also access the object from the object class name and the toString() form of the
                    datastore identity (e.g "1[OID]mydomain.MyClass") like this
                </p>
                <source>Object obj = pm.getObjectById(MyClass.class, mykey);</source>
                <br/>
            </subsection>
        </section>

        <section name="Application Identity">
            <a name="application"/>
            <p>
                With <b>application identity</b> you are taking control of the specification of id's to DataNucleus. 
                Application identity requires a primary key class <i>(unless you have a single primary-key field in which 
                case the PK class is provided for you)</i>, and each persistent capable class may define a different 
                class for its primary key, and different persistent capable classes can use the same primary key class, 
                as appropriate. With <b>application identity</b> the field(s) of the primary key will be present as 
                field(s) of the class itself. To specify that a class is to use <b>application identity</b>, you add 
                the following to the MetaData for the class.
            </p>
            <source><![CDATA[
<class name="MyClass" objectid-class="MyIdClass">
    <field name="myPrimaryKeyField" primary-key="true"/>
    ...
</class>]]></source>
            <p>
                For JDO we specify the <b>primary-key</b> and <b>objectid-class</b>. 
                The <b>objectid-class</b> is optional, and is the class defining the identity for this class (again, if you have a single primary-key
                field then you can omit it). Alternatively, if we are using annotations
            </p>
            <source><![CDATA[
@PersistenceCapable(objectIdClass=MyIdClass.class)
public class MyClass
{
    @Persistent(primaryKey="true")
    private long myPrimaryKeyField;
}]]></source>
            <table class="infoTable">
                <tr>
                    <td><img src="../images/lightbulb.png" border="0"/></td>
                    <td>
                        <b>When you have an inheritance hierarchy, you should specify the identity type in the 
                        <i>base instantiable</i> class for the inheritance tree. This is then used for all persistent classes in the tree.</b>
                        This means that you can have superclass(es) using application-identity without any identity
                        fields/properties but using <i>subclass-table</i> inheritance, and then the base instantiable 
                        class is the first persistable class which has the identity field(s).
                    </td>
                </tr>
            </table>
            <p>See also :-</p>
                <ul>
                    <li><a href="metadata_xml.html#field">MetaData reference for &lt;field&gt; element</a></li>
                    <li><a href="annotations.html#Persistent">Annotations reference for @Persistent</a></li>
                </ul>
            <br/>

            <a name="application_primarykey"/>
            <subsection name="Application Identity : PrimaryKey Classes">
                <p>
                    When you choose application identity you are defining which fields of the class are part of the primary key,
                    and you are taking control of the specification of id's to DataNucleus. Application identity requires 
                    a primary key (PK) class, and each persistent capable class may define a different class for its 
                    primary key, and different persistent capable classes can use the same primary key class, as 
                    appropriate. If you have only a single primary-key field then there are built-in PK classes so you can forget this section. 
                    Where you have more than 1 primary key field, you would define the PK class like this
            </p>
<source><![CDATA[
<class name="MyClass" identity-type="application" objectid-class="MyIdClass">
...
</class>
]]></source>
            <p>or using annotations</p>
            <source><![CDATA[
@PersistenceCapable(objectIdClass=MyIdClass.class)
public class MyClass
{
    ...
}]]></source>
                <p>
                    You now need to define the PK class to use. This is simplified for you because <b>if you have only one 
                    PK field then you dont need to define a PK class</b> and you only define it when you have a composite PK.
                </p>
                <p>
                    An important thing to note is that the PK can only be made up of fields of the following Java types
                </p>
                <ul>
                    <li>Primitives : <b>boolean</b>, <b>byte</b>, <b>char</b>, <b>int</b>, <b>long</b>, <b>short</b></li>
                    <li>java.lang : <b>Boolean</b>, <b>Byte</b>, <b>Character</b>, <b>Integer</b>, <b>Long</b>, <b>Short</b>, <b>String</b>, <b>Enum</b>, StringBuffer</li>
                    <li>java.math : <b>BigInteger</b></li>
                    <li>java.sql : <b>Date</b>, <b>Time</b>, <b>Timestamp</b></li>
                    <li>java.util : <b>Date</b>, <b>Currency</b>, <b>Locale</b>, TimeZone, UUID</li>
                    <li>java.net : URI, URL</li>
                    <li><i>persistable</i></li>
                </ul>
                <p>
                    Note that the types in <b>bold</b> are JDO standard types. Any others are DataNucleus extensions and,
                    as always, <a href="../datastores/index.html">check the specific datastore docs</a> to see what is supported for your datastore.
                </p>

                <p><b>Single PrimaryKey field</b></p>
                <p>
                    The simplest way of using <b>application identity</b> is where you have a single PK field, and in 
                    this case you use <b>SingleFieldIdentity</b> 
                    <a href="http://db.apache.org/jdo/api20/apidocs/javax/jdo/identity/SingleFieldIdentity.html" target="_blank"><img src="../images/javadoc.gif" alt=""/></a>.
                    mechanism. This provides a PrimaryKey and you don't need to specify the <i>objectid-class</i>. 
                    Let's take an example
                </p>
<source><![CDATA[
public class MyClass
{
    long id;
    ...
}

<class name="MyClass" identity-type="application">
    <field name="id" primary-key="true"/>
    ...
</class>]]></source>
                <p>or using annotations</p>
<source><![CDATA[
@PersistenceCapable
public class MyClass
{
    @PrimaryKey
    long id;
    ...
}]]></source>
                <p>
                    So we didnt specify the JDO "objectid-class". You will, of course, have to give 
                    the field a value before persisting the object, either by setting it yourself, or by using a 
                    <a href="value_generation.html">value-strategy</a> on that field.
                </p>
                <p>
                    If you need to create an identity of this form for use in querying via <i>pm.getObjectById()</i> 
                    then you can create the identities in the following way
                </p>
                <source>
For a "long" type :
javax.jdo.identity.LongIdentity id = new javax.jdo.identity.LongIdentity(myClass, 101);

For a "String" type :
javax.jdo.identity.StringIdentity id = new javax.jdo.identity.StringIdentity(myClass, "ABCD");</source>
                <p>We have shown an example above for type "long", but you can also use this for the following</p>
                <source>
short, Short       - javax.jdo.identity.ShortIdentity
int, Integer       - javax.jdo.identity.IntIdentity
long, Long         - javax.jdo.identity.LongIdentity
String             - javax.jdo.identity.StringIdentity
char, Character    - javax.jdo.identity.CharIdentity
byte, Byte         - javax.jdo.identity.ByteIdentity
java.util.Date     - javax.jdo.identity.ObjectIdentity
java.util.Currency - javax.jdo.identity.ObjectIdentity
java.util.Locale   - javax.jdo.identity.ObjectIdentity</source>
                <br/>

                <br/>
            </subsection>

            <subsection name="PrimaryKey : Rules for User-Defined classes">
                <p>
                    If you wish to use <b>application identity</b> and don't want to use the "SingleFieldIdentity" builtin PK classes then you must define a 
                    Primary Key class of your own. You can't use classes like java.lang.String, or java.lang.Long directly. You must follow these rules when defining your 
                    primary key class.
                </p>
                <ul>
                    <li>the Primary Key class must be public</li>
                    <li>the Primary Key class must implement Serializable</li>
                    <li>the Primary Key class must have a public no-arg constructor, which might be the default 
                        constructor</li>
                    <li>the field types of all non-static fields in the Primary Key class must be serializable, and 
                        are recommended to be primitive, String, Date, or Number types</li>
                    <li>all serializable non-static fields in the Primary Key class must be public</li>
                    <li>the names of the non-static fields in the Primary Key class must include the names of the 
                        primary key fields in the JDO class, and the types of the common fields must be identical</li>
                    <li>the equals() and hashCode() methods of the Primary Key class must use the value(s) of all the 
                        fields corresponding to the primary key fields in the JDO class</li>
                    <li>if the Primary Key class is an inner class, it must be static</li>
                    <li>the Primary Key class must override the toString() method defined in Object, and return a 
                        String that can be used as the parameter of a constructor</li>
                    <li>the Primary Key class must provide a String constructor that returns an instance that compares 
                        equal to an instance that returned that String by the toString() method.</li>
                    <li>the Primary Key class must be only used within a single inheritence tree.</li>
                </ul>
                <p>
                    Please note that if one of the fields that comprises the primary key is in itself
                    a persistable object then you have <a href="orm/compound_identity.html">Compound Identity</a>
                    and should consult the documentation for that feature which contains its own example.
                </p>
                <img src="../images/nucleus_extension.gif" alt=""/>
                <table class="infoTable"><tr>
                    <td><img src="../images/lightbulb.png" border="0"/></td>
                    <td>Since there are many possible combinations of primary-key fields it is impossible for JDO to provide a series of builtin composite primary key classes. 
                        However the <a href="enhancer.html">DataNucleus enhancer</a> provides a mechanism for auto-generating a primary-key class for a persistable class. 
                        It follows the rules listed below and should work for all cases. Obviously if you want to tailor the output of things like the PK toString() method 
                        then you ought to define your own. The enhancer generation of primary-key class is only enabled if you don't define your own class.</td>
                </tr></table>
                <br/>
            </subsection>

            <subsection name="PrimaryKey Example - Multiple Field">
                <p>
                    Here's an example of a composite (multiple field) primary key class
                </p>
<source><![CDATA[
@PersistenceCapable(objectIdClass=ComposedIdKey.class)
public class MyClass
{
    @PrimaryKey
    String field1;

    @PrimaryKey
    String field2;
    ...
}

public class ComposedIdKey implements Serializable
{
    public String field1;
    public String field2;

    public ComposedIdKey ()
    {
    }

    /**
     * Constructor accepting same input as generated by toString().
     */
    public ComposedIdKey(String value) 
    {
        StringTokenizer token = new StringTokenizer (value, "::");
        token.nextToken();               // className
        this.field1 = token.nextToken(); // field1
        this.field2 = token.nextToken(); // field2
    }

    public boolean equals(Object obj)
    {
        if (obj == this)
        {
            return true;
        }
        if (!(obj instanceof ComposedIdKey))
        {
            return false;
        }
        ComposedIdKey c = (ComposedIdKey)obj;

        return field1.equals(c.field1) && field2.equals(c.field2);
    }

    public int hashCode ()
    {
        return this.field1.hashCode() ^ this.field2.hashCode();
    }

    public String toString ()
    {
        // Give output expected by String constructor
        return this.getClass().getName() + "::"  + this.field1 + "::" + this.field2;
    }
}]]></source>
            </subsection>

            <subsection name="Compound Identity">
                <p>
                    Where one of the fields that is primary-key of your class is a persistable object you have
                    something known as <b>compound identity</b> since the identity of this class contains the
                    identity of a related class. Please refer to the docs for 
                    <a href="#compound">Compound Identity</a>
                </p>
                <br/>
            </subsection>

            <subsection name="Application Identity : Generating identities">
                <p>
                    By choosing <b>application identity</b> you are controlling the process of identity generation for this 
                    class. This does not mean that you have a lot of work to do for this. JDO defines many ways of 
                    generating these identities and DataNucleus supports all of these and provides some more of its own besides.
                </p>
                <p>See also :-</p>
                <ul>
                    <li><a href="value_generation.html">Identity Generation Guide</a> - strategies for generating ids</li>
                </ul>
                <br/>
            </subsection>

            <subsection name="Application Identity : Accessing the Identity">
                <p>
                    When using <b>application identity</b>, the class has associated field(s) that equate to the identity. 
                    As a result you can simply access the values for these field(s).
                    Alternatively you could use a JDO identity-independent way
                </p>
                <source>Object id = pm.getObjectId(obj);</source>
                <source>Object id = JDOHelper.getObjectId(obj);</source>
                <br/>
            </subsection>

            <subsection name="Application Identity : Changing Identities">
                <p>
                    JDO allows implementations to support the changing of the identity of a persisted object.
                    <b>This is an optional feature and DataNucleus doesn't currently support it.</b>
                </p>
                <br/>
            </subsection>

            <subsection name="Application Identity : Accessing objects by Identity">
                <p>
                    If you have the JDO identity then you can access the object with that identity like this
                </p>
                <source>Object obj = pm.getObjectById(id);</source>
                <p>
                    If you are using SingleField identity then you can access it from the object class name
                    and the key value like this
                </p>
                <source>Object obj = pm.getObjectById(MyClass.class, mykey);</source>
                <p>
                    If you are using your own PK class then the <i>mykey</i> value is the toString() form
                    of the identity of your PK class.
                </p>
                <br/>
            </subsection>
        </section>

        <section name="Nondurable Identity">
            <a name="nondurable"/>
            <p>
                With <b>nondurable identity</b> your objects will not have a unique identity in the datastore. 
                This type of identity is typically for log files, history files etc where you aren't going to access the object by key, but instead by a different parameter. 
                In the datastore the table will typically not have a primary key. To specify that a class is to use <b>nondurable identity</b> with JDO you 
                would add the following to the MetaData for the class.
            </p>
            <source><![CDATA[
<class name="MyClass" identity-type="nondurable">
...
</class>]]></source>
                <p>
                    or using annotations, for example
                </p>
                <source>
@PersistenceCapable(identityType=IdentityType.NONDURABLE)
public class MyClass
{
    ...
}</source>
            <p>
                DataNucleus provides support for "nondurable" identity for some datastores only currently (RDBMS, Excel, ODF, MongoDB, HBase, Cassandra, Neo4j). 
                What this means for something like RDBMS is that the table (or view) of the class will not have a primary-key.
            </p>
        </section>

        <section name="Compound Identity Relationships">
            <a name="compound"/>
            <p>
                A JDO "compound identity relationship" is a relationship between two classes in which the child object must coexist with the parent object 
                and where the primary key of the child includes the persistable object of the parent. The key aspect of this type of relationship is that 
                the primary key of one of the classes includes a persistable field (hence why is is referred to as <i>Compound Identity</i>). 
                This type of relation is available in the following forms
            </p>
            <ul>
                <li><a href="#compound_1_1_uni">1-1 unidirectional</a></li>
                <li><a href="#compound_1_N_coll_bi">1-N collection bidirectional using ForeignKey</a></li>
                <li><a href="#compound_1_N_map_bi">1-N map bidirectional using ForeignKey (key stored in value)</a></li>
            </ul>
            <table class="infoTable"><tr>
                <td><img src="../images/lightbulb.png" border="0"/></td>
                <td>In the identity class of the compound persistable class you should define the <i>object-idclass</i> of the 
                    persistable type being contained and use that type in the identity class of the compound persistable type.</td>
            </tr></table>
            <table class="infoTable"><tr>
                <td><img src="../images/lightbulb.png" border="0"/></td>
                <td>The persistable class that is contained cannot be using <i>datastore identity</i>, and must be using <i>application identity</i> with an objectid-class</td>
            </tr></table>
            <br/>

            <a name="compound_1_1_uni"/>
            <subsection name="1-1 Relationship">
                <p>
                    Lets take the same classes as we have in the <a href="orm/one_to_one.html">1-1 Relationships</a>.
                    In the 1-1 relationships guide we note that in the datastore representation of the <b>User</b> and 
                    <b>Account</b> the <b>ACCOUNT</b> table has a primary key as well as a foreign-key to <b>USER</b>. 
                    In our example here we want to just have a primary key that is also a foreign-key to <b>USER</b>. 
                    To do this we need to modify the classes slightly and add primary-key fields and use 
                    "application-identity".
                </p>
                <br/>
                <img src="../images/orm/relationship_1_1_compound_class.jpg" border="0" alt=""/>
                <br/>
                <p>
                    In addition we need to define primary key classes for our <b>User</b> and <b>Account</b> classes
                </p>
                <source><![CDATA[
public class User
{
    long id;

    ... (remainder of User class)

    /**
     * Inner class representing Primary Key
     */
    public static class PK implements Serializable
    {
        public long id;

        public PK()
        {
        }

        public PK(String s)
        {
            this.id = Long.valueOf(s).longValue();
        }

        public String toString()
        {
            return "" + id;
        }

        public int hashCode()
        {
            return (int)id;
        }

        public boolean equals(Object other)
        {
            if (other != null && (other instanceof PK))
            {
                PK otherPK = (PK)other;
                return otherPK.id == this.id;
            }
            return false;
        }
    }
}

public class Account
{
    User user;
                
    ... (remainder of Account class)

    /**
     * Inner class representing Primary Key
     */
    public static class PK implements Serializable
    {
        public User.PK user; // Use same name as the real field above

        public PK()
        {
        }

        public PK(String s)
        {
            StringTokenizer token = new StringTokenizer(s,"::");

            this.user = new User.PK(token.nextToken());
        }

        public String toString()
        {
            return "" + this.user.toString();
        }

        public int hashCode()
        {
            return user.hashCode();
        }

        public boolean equals(Object other)
        {
            if (other != null && (other instanceof PK))
            {
                PK otherPK = (PK)other;
                return this.user.equals(otherPK.user);
            }
            return false;
        }
    }
}]]></source>
                <p>
                    To achieve what we want with the datastore schema we define the MetaData like this
                </p>
                <source><![CDATA[
<package name="mydomain">
    <class name="User" identity-type="application" objectid-class="User$PK">
        <field name="id" primary-key="true"/>
        <field name="login" persistence-modifier="persistent">
            <column length="20" jdbc-type="VARCHAR"/>
        </field>
    </class>

    <class name="Account" identity-type="application" objectid-class="Account$PK">
        <field name="user" persistence-modifier="persistent" primary-key="true">
            <column name="USER_ID"/>
        </field>
        <field name="firstName" persistence-modifier="persistent">
            <column length="50" jdbc-type="VARCHAR"/>
        </field>
        <field name="secondName" persistence-modifier="persistent">
            <column length="50" jdbc-type="VARCHAR"/>
        </field>
    </class>
</package>]]></source>
                <p>
                    So now we have the following datastore schema
                </p>
                <br/>
                <img src="../images/orm/relationship_1_1_compound_db.jpg" border="0" alt=""/>
                <br/>
                <p>
                    Things to note :-
                </p>
                <ul>
                    <li>You must use "application-identity" in both parent and child classes</li>
                    <li>In the child Primary Key class, you must have a field with the same name as the relationship in the 
                        child class, and the field in the child Primary Key class must be the same type as the Primary Key 
                        class of the parent</li>
                    <li>See also the <a href="#application_primarykey">general instructions for Primary Key classes</a></li>
                    <li>You can only have one "Account" object linked to a particular "User" object since the FK to the "User"
                        is now the primary key of "Account". To remove this restriction you could also add a "long id" to 
                        "Account" and make the "Account.PK" a composite primary-key</li>
                </ul>
                <br/>
            </subsection>

            <a name="compound_1_N_coll_bi"/>
            <subsection name="1-N Collection Relationship">
                <p>
                    Lets take the same classes as we have in the <a href="orm/one_to_many_collection.html#fk_bi">1-N Relationships
                    (FK)</a>. In the 1-N relationships guide we note that in the datastore representation of the
                    <b>Account</b> and <b>Address</b> classes the <b>ADDRESS</b> table has a primary key as well as a 
                    foreign-key to <b>ACCOUNT</b>. In our example here we want to have the primary-key to <b>ACCOUNT</b> to 
                    <i>include</i> the foreign-key. To do this we need to modify the classes slightly, adding primary-key 
                    fields to both classes, and use "application-identity" for both.
                </p>
                <br/>
                <img src="../images/orm/relationship_1_N_compound_class.jpg" border="0" alt=""/>
                <br/>
                <p>
                    In addition we need to define primary key classes for our <b>Account</b> and <b>Address</b> classes
                </p>
                <source><![CDATA[
public class Account
{
    long id; // PK field

    Set addresses = new HashSet();

    ... (remainder of Account class)

    /**
     * Inner class representing Primary Key
     */
    public static class PK implements Serializable
    {
        public long id;

        public PK()
        {
        }

        public PK(String s)
        {
            this.id = Long.valueOf(s).longValue();
        }

        public String toString()
        {
            return "" + id;
        }

        public int hashCode()
        {
            return (int)id;
        }

        public boolean equals(Object other)
        {
            if (other != null && (other instanceof PK))
            {
                PK otherPK = (PK)other;
                return otherPK.id == this.id;
            }
            return false;
        }
    }
}

public class Address
{
    long id;
    Account account;

    .. (remainder of Address class)

    /**
     * Inner class representing Primary Key
     */
    public static class PK implements Serializable
    {
        public long id; // Same name as real field above
        public Account.PK account; // Same name as the real field above

        public PK()
        {
        }

        public PK(String s)
        {
            StringTokenizer token = new StringTokenizer(s,"::");
            this.id = Long.valueOf(token.nextToken()).longValue();
            this.account = new Account.PK(token.nextToken());
        }

        public String toString()
        {
            return "" + id + "::" + this.account.toString();
        }

        public int hashCode()
        {
            return (int)id ^ account.hashCode();
        }

        public boolean equals(Object other)
        {
            if (other != null && (other instanceof PK))
            {
                PK otherPK = (PK)other;
                return otherPK.id == this.id && this.account.equals(otherPK.account);
            }
            return false;
        }
    }
}]]></source>
                <p>
                    To achieve what we want with the datastore schema we define the MetaData like this
                </p>
                <source><![CDATA[
<package name="mydomain">
    <class name="Account" identity-type="application" objectid-class="Account$PK">
        <field name="id" primary-key="true"/>
        <field name="firstName" persistence-modifier="persistent">
            <column length="50" jdbc-type="VARCHAR"/>
        </field>
        <field name="secondName" persistence-modifier="persistent">
            <column length="50" jdbc-type="VARCHAR"/>
        </field>
        <field name="addresses" persistence-modifier="persistent" mapped-by="account">
            <collection element-type="Address"/>
        </field>
    </class>

    <class name="Address" identity-type="application" objectid-class="Address$PK">
        <field name="id" primary-key="true"/>
        <field name="account" persistence-modifier="persistent" primary-key="true">
            <column name="ACCOUNT_ID"/>
        </field>
        <field name="city" persistence-modifier="persistent">
            <column length="50" jdbc-type="VARCHAR"/>
        </field>
        <field name="street" persistence-modifier="persistent">
            <column length="50" jdbc-type="VARCHAR"/>
        </field>
    </class>
</package>]]></source>
                <p>
                    So now we have the following datastore schema
                </p>
                <br/>
                <img src="../images/orm/relationship_1_N_compound_db.jpg" border="0" alt=""/>
                <br/>
                <p>
                    Things to note :-
                </p>
                <ul>
                    <li>You must use "application-identity" in both parent and child classes</li>
                    <li>In the child Primary Key class, you must have a field with the same name as the relationship in the 
                        child class, and the field in the child Primary Key class must be the same type as the Primary Key
                        class of the parent</li>
                    <li>See also the <a href="#application_primarykey">general instructions for Primary Key classes</a></li>
                    <li>If we had omitted the "id" field from "Address" it would have only been possible to have one "Address"
                        in the "Account" "addresses" collection due to PK constraints. For that reason we have the "id" field 
                        too.</li>
                </ul>
                <br/>
            </subsection>
            
            <a name="compound_1_N_map_bi"/>
            <subsection name="1-N Map Relationship">
                <p>
                    Lets take the same classes as we have in the <a href="orm/one_to_many_map.html#fk_bi_key">1-N Relationships 
                    (FK)</a>. In this guide we note that in the datastore representation of the <b>Account</b> and 
                    <b>Address</b> classes the <b>ADDRESS</b> table has a primary key as well as a foreign-key to 
                    <b>ACCOUNT</b>. In our example here we want to have the primary-key to <b>ACCOUNT</b> to 
                    <i>include</i> the foreign-key. To do this we need to modify the classes slightly, adding primary-key 
                    fields to both classes, and use "application-identity" for both.
                </p>
                <br/>
                <img src="../images/orm/relationship_1_N_bi_map_fk_simple_pc_class.jpg" border="0" alt=""/>
                <br/>
                <p>
                    In addition we need to define primary key classes for our <b>Account</b> and <b>Address</b> classes
                </p>
                <source><![CDATA[
public class Account
{
    long id; // PK field

    Set addresses = new HashSet();

    ... (remainder of Account class)

    /**
     * Inner class representing Primary Key
     */
    public static class PK implements Serializable
    {
        public long id;

        public PK()
        {
        }

        public PK(String s)
        {
            this.id = Long.valueOf(s).longValue();
        }

        public String toString()
        {
            return "" + id;
        }

        public int hashCode()
        {
            return (int)id;
        }

        public boolean equals(Object other)
        {
            if (other != null && (other instanceof PK))
            {
                PK otherPK = (PK)other;
                return otherPK.id == this.id;
            }
            return false;
        }
    }
}

public class Address
{
    String alias;
    Account account;

    .. (remainder of Address class)

    /**
     * Inner class representing Primary Key
     */
    public static class PK implements Serializable
    {
        public String alias; // Same name as real field above
        public Account.PK account; // Same name as the real field above

        public PK()
        {
        }

        public PK(String s)
        {
            StringTokenizer token = new StringTokenizer(s,"::");
            this.alias = Long.valueOf(token.nextToken()).longValue();
            this.account = new Account.PK(token.nextToken());
        }

        public String toString()
        {
            return alias + "::" + this.account.toString();
        }

        public int hashCode()
        {
            return alias.hashCode() ^ account.hashCode();
        }

        public boolean equals(Object other)
        {
            if (other != null && (other instanceof PK))
            {
                PK otherPK = (PK)other;
                return otherPK.alias.equals(this.alias) && this.account.equals(otherPK.account);
            }
            return false;
        }
    }
}]]></source>
                <p>
                    To achieve what we want with the datastore schema we define the MetaData like this
                </p>
                <source><![CDATA[
<package name="com.mydomain">
    <class name="Account" objectid-class="Account$PK">
        <field name="id" primary-key="true"/>
        <field name="firstname" persistence-modifier="persistent">
            <column length="100" jdbc-type="VARCHAR"/>
        </field>
        <field name="lastname" persistence-modifier="persistent">
            <column length="100" jdbc-type="VARCHAR"/>
        </field>
        <field name="addresses" persistence-modifier="persistent" mapped-by="account">
            <map key-type="java.lang.String" value-type="com.mydomain.Address"/>
            <key mapped-by="alias"/>
        </field>
    </class>

    <class name="Address" objectid-class="Address$PK>
        <field name="account" persistence-modifier="persistent" primary-key="true"/>
        <field name="alias" null-value="exception" primary-key="true">
            <column name="KEY" length="20" jdbc-type="VARCHAR"/>
        </field>
        <field name="city" persistence-modifier="persistent">
            <column length="50" jdbc-type="VARCHAR"/>
        </field>
        <field name="street" persistence-modifier="persistent">
            <column length="50" jdbc-type="VARCHAR"/>
        </field>
    </class>
</package>]]></source>
                <p>
                    So now we have the following datastore schema
                </p>
                <br/>
                <img src="../images/orm/relationship_1_N_compound_map_db.jpg" border="0" alt=""/>
                <br/>
                <p>
                    Things to note :-
                </p>
                <ul>
                    <li>You must use "application-identity" in both parent and child classes</li>
                    <li>In the child Primary Key class, you must have a field with the same name as the relationship in the 
                        child class, and the field in the child Primary Key class must be the same type as the Primary Key
                        class of the parent</li>
                    <li>See also the <a href="#application_primarykey">general instructions for Primary Key classes</a></li>
                    <li>If we had omitted the "alias" field from "Address" it would have only been possible to have one 
                        "Address" in the "Account" "addresses" collection due to PK constraints. For that reason we have the
                        "alias" field too as part of the PK.</li>
                </ul>
                <br/>
            </subsection>
        </section>

    </body>
</document>
