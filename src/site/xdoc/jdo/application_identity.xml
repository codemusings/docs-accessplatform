<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>Application Identity</title>
    </properties>

    <body>
        <section name="JDO : Application Identity">
            <p>
                With <b>application identity</b> you are taking control of the specification of id's to DataNucleus. 
                Application identity requires a primary key class <i>(unless you have a single primary-key field in which 
                case the PK class is provided for you)</i>, and each persistent capable class may define a different 
                class for its primary key, and different persistent capable classes can use the same primary key class, 
                as appropriate. With <b>application identity</b> the field(s) of the primary key will be present as 
                field(s) of the class itself. To specify that a class is to use <b>application identity</b>, you add 
                the following to the MetaData for the class.
            </p>
            <source><![CDATA[
<class name="MyClass" objectid-class="MyIdClass">
    <field name="myPrimaryKeyField" primary-key="true"/>
    ...
</class>]]></source>
            <p>
                For JDO we specify the <b>primary-key</b> and <b>objectid-class</b>. The <b>objectid-class</b>
                is optional, and is the class defining the identity for this class (again, if you have a single primary-key
                field then you can omit it). Alternatively, if we are using annotations
            </p>
            <source><![CDATA[
@PersistenceCapable(objectIdClass=MyIdClass.class)
public class MyClass
{
    @Persistent(primaryKey="true")
    private long myPrimaryKeyField;
}]]></source>
            <table>
                <tr>
                    <td>
                        <b>When you have an inheritance hierarchy, you should specify the identity type in the 
                        <u>base instantiable</u> class for the inheritance tree. This is then used for all persistent classes 
                        in the tree.</b>
                        This means that you can have superclass(es) using application-identity without any identity
                        fields/properties but using <i>subclass-table</i> inheritance, and then the base instantiable 
                        class is the first persistable class which has the identity field(s). 
                        This is a change from DataNucleus 2.2 where you had to have identity fields in the base 
                        persistable class of the inheritance tree.
                    </td>
                </tr>
            </table>
            <p>See also :-</p>
                <ul>
                    <li><a href="metadata_xml.html#field">MetaData reference for &lt;field&gt; element</a></li>
                    <li><a href="annotations.html#Persistent">Annotations reference for @Persistent</a></li>
                </ul>
            <br/>

            <subsection name="Primary Key">
                <p>
                    Using <b>application identity</b> requires the use of a Primary Key class. When you have a single
                    primary-key field a built-in class is available meaning you don't need to define this class. 
                    This is referred to as <i>SingleFieldIdentity</i>.
                    Where the class has multiple fields that form the primary key a Primary Key class must be provided.
                </p>
                <p>See also :-</p>
                <ul>
                    <li><a href="#primarykey">Primary Key Guide</a> - user-defined and built-in primary keys</li>
                </ul>
                <br/>
            </subsection>

            <subsection name="Compound Identity">
                <p>
                    Where one of the fields that is primary-key of your class is a persistable object you have
                    something known as <b>compound identity</b> since the identity of this class contains the
                    identity of a related class. Please refer to the docs for 
                    <a href="orm/compound_identity.html">Compound Identity</a>
                </p>
                <br/>
            </subsection>

            <subsection name="Generating identities">
                <p>
                    By choosing <b>application identity</b> you are controlling the process of identity generation for this 
                    class. This does not mean that you have a lot of work to do for this. JDO defines many ways of 
                    generating these identities and DataNucleus supports all of these and provides some more of its own besides.
                </p>
                <p>See also :-</p>
                <ul>
                    <li><a href="value_generation.html">Identity Generation Guide</a> - strategies for generating ids</li>
                </ul>
                <br/>
            </subsection>

            <subsection name="Accessing the Identity">
                <p>
                    When using <b>application identity</b>, the class has associated field(s) that equate to the identity. 
                    As a result you can simply access the values for these field(s).
                    Alternatively you could use a JDO identity-independent way
                </p>
                <source>Object id = pm.getObjectId(obj);</source>
                <source>Object id = JDOHelper.getObjectId(obj);</source>
                <br/>
            </subsection>

            <subsection name="Changing Identities">
                <p>
                    JDO allows implementations to support the changing of the identity of a persisted object.
                    <b>This is an optional feature and DataNucleus doesn't currently support it.</b>
                </p>
                <br/>
            </subsection>

            <subsection name="Accessing objects by Identity">
                <p>
                    If you have the JDO identity then you can access the object with that identity like this
                </p>
                <source>Object obj = pm.getObjectById(id);</source>
                <p>
                    If you are using SingleField identity then you can access it from the object class name
                    and the key value like this
                </p>
                <source>Object obj = pm.getObjectById(MyClass.class, mykey);</source>
                <p>
                    If you are using your own PK class then the <i>mykey</i> value is the toString() form
                    of the identity of your PK class.
                </p>
                <br/>
            </subsection>
        </section>

        <section name="JDO : PrimaryKey Classes">
            <a name="primarykey"/>
            <p>
                When you choose application identity you are defining which fields of the class are part of the primary key,
                and you are taking control of the specification of id's to DataNucleus. Application identity requires 
                a primary key (PK) class, and each persistent capable class may define a different class for its 
                primary key, and different persistent capable classes can use the same primary key class, as 
                appropriate. If you have only a single primary-key field then there are builtin PK classes so you
                can forget this section. Where you have more than 1 primary key field, you would define 
                the PK class like this
            </p>
            <source><![CDATA[
<class name="MyClass" identity-type="application" objectid-class="MyIdClass">
...
</class>
]]></source>
            <p>or using annotations</p>
            <source><![CDATA[
@PersistenceCapable(objectIdClass=MyIdClass.class)
public class MyClass
{
    ...
}]]></source>
            <p>
                You now need to define the PK class to use. This is simplified for you because <b>if you have only one 
                PK field then you dont need to define a PK class</b> and you only define it when you have a composite PK.
            </p>
            <p>
                An important thing to note is that the PK can only be made up of fields of the following Java types
            </p>
            <ul>
                <li>Primitives : <b>boolean</b>, <b>byte</b>, <b>char</b>, <b>int</b>, <b>long</b>, 
                    <b>short</b></li>
                <li>java.lang : <b>Boolean</b>, <b>Byte</b>, <b>Character</b>, <b>Integer</b>, <b>Long</b>, 
                    <b>Short</b>, <b>String</b>, <b>Enum</b>, StringBuffer</li>
                <li>java.math : <b>BigInteger</b></li>
                <li>java.sql : <b>Date</b>, <b>Time</b>, <b>Timestamp</b></li>
                <li>java.util : <b>Date</b>, <b>Currency</b>, <b>Locale</b>, TimeZone, UUID</li>
                <li>java.net : URI, URL</li>
                <li>javax.jdo.spi : <b>PersistenceCapable</b></li>
            </ul>
            <p>
                Note that the types in <b>bold</b> are JDO standard types. Any others are DataNucleus extensions and,
                as always, <a href="../datastores/index.html">check the specific datastore docs</a> to see what is
                supported for your datastore.
            </p>

            <subsection name="Single PrimaryKey field">
                <p>
                    The simplest way of using <b>application identity</b> is where you have a single PK field, and in 
                    this case you use <b>SingleFieldIdentity</b> 
                    <a href="http://db.apache.org/jdo/api20/apidocs/javax/jdo/identity/SingleFieldIdentity.html" target="_blank"><img src="../images/javadoc.gif" alt=""/></a>.
                    mechanism. This provides a PrimaryKey and you don't need to specify the <i>objectid-class</i>. 
                    Let's take an example</p>
            	<source><![CDATA[
public class MyClass
{
    long id;
    ...
}

<class name="MyClass" identity-type="application">
    <field name="id" primary-key="true"/>
    ...
</class>]]></source>
                <p>or using annotations</p>
<source><![CDATA[
@PersistenceCapable
public class MyClass
{
    @PrimaryKey
    long id;
    ...
}]]></source>
                <p>
                    So we didnt specify the JDO "objectid-class". You will, of course, have to give 
                    the field a value before persisting the object, either by setting it yourself, or by using a 
                    <a href="value_generation.html">value-strategy</a> on that field.
                </p>
                <p>
                    If you need to create an identity of this form for use in querying via <i>pm.getObjectById()</i> 
                    then you can create the identities in the following way
                </p>
                <source>
For a "long" type :
javax.jdo.identity.LongIdentity id = new javax.jdo.identity.LongIdentity(myClass, 101);

For a "String" type :
javax.jdo.identity.StringIdentity id = new javax.jdo.identity.StringIdentity(myClass, "ABCD");</source>
                <p>We have shown an example above for type "long", but you can also use this for the following</p>
                <source>
short, Short       - javax.jdo.identity.ShortIdentity
int, Integer       - javax.jdo.identity.IntIdentity
long, Long         - javax.jdo.identity.LongIdentity
String             - javax.jdo.identity.StringIdentity
char, Character    - javax.jdo.identity.CharIdentity
byte, Byte         - javax.jdo.identity.ByteIdentity
java.util.Date     - javax.jdo.identity.ObjectIdentity
java.util.Currency - javax.jdo.identity.ObjectIdentity
java.util.Locale   - javax.jdo.identity.ObjectIdentity</source>
                <br/>
            </subsection>

            <subsection name="Multiple PrimaryKey field">
                <img src="../images/nucleus_extension.gif" alt=""/>
                <p>
                    Since there are many possible combinations of primary-key fields it is impossible for JDO
                    to provide a series of builtin composite primary key classes. However the 
                    <a href="enhancer.html">DataNucleus enhancer</a>
                    provides a mechanism for auto-generating a primary-key class for a persistable class. It follows
                    the rules listed below and should work for all cases. Obviously if you want to tailor the
                    output of things like the PK toString() method then you ought to define your own.
                    The enhancer generation of primary-key class is only enabled if you don't define your own
                    class.
                </p>
                <br/>
            </subsection>

            <subsection name="Rules for User-Defined PrimaryKey classes">
                <p> If you wish to use <b>application identity</b> and don't want to use the "SingleFieldIdentity" 
                    builtin PK classes then you must define a Primary Key class of your own. You can't use classes 
                    like java.lang.String, or java.lang.Long directly. You must follow these rules when defining your 
                    primary key class.</p>
                <ul>
                    <li>the Primary Key class must be public</li>
                    <li>the Primary Key class must implement Serializable</li>
                    <li>the Primary Key class must have a public no-arg constructor, which might be the default 
                        constructor</li>
                    <li>the field types of all non-static fields in the Primary Key class must be serializable, and 
                        are recommended to be primitive, String, Date, or Number types</li>
                    <li>all serializable non-static fields in the Primary Key class must be public</li>
                    <li>the names of the non-static fields in the Primary Key class must include the names of the 
                        primary key fields in the JDO class, and the types of the common fields must be identical</li>
                    <li>the equals() and hashCode() methods of the Primary Key class must use the value(s) of all the 
                        fields corresponding to the primary key fields in the JDO class</li>
                    <li>if the Primary Key class is an inner class, it must be static</li>
                    <li>the Primary Key class must override the toString() method defined in Object, and return a 
                        String that can be used as the parameter of a constructor</li>
                    <li>the Primary Key class must provide a String constructor that returns an instance that compares 
                        equal to an instance that returned that String by the toString() method.</li>
                    <li>the Primary Key class must be only used within a single inheritence tree.</li>
                </ul>
                <p>
                    Please note that if one of the fields that comprises the primary key is in itself
                    a persistable object then you have <a href="orm/compound_identity.html">Compound Identity</a>
                    and should consult the documentation for that feature which contains its own example.
                </p>
                <br/>
            </subsection>

            <subsection name="PrimaryKey Example - Multiple Field">
                <p>
                    Here's an example of a composite (multiple field) primary key class
                </p>
                <source><![CDATA[
@PersistenceCapable(objectIdClass=ComposedIdKey.class)
public class MyClass
{
    @PrimaryKey
    String field1;

    @PrimaryKey
    String field2;
    ...
}

public class ComposedIdKey implements Serializable
{
    public String field1;
    public String field2;

    public ComposedIdKey ()
    {
    }

    /**
     * Constructor accepting same input as generated by toString().
     */
    public ComposedIdKey(String value) 
    {
        StringTokenizer token = new StringTokenizer (value, "::");
        token.nextToken();               // className
        this.field1 = token.nextToken(); // field1
        this.field2 = token.nextToken(); // field2
    }

    public boolean equals(Object obj)
    {
        if (obj == this)
        {
            return true;
        }
        if (!(obj instanceof ComposedIdKey))
        {
            return false;
        }
        ComposedIdKey c = (ComposedIdKey)obj;

        return field1.equals(c.field1) && field2.equals(c.field2);
    }

    public int hashCode ()
    {
        return this.field1.hashCode() ^ this.field2.hashCode();
    }

    public String toString ()
    {
        // Give output expected by String constructor
        return this.getClass().getName() + "::"  + this.field1 + "::" + this.field2;
    }
}]]></source>
            </subsection>
        </section>
    </body>
</document>