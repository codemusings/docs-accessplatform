<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>PersistenceManager</title>
    </properties>

    <body>
        <section name="JDO : PersistenceManager">
            <p>
                As you read in the guide for <a href="pmf.html">PersistenceManagerFactory</a>, to control the 
                persistence of your objects you will require at least one <i>PersistenceManagerFactory</i>. 
                Once you have obtained this object you then use this to obtain a <i>PersistenceManager</i> (PM). 
                A <i>PersistenceManager</i> provides access to the operations for persistence of your objects. 
                This short guide will demonstrate some of the more common operations. For example
                with a web application you would have one PMF representing the datastore, present for the duration
                of the application, and then have a PM per request that comes in, closing it before responding.
            </p>
            <p>
                <b>Important : A <i>PersistenceManagerFactory</i> is designed to be thread-safe. A <i>PersistenceManager</i> is not</b>.
                Note that if you set the persistence property <b>javax.jdo.option.Multithreaded</b> this acts as a hint to the PMF to provide 
                <i>PersistenceManager</i>s that are usable with multiple threads. While DataNucleus makes efforts to make this <i>PersistenceManager</i>
                usable with multiple threads, it is not guaranteed to work multi-threaded in all situations, particularly around second class collection/map
                fields.
            </p>

            <subsection name="Opening/Closing a PersistenceManager">
                <p>
                    You obtain a <i>PersistenceManager</i> 
                    <a href="http://db.apache.org/jdo/api30/apidocs/javax/jdo/PersistenceManager.html" target="_blank"><img src="../images/javadoc.gif" alt=""/></a>
                    as follows
                </p>
                <source>PersistenceManager pm = pmf.getPersistenceManager();</source>
                <p>
                    You then perform all operations that you need using this <i>PersistenceManager</i> and finally you must <b>close</b> it.
                    Forgetting to close it will lead to memory/resource leaks.
                </p>
                <source>pm.close();</source>
                <p>
                    You likely will be performing all operations on a <i>PersistenceManager</i> within a transaction, 
                    whether your transactions are controlled by your JavaEE container, by a framework such as Spring, or by 
                    locally defined transactions. Alternatively you can perform your operations non-transactional.
                    In the examples below we will omit the transaction demarcation for clarity.
                </p>
            <br/>

            <subsection name="Persisting an Object">
                <p>
                    The main thing that you will want to do with the data layer of a JDO-enabled application is 
                    persist your objects into the datastore. As we mentioned earlier, a <i>PersistenceManagerFactory</i>
                    represents the datastore where the objects will be persisted. So you create a normal Java object 
                    in your application, and you then persist this as follows
                </p>
                <source>pm.makePersistent(obj);</source>
                <p>
                    This will result in the object being persisted into the datastore, though clearly it will not be 
                    persistent until you commit the transaction. The LifecycleState of the object changes from 
                    <i>Transient</i> to <i>PersistentClean</i> (after makePersistent), to <i>Hollow</i> (at commit).
                </p>
                <br/>
            </subsection>

            <subsection name="Finding an object by its identity">
                <p>
                    Once you have persisted an object, it has an "identity". This is a unique way of identifying it. 
                    You can obtain the identity by calling
                </p>
                <source>Object id = pm.getObjectId(obj);</source>
                <p>
                    Alternatively by calling
                </p>
                <source>Object id = pm.newObjectIdInstance(cls, key);</source>
                <p>
                    So what ? Well the identity can be used to retrieve the object again at some other part in your 
                    application. So you pass the identity into your application, and the user clicks on some button 
                    on a web page and that button corresponds to a particular object identity. You can then go back 
                    to your data layer and retrieve the object as follows
                </p>
                <source>Object obj = pm.getObjectById(id);</source>
                
                <img src="../images/nucleus_extension.gif" border="0" alt=""/>
                <p>
                    A DataNucleus extension is to pass in a String form of the identity to the above method.
                    It accepts identity strings of the form
                </p>
                <ul>
                    <li><i>{fully-qualified-class-name}:{key}</i></li>
                    <li><i>{discriminator-name}:{key}</i></li>
                </ul>
                <p>
                    where the <i>key</i> is the identity value (datastore-identity) or
                    the result of PK.toString() (application-identity). So for example we could input
                </p>
                <source><![CDATA[obj = pm.getObjectById("mydomain.MyClass:3");]]></source>
                <p>
                    There is, of course, a bulk load variant too
                </p>
                <source>Object[] objs = pm.getObjectsById(ids);</source>
                <br/>

                <img src="../images/nucleus_extension.gif" border="0" alt=""/>
                <p>
                    When you call the method <i>getObjectById</i> if an object with that identity is found in the
                    cache then a call is, by default, made to validate it still exists. You can avoid this call
                    to the datastore by setting the persistence property <b>datanucleus.findObject.validateWhenCached</b>
                    to <i>false</i>.
                </p>
            </subsection>

            <subsection name="Finding an object by its class and primary-key value">
                <p>
                    An alternate form of the <i>getObjectById</i> method is taking in the class of the object, and
                    the "identity". This is for use where you have a <i>single field</i> that is primary key. Like this
                </p>
                <source>Object id = pm.getObjectId(MyClass.class, 123);</source>
                <p>
                    where 123 is the value of the primary key field (numeric).
                    Note that the first argument could be a base class and the real object could be an instance of
                    a subclass of that.
                </p>
                <br/>
            </subsection>

            <subsection name="Deleting an Object">
                <p>
                    When you need to delete an object that you had previous persisted, deleting it is simple.
                    Firstly you need to get the object itself, and then delete it as follows
                </p>
                <source>
Object obj = pm.getObjectById(id);  // Retrieves the object to delete
pm.deletePersistent(obj);</source>
                <p>
                    Don't forget that you can also use <a href="jdoql.html#deletebyquery">deletion by query</a>
                    to delete objects. Alternatively use <a href="jdoql.html#bulkdelete">bulk deletion</a>.
                </p>
                <br/>
            </subsection>

            <subsection name="Modifying a persisted Object">
                <p>
                    To modify a previously persisted object you need to retrieve it (getObjectById, query, getExtent) 
                    and then modify it and its changes will be propagated to the datastore at commit of the transaction.
                </p>
                <p>
                    Don't forget that you can also use <a href="jdoql.html#bulkupdate">bulk update</a> to update
                    a group of objects of a type.
                </p>
                <br/>
            </subsection>

            <subsection name="Detaching a persisted Object">
                <p>
                    You often have a previously persisted object and you want to use it away from the data-access 
                    layer of your application. In this case you want to <i>detach</i> the object (and its related 
                    objects) so that they can be passed across to the part of the application that requires it.
                    To do this you do
                </p>
                <source>
Object detachedObj = pm.detachCopy(obj); // Returns a copy of the persisted object, in detached state</source>
                <p>
                    The detached object is like the original object except that it has no StateManager connected, 
                    and it stores its JDO identity and version. It retains a list of all fields that are modified 
                    while it is detached. This means that when you want to "attach" it to the data-access layer it 
                    knows what to update.
                </p>
                <p>
                    As an alternative, to make the detachment process transparent, you can set the PMF property
                    <i>datanucleus.DetachAllOnCommit</i> to true and when you commit your transaction all objects
                    enlisted in the transaction will be detached.
                </p>
                <br/>
            </subsection>

            <subsection name="Attaching a persisted Object">
                <p>
                    You've detached an object (shown above), and have modified it in your application, and you now 
                    want to attach it back to the persistence layer. You do this as follows
                </p>
                <source>
Object attachedObj = pm.makePersistent(obj); // Returns a copy of the detached object, in attached state</source>
                <br/>
            </subsection>

            <a name="refresh"/>
            <subsection name="Refresh of objects">
                <p>
                    In the situation where you have an object and you think that its values may have changed in
                    the datastore you can update its values to the latest using the following
                </p>
                <source><![CDATA[pm.refresh(obj);]]></source>
                <p>
                    What this will do is as follows
                </p>
                <ul>
                    <li>Refresh the values of all FetchPlan fields in the object</li>
                    <li>Unload all non-FetchPlan fields in the object</li>
                </ul>
                <p>
                    If the object had any changes they will be thrown away by this step, and replaced by
                    the latest datastore values.
                </p>
                <br/>
            </subsection>

            <a name="level1_cache"/>
            <subsection name="Level 1 Cache">
                <p>
                    Each PersistenceManager maintains a cache of the objects that it has encountered (or have been
                    "enlisted") during its lifetime. This is termed the <b>Level 1 Cache</b>. It is enabled by default
                    and you should only ever disable it if you really know what you are doing.
                    There are inbuilt types for the Level 1 (L1) Cache available for selection.
                    DataNucleus supports the following types of L1 Cache :-
                </p>
                <ul>
                    <li><i>weak</i> - uses a weak reference backing map. If JVM garbage collection clears 
                        the reference, then the object is removed from the cache.</li>
                    <li><i>soft</i> - uses a soft reference backing map. If the map entry value object is 
                        not being actively used, then garbage collection <i>may</i> garbage collect the reference, 
                        in which case the object is removed from the cache.</li>
                    <li><i>strong</i> - uses a normal HashMap backing. With this option all references are 
                        strong meaning that objects stay in the cache until they are explicitly removed by calling 
                        remove() on the cache.</li>
                    <li><i>none</i> - will turn off L1 caching. <b>Only ever use this where the cache is of no use
                        and you are performing bulk operations and not requiring objects returned</b></li>
                </ul>
                <p>
                    You can specify the type of L1 cache by providing the persistence property 
                    <b>datanucleus.cache.level1.type</b>. You set this to the value of the type required. 
                    If you want to remove objects from the L1 cache programmatically you should use the
                    <i>pm.evict</i> or <i>pm.evictAll</i> methods.
                </p>
                <p>
                    Objects are placed in the L1 cache (and updated there) during the course of the transaction.
                    This provides rapid access to the objects in use in the users application and is used to
                    guarantee that there is only one object with a particular identity at any one time
                    for that PersistenceManager. When the PersistenceManager is closed the L1 cache is cleared.
                </p>
                <p>
                    <a href="../extensions/level1_cache.html"><img src="../images/nucleus_plugin.gif" border="0" alt=""/></a>
                    The L1 cache is a DataNucleus plugin point allowing you to provide your own cache
                    where you require it.
                </p>
                <br/>
            </subsection>

            <a name="multitenancy"/>
            <subsection name="Multitenancy">
                <p>
                    If you are using a PersistenceManager in a <a href="multitenancy.html">multitenancy</a> environment, and want to have
                    a PersistenceManager per <i>tenant</i> you would set the "Tenant ID" on the PersistenceManager after creation.
                </p>
<source><![CDATA[
pm.setProperty("datanucleus.tenantId", "MyTenantName");]]></source>
                <p>
                    Subsequently on database accesses for classes that are using multitenancy you will likely see use of the "Tenant ID" discriminator column.
                </p>
                <br/>
            </subsection>

        </section>
    </body>
</document>