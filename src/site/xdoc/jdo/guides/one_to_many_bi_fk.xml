<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>JDO Guides - 1-N Bidir FK Collection</title>
    </properties>

    <body>
        <section name="JDO Guides : 1-N Bidirectional Relation using Foreign-Key">
            <a href="https://sourceforge.net/projects/datanucleus/files/datanucleus-samples/">
                <img src="../../images/download.png" alt="Download" border="0"/>
            </a>
            <a href="https://github.com/datanucleus/sample-jdo-one_to_many_fk_bidir">
                <img src="../../images/source_code.png" alt="Source Code" border="0"/>
            </a>
        
            <p>
                This guide demonstrates a 1-N collection relationship between 2 classes. In this sample we
                have <b>Pack</b> and <b>Card</b> such that each <b>Pack</b> can contain many <b>Card</b>s. In addition
                each <b>Card</b> has a <b>Pack</b> that it belongs to. We demonstrate the classes themselves,
                and the MetaData necessary to persist them to the datastore in the way that we require. In this
                case we are going to persist the relation to an RDBMS using a ForeignKey.
            </p>
            <ol>
                <li><b><a href="#classes">Classes</a></b> - Design your Java classes to represent what you 
                    want to model in your system. Persistence doesn't have much of an impact on this stage, but 
                    we'll analyse the very minor influence it does have.</li>
                <li><b><a href="#identity">Object Identity</a></b> - Decide how the identities of your objects 
                    of these classes will be defined. Do you want JDO to give them id's or will you do it yourself.</li>
                <li><b>Meta-Data</b> - Define how your objects of these classes will be persisted.
                    <ol>
                        <li><b><a href="#newschema">New Database Schema</a></b> - you have a clean sheet 
                        of paper and can have them persisted with no constraints.</li>
                        <li><b><a href="#existingschema">Existing Database Schema</a></b> - you have 
                        existing tables that you need the objects persisted to.</li>
                    </ol>
                </li>
            </ol>

            <a name="classes"/>
            <subsection name="The Classes">
                <p>
                    Lets look at our initial classes for the example. We want to represent a pack of cards.
                </p>
                <source><![CDATA[
package org.datanucleus.samples.packofcards.inverse;

public class Pack
{
    String name=null;
    String description=null;

    Set    cards=new HashSet();

    public Pack(String name, String desc)
    {
        this.name = name;
        this.description = desc;
    }

    public void addCard(Card card)
    {
        cards.add(card);
    }

    public void removeCard(Card card)
    {
        cards.remove(card);
    }

    public Set getCards()
    {
        return cards;
    }

    public int getNumberOfCards()
    {
        return cards.size();
    }
}

public class Card
{
    String suit=null;
    String number=null;
    Pack   pack=null;

    public Card(String suit,String number)
    {
        this.suit = suit;
        this.number = number;
    }

    public String getSuit()
    {
        return suit;
    }

    public String getNumber()
    {
        return number;
    }

    public Pack getPack()
    {
        return pack;
    }

    public void setPack(Pack pack)
    {
        this.pack = pack;
    }

    public String toString()
    {
        return "The " + number + " of " + suit;
    }
}]]></source>
            <p>
                The first thing that we need to do is add a default constructor. This is a requirement of JDO. This can be private if we wish, so we add
            </p>
            <source><![CDATA[
public class Pack
{
    private Pack()
    {
    }

    ...
}
public class Card
{
    private Card()
    {
    }

    ...
}]]></source>
                <br/>
            </subsection>

            <a name="identity"/>
            <subsection name="Object Identity">
                <p>
                    The next thing to do is decide if we want to allow DataNucleus to generate the 
                    <a href="../value_generation.html">identities</a> of our objects, or whether we 
                    want to do it ourselves. In our case we will allow DataNucleus to create the identities for 
                    our <b>Pack</b>s and also for our <b>Card</b>s.
                </p>
                <p>
                    In the case of <b>Pack</b> there is nothing more to code since DataNucleus will handle the identities.
                    Similarly, in the case of <b>Card</b> there is nothing more to add.
                </p>
                <br/>
            </subsection>

            <a name="newschema"/>
            <subsection name="MetaData for New Schema">
                <p>
                    Now that we've decided on our classes and how we want to define their identities we can decide on 
                    the precise persistence definition in the datastore. In this section we'll describe how to persist 
                    these objects to a new database schema where we can create new tables and don't need to write to 
                    some existing table.
                </p>
                <p>
                    Some JDO tools provide an IDE to generate Meta-Data files, but DataNucleus doesn't currently. Either way 
                    it is a good idea to become familiar with the structure of these files since they define how your 
                    classes are persisted. Lets start with the header area. You add a block like this to define that 
                    the file is JDO Meta-Data
                </p>
                <source><![CDATA[
<?xml version="1.0"?>
<!DOCTYPE jdo PUBLIC
    "-//Sun Microsystems, Inc.//DTD Java Data Objects Metadata 2.0//EN" 
    "http://java.sun.com/dtd/jdo_2_0.dtd">
<jdo>]]></source>

                <p>
                    Now let's define the persistence for our <b>Pack</b> class. We are going to use 
                    <u>datastore identity</u> here, meaning that DataNucleus will assign id's to each <b>Pack</b> object 
                    persisted. We define it as follows
                </p>
                <source><![CDATA[
    <package name="org.datanucleus.samples.packofcards.inverse">
        <class name="Pack" identity-type="datastore">
            <field name="name" persistence-modifier="persistent">
                <column length="100" jdbc-type="VARCHAR"/>
            </field>
            <field name="description" persistence-modifier="persistent">
                <column length="100" jdbc-type="VARCHAR"/>
            </field>
            <field name="cards" persistence-modifier="persistent" mapped-by="pack">
                <collection element-type="org.datanucleus.samples.packofcards.inverse.Card">
                </collection>
            </field>
        </class>]]></source>
                <p>
                    Here we've defined that our <i>name</i> field will be persisted to a VARCHAR(100) column, 
                    our <i>description</i> field will be persisted to a VARCHAR(255) column, and that our <i>cards</i> 
                    field is a Collection containing <b>org.datanucleus.examples.packofcards.inverse.Card</b> objects. 
                    In addition, it specifies that there is a <i>pack</i> field in the <b>Card</b> class 
                    (the <i>mapped-by</i> attribute) that gives the related pack (with the <b>Pack</b> being the 
                    owner of the relationship). This final information is to inform DataNucleus to link the table for this class 
                    (via a foreign key) to the table for <b>Card</b> class. This is what is termed a 
                    <b><u>ForeignKey</u></b> relationship. Please refer to the 
                    <a href="../orm/one_to_many.html">1-N Relationships Guide</a> for more details 
                    on this. We'll discuss <b><u>join table</u></b> relationships in a different example.
                </p>

                <p>
                    Now lets define the persistence for our <b>Card</b> class. We are going to use 
                    <u>datastore identity</u> here, meaining that DataNucleus will assign the id's for any object of type 
                    <b>Card</b>. We define it as follows
                </p>
                <source><![CDATA[
        <class name="Card" identity-type="datastore">
            <field name="suit">
                <column length="100" jdbc-type="VARCHAR"/>
            </field>
            <field name="number">
                <column length="100" jdbc-type="VARCHAR"/>
            </field>
            <field name="pack">
            </field>
        </class>
    </package>]]></source>
                <p>
                    Here we've defined that our <i>suit</i> field will be persisted to a VARCHAR(10) column, 
                    our <i>number</i> field will be persisted to a VARCHAR(20) column.
                </p>
                <p>
                    We finally terminate the Meta-Data file with the closing tag
                </p>
                <source><![CDATA[</jdo>]]></source>
                <br/>
            </subsection>

            <a name="existingschema"/>
            <subsection name="MetaData for Existing Schema">
                <p>
                    Now that we've decided on our classes and how we want to define their identities we can decide on 
                    the precise persistence definition. In this section we'll describe how to persist these objects 
                    to an existing database schema where we already have some database tables from a previous 
                    persistence mechanism and we want to use those tables (because they have data in them). 
                    Our existing tables are shown below.
                </p>
                <img src="../../images/jdo/one_to_many_bi_fk_existingschema.gif" alt="1-N-Bi-FK-ExistingSchema"/><br/>
                <p>
                    We will take the Meta-Data that was described in the previous section (New Schema) and continue 
                    from there. To recap, here is what we arrived at
                </p>
                <source><![CDATA[
<?xml version="1.0"?>
<!DOCTYPE jdo PUBLIC
    "-//Sun Microsystems, Inc.//DTD Java Data Objects Metadata 2.0//EN" 
    "http://java.sun.com/dtd/jdo_2_0.dtd">
<jdo>
    <package name="org.datanucleus.samples.packofcards.inverse">
        <class name="Pack" identity-type="datastore">
            <field name="name" persistence-modifier="persistent">
                <column length="100" jdbc-type="VARCHAR"/>
            </field>
            <field name="description" persistence-modifier="persistent">
                <column length="255" jdbc-type="VARCHAR"/>
            </field>
            <field name="cards" persistence-modifier="persistent" mapped-by="pack">
                <collection element-type="org.datanucleus.samples.packofcards.inverse.Card">
                </collection>
            </field>
        </class>
        <class name="Card" identity-type="datastore">
            <field name="suit">
                <column length="10" jdbc-type="VARCHAR"/>
            </field>
            <field name="number">
                <column length="20" jdbc-type="VARCHAR"/>
            </field>
            <field name="pack">
            </field>
        </class>
    </package>
</jdo>]]></source>
                <p>
                    The first thing we need to do is map the <b>Pack</b> class to the table that we have in our 
                    database. It needs to be mapped to a table called "DECK", with columns "IDENTIFIERNAME" and 
                    "DETAILS", and the identity column that DataNucleus uses needs to be called IDENTIFIER_ID. 
                    We do this by changing the Meta-Data to be
                </p>
                <source><![CDATA[
        <class name="Pack" identity-type="datastore" table="DECK">
            <datastore-identity>
                <column name="IDENTIFIER_ID"/>
            </datastore-identity>
            <field name="name" persistence-modifier="persistent">
                <column name="IDENTIFIERNAME" length="100" jdbc-type="VARCHAR"/>
            </field>
            <field name="description" persistence-modifier="persistent">
                <column name="DETAILS" length="100" jdbc-type="VARCHAR"/>
            </field>
            <field name="cards" persistence-modifier="persistent" mapped-by="pack">
                <collection element-type="org.datanucleus.samples.packofcards.inverse.Card"/>
            </field>
        </class>]]></source>
                <p> So we made use of the attribute <i>table</i> (of element <b>class</b>) and <i>name</i> (of 
                    element <b>column</b>) to align to the table that is there. In addition we made use of the 
                    <i>datastore-identity</i> element to map the identity column name. Lets now dothe same for the 
                    class <b>Card</b>. In our database we want this to map to a table called "PLAYINGCARD", with 
                    columns "SET" and "VALUE". So we do the same thing to its Meta-Data 
                </p>
                <source><![CDATA[
        <class name="Card" identity-type="datastore" table="PLAYINGCARD">
            <datastore-identity>
                <column name="PLAYINGCARD_ID"/>
            </datastore-identity>
            <field name="suit">
                <column name="SET" length="10" jdbc-type="VARCHAR"/>
            </field>
            <field name="number">
                <column name="VALUE" length="20" jdbc-type="VARCHAR"/>
            </field>
            <field name="pack">
                <column name="DECK_ID"/>
            </field>
        </class>]]></source>

                <p>
                    OK, so we've now mapped our 2 classes to their tables. This completes our job. The only other
                    aspect that is likely to be met is where a column in the database is of a particular type, but 
                    we'll cover that in a different example.
                </p>
                <p>
                    One thing worth mentioning is the difference if our Collection class was a List, ArrayList, 
                    Vector, etc. In this case we need to specify the ordering column for maintaining the order 
                    within the List. In our case we want to specify this column to be called "IDX", so we do it 
                    like this.
                </p>
                <source><![CDATA[
        <class name="Card" identity-type="datastore" table="PLAYINGCARD">
            <datastore-identity>
                <column name="PLAYINGCARD_ID"/>
            </datastore-identity>
            <field name="suit">
                <column name="SET" length="10" jdbc-type="VARCHAR"/>
            </field>
            <field name="number">
                <column name="VALUE" length="20" jdbc-type="VARCHAR"/>
            </field>
            <field name="pack">
                <column name="DECK_ID"/>
                <order column="IDX"/>
            </field>
        </class>]]></source>
                <br/>
            </subsection>

        </section>

    </body>
</document>