<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>JDO Queries - SQL</title>
    </properties>

    <body>
        <section name="JDO : SQL Queries">
            <p>
                The ability to query the datastore is an essential part of any system that persists data. Sometimes an 
                object-based query language (such as JDOQL) is considered not suitable, maybe due to the lack of familiarity
                of the application developer with such a query language. In this case it is desirable to query using 
                <b>SQL</b>. JDO standardises this as a valid query mechanism, and DataNucleus supports this.
                <b>Please be aware that the SQL query that you invoke has to be valid for your RDBMS, and that the SQL 
                syntax differs across almost all RDBMS.</b>
            </p>
            <p>
                To utilise <b>SQL</b> syntax in queries, you create a Query as follows
            </p>
<source>Query q = pm.newQuery("javax.jdo.query.SQL",the_query);</source>
            <p>
                You have several forms of SQL queries, depending on what form of output you require.
            </p>
            <ul>
                <li><b>No candidate class and no result class</b> - the result will be a List of Objects (when there is a 
                single column in the query), or a List of Object[]s (when there are multiple columns in the query)</li>
                <li><b>Candidate class specified, no result class</b> - the result will be a List of candidate class objects,
                or will be a single candidate class object (when you have specified "unique"). The columns of the querys result
                set are matched up to the fields of the candidate class by name. You need to select a minimum of the PK
                columns in the SQL statement.</li>
                <li><b>No candidate class, result class specified</b> - the result will be a List of result class objects, or
                will be a single result class object (when you have specified "unique"). Your result class has to abide by 
                the rules of JDO2 result classes (see <a href="query.html#resultclass">Result Class specification</a>) - this
                typically means either providing public fields matching the columns of the result, or providing 
                setters/getters for the columns of the result.</li>
                <li><b>Candidate class and result class specified</b> - the result will be a List of result class objects, 
                or will be a single result class object (when you have specified "unique"). The result class has to abide by 
                the rules of JDO2 result classes (see <a href="query.html#resultclass">Result Class specification</a>).</li>
            </ul>
            <br/>

            <a name="Class"/>
            <subsection name="Setting candidate class">
                <p>
                    If you want to return instances of persistable types, then you can set the candidate class.
                </p>
                <source><![CDATA[
Query query = pm.newQuery("javax.jdo.query.SQL", "SELECT MY_ID, MY_NAME FROM MYTABLE");
query.setClass(MyClass.class);
List<MyClass> results = (List<MyClass>) query.execute();]]></source>
                <br/>
            </subsection>

            <a name="Unique"/>
            <subsection name="Unique results">
                <p>
                    If you know that there will only be a single row returned from the SQL query then you can set
                    the query as <i>unique</i>. Note that the query will return null if the SQL has no results.
                </p>
                <p>
                    Sometimes you know that the query can only every return 0 or 1 objects. In this case you can 
                    simplify your job by adding
                </p>
                <source><![CDATA[
Query query = pm.newQuery("javax.jdo.query.SQL", "SELECT MY_ID, MY_NAME FROM MYTABLE");
query.setClass(MyClass.class);
query.setUnique(true);
MyClass obj = (MyClass) query.execute();]]></source>
                <br/>
            </subsection>

            <a name="ResultClass"/>
            <subsection name="Defining a result type">
                <p>
                    If you want to dump each row of the SQL query results into an object of a particular type then
                    you can set the result class. 
                </p>
                <source><![CDATA[
Query query = pm.newQuery("javax.jdo.query.SQL", "SELECT MY_ID, MY_NAME FROM MYTABLE");
query.setResultClass(MyResultClass.class);
List<MyResultClass> results = (List<MyClass>) query.execute();]]></source>
                <p>
                    The <i>Result Class</i> has to meet certain requirements. These are
                </p>
                <ul>
                    <li>Can be one of Integer, Long, Short, Float, Double, Character, Byte, Boolean, String, 
                        java.math.BigInteger, java.math.BigDecimal, java.util.Date, java.sql.Date, java.sql.Time,
                        java.sql.Timestamp, or Object[]</li>
                    <li>Can be a user defined class, that has either a constructor taking arguments of the same type
                        as those returned by the query (in the same order), or has a public put(Object, Object) method, 
                        or public setXXX() methods, or public fields.</li>
                </ul>
                <p>
                    For example, if we are returning two columns like above, an <i>int</i> and a <i>String</i> then
                    we define our result class like this
                </p>
                <source>
public class MyResultClass
{
    protected int id = 0;
    protected String name = null;

    public MyResultClass(int id, String name)
    {
        this.id = id;
        this.name = name;
    }

    ...
}</source>
                <p>
                    So here we have a result class using the constructor arguments. We could equally have provided 
                    a class with public fields instead, or provided <i>setXXX</i> methods or a <i>put</i> method. 
                    They all work in the same way.
                </p>
                <br/>
            </subsection>

            <a name="updates"/>
            <subsection name="Inserting/Updating/Deleting">
                <p>
                    In JDO all SQL queries must begin "SELECT ...", and consequently it is not possible to execute
                    queries that change data. In DataNucleus we have an extension that allows this to be overridden. 
                    To enable this you should pass the property <b>datanucleus.query.sql.allowAll</b> as true when 
                    creating the PersistenceManagerFactory. Thereafter you just invoke your statements like this
                </p>
                <source>
Query q = pm.newQuery("javax.jdo.query.SQL", 
    "UPDATE MY_TABLE SET MY_COLUMN = ? WHERE MY_ID = ?");</source>
                <p>
                    you then pass any parameters in as normal for an SQL query. Note that DataNucleus currently supports
                    queries starting "INSERT", "UPDATE", "MERGE", "DELETE" and "CREATE" as update/delete queries and
                    so will be invoked with JDBC <i>executeStatementUpdate</i>. If you have a query starting with something
                    other than that it will be invoked with <i>executeStatementQuery</i>. If your statement really needs
                    to be executed differently then you should look at contributing support for those statements to DataNucleus.
                </p>
                <br/>
            </subsection>

            <a name="parameters"/>
            <subsection name="Parameters">
                <p>
                    In JDO SQL queries can have parameters but must be <i>positional</i>. This means that you do as 
                    follows
                </p>
                <source>
Query q = pm.newQuery("javax.jdo.query.SQL",
    "SELECT col1, col2 FROM MYTABLE WHERE col3 = ? AND col4 = ? and col5 = ?");
List results = (List) q.execute(val1, val2, val3);</source>
                <p>
                    So we used traditional JDBC form of parametrisation, using "?".
                </p>
                <br/>
                <img src="../images/nucleus_extension.gif" alt=""/>
                <p>
                    DataNucleus also supports two further variations. The first is called <i>numbered</i> parameters
                    where we assign numbers to them, so the previous example could have been written like this
                </p>
                <source>
Query q = pm.newQuery("javax.jdo.query.SQL",
    "SELECT col1, col2 FROM MYTABLE WHERE col3 = ?1 AND col4 = ?2 and col5 = ?1");
List results = (List) q.execute(val1, val2);</source>
                <p>
                    so we can reuse parameters in this variation.
                    The second variation  is called <i>named</i> parameters where we assign names to them, and so the
                    example can be furtehr rewritten like this
                </p>
                <source>
Query q = pm.newQuery("javax.jdo.query.SQL",
    "SELECT col1, col2 FROM MYTABLE WHERE col3 = :firstVal AND col4 = :secondVal and col5 = :firstVal");
Map params = new HashMap();
params.put("firstVal", val1);
params.put("secondVal", val1);
List results = (List) q.executeWithMap(params);</source>
                <br/>
            </subsection>

            <br/>

            <subsection name="Example 1 - Using SQL aggregate functions, without candidate class">
                <p>
                    Here's an example for getting the size of a table without a candidate class.
                </p>
                <source>
Query query = pm.newQuery("javax.jdo.query.SQL", "SELECT count(*) FROM MYTABLE");
List results = (List) query.execute();
Integer tableSize = (Integer) result.iterator().next();</source>
                <p>
                    Here's an example for getting the maximum and miminum of a parameter without a candidate class.
                </p>
                <source>
Query query = pm.newQuery("javax.jdo.query.SQL", "SELECT max(PARAM1), min(PARAM1) FROM MYTABLE");
List results = (List) query.execute();
Object[] measures = (Object[])result.iterator().next();
Double maximum = (Double)measures[0];
Double minimum = (Double)measures[1];</source>
                <br/>
            </subsection>

            <subsection name="Example 2 - Using SQL aggregate functions, with result class">
                <p>
                    Here's an example for getting the size of a table with a result class. So we have
                    a result class of
                </p>
                <source>
public class TableStatistics
{
    private int total;

    public setTotal(int total);
}</source>
                <p>
                    So we define our query to populate this class
                </p>
                <source>
Query query = pm.newQuery("javax.jdo.query.SQL", "SELECT count(*) AS total FROM MYTABLE");
query.setResultClass(TableStatistics.class);
List results = (List) query.execute();
TableStatistics tableStats = (TableStatistics) result.iterator().next();</source>
                <p>
                    Each row of the results is of the type of our result class. Since our query is for an aggregate, 
                    there is actually only 1 row.
                </p>
                <br/>
            </subsection>

            <subsection name="Example 3 - Retrieval using candidate class">
                <p>
                    When we want to retrieve objects of a particular persistable class we specify the candidate
                    class. Here we need to select, as a minimum, the identity columns for the class.
                </p>
                <source>
Query query = pm.newQuery("javax.jdo.query.SQL",
                        "SELECT MY_ID, MY_NAME FROM MYTABLE");
query.setClass(MyClass.class);
List results = (List) query.execute();
Iterator resultsIter = results.iterator();
while (resultsIter.hasNext())
{
    MyClass obj = (MyClass)resultsIter.next();
}</source>
                <source><![CDATA[
class MyClass
{
    String name;
    ...
}

<jdo>
    <package name="org.datanucleus.samples.sql">
        <class name="MyClass" identity-type="datastore" table="MYTABLE">
            <datastore-identity strategy="identity">
                <column name="MY_ID"/>
            </datastore-identity>
            <field name="name" persistence-modifier="persistent">
                <column name="MY_NAME"/>
            </field>
        </class>
    </package>
</jdo>]]></source>
                <br/>
            </subsection>

            <subsection name="Example 4 - Using parameters, without candidate class">
                <p>
                    Here's an example for getting the number of people with a particular email address.
                    You simply add a "?" for all parameters that are passed in, and these are subsitituted
                    at execution time.
                </p>
                <source>
Query query = pm.newQuery("javax.jdo.query.SQL", "SELECT count(*) FROM PERSON WHERE EMAIL_ADDRESS = ?");
List results = (List) query.execute("nobody@datanucleus.org");
Integer tableSize = (Integer) result.iterator().next();</source>
                <br/>
            </subsection>

            <subsection name="Example 5 - Named Query">
                <p>
                    While "named" queries were introduced primarily for JDOQL queries, we can define "named" queries
                    for SQL also. So let's take a <i>Product</i> class, and we want to define a query for all products
                    that are "sold out". We firstly add this to our MetaData
                </p>
                <source><![CDATA[
<jdo>
    <package name="org.datanucleus.samples.store">
        <class name="Product" identity-type="datastore" table="PRODUCT">
            <datastore-identity strategy="identity">
                <column name="PRODUCT_ID"/>
            </datastore-identity>
            <field name="name" persistence-modifier="persistent">
                <column name="NAME"/>
            </field>
            <field name="status" persistence-modifier="persistent">
                <column name="STATUS"/>
            </field>

            <query name="SoldOut" language="javax.jdo.query.SQL">
                SELECT PRODUCT_ID FROM PRODUCT WHERE STATUS == "Sold Out"
            </query>
        </class>
    </package>
</jdo>]]></source>
                <p>
                    And then in our application code we utilise the query
                </p>
                <source>
Query q = pm.newNamedQuery(Product.class, "SoldOut");
List results = (List)q.execute();</source>
                <br/>
            </subsection>

        </section>
    </body>
</document>