<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>JDO 1-N Relationships : Set</title>
    </properties>

    <body>
        <section name="JDO : 1-N Relationships with Sets">
            <p>
				You have a 1-N (one to many) or N-1 (many to one) when you have one object of a class that has a Set of objects of 
                another class. <b>Please note that Sets do not allow duplicates, and so the persistence process reflects this with the
                choice of primary keys</b>. There are two ways in which you can represent this in a datastore : 
			    <b>Join Table</b> (where e join table is used to provide the relationship mapping between the objects), and 
				<b>Foreign-Key</b> (where a foreign key is placed in the table of the object contained in the Set.
		    </p>
            <p>
                The various possible relationships are described below.
            </p>
            <ul>
                <li><a href="#join_uni">1-N Unidirectional using Join Table</a></li>
                <li><a href="#fk_uni">1-N Unidirectional using Foreign-Key</a></li>
                <li><a href="#join_bi">1-N Bidirectional using Join Table</a></li>
                <li><a href="#fk_bi">1-N Bidirectional using Foreign-Key</a></li>
                <li><a href="#join_nonpc">1-N Unidirectional of non-PC using Join Table</a></li>
                <li><a href="embedded.html#Collection">1-N embedded elements using Join Table</a></li>
                <li><a href="serialised.html#Collection">1-N Serialised Set</a></li>
                <li><a href="one_to_many_collection.html#shared_join">1-N using shared join table</a></li>
                <li><a href="one_to_many_collection.html#shared_fk">1-N using shared foreign key</a></li>
                <li><a href="compound_identity.html#1_N_coll_bi">1-N Bidirectional "Compound Identity" (owner object 
                as part of PK in element)</a></li>
            </ul>
            <p>
                This page is aimed at Set fields and so applies to fields of Java type
                <i>java.util.HashSet, java.util.LinkedHashSet, java.util.Set, java.util.SortedSet, java.util.TreeSet</i>
            </p>
            <p>
                <b>Please note that RDBMS supports the full range of options on this page, whereas other datastores
                (ODF, Excel, HBase, MongoDB, etc) persist the Set in a column in the owner object (as well as a column
                in the non-owner object when bidirectional) rather than using join-tables or foreign-keys since 
                those concepts are RDBMS-only.</b>
            </p>

            <subsection name="equals() and hashCode()">
                <p>
                    <b>Important : The element of a Collection ought to define the methods <i>equals</i> and 
                    <i>hashCode</i> so that updates are detected correctly.</b> This is because any Java Collection will
                    use these to determine equality and whether an element is <i>contained</i> in the Collection.
                    Note also that the hashCode() should be consistent throughout the lifetime of a persistable
                    object. By that we mean that it should <b>not</b> use some basis before persistence and then use 
                    some other basis (such as the object identity) after persistence, for this reason we do not
                    recommend usage of <i>JDOHelper.getObjectId(obj)</i> in the equals/hashCode methods.
                </p>
            </subsection>
        </section>

        <section name="1-N Set Unidirectional">
            <p>
                We have 2 sample classes <b>Account</b> and <b>Address</b>. These are related in such a way as <b>Account</b>
                contains a <i>Set</i> of objects of type <b>Address</b>, yet each <b>Address</b> knows nothing about the
				<b>Account</b> objects that it relates to. Like this
            </p>
            <img src="../../images/orm/relationship_1_N_uni_set_class.jpg" border="0" alt=""/>
			<p>
				There are 2 ways that we can persist this relationship. These are shown below
			</p>

            <a name="join_uni"/>
			<subsection name="Using Join Table">
                <p>
                    If you define the XML metadata for these classes as follows
                </p>
                <source><![CDATA[
<package name="com.mydomain">
    <class name="Account">
        <field name="id" primary-key="true">
            <column name="ACCOUNT_ID"/>
        </field>
        ...
        <field name="addresses">
            <collection element-type="com.mydomain.Address"/>
            <join/>
        </field>
    </class>

    <class name="Address">
        <field name="id" primary-key="true">
            <column name="ADDRESS_ID"/>
        </field>
        ...
    </class>
</package>]]></source>
                <p>or alternatively using annotations</p>
<source><![CDATA[
public class Account
{
    ...

    @Join
    Set<Address> addresses;
}

public class Address
{
    ...
}]]></source>
                <table>
                    <tr>
                        <td>The crucial part is the <i>join</i> element on the field element - this signals to JDO 
                            to use a join table.</td>
                    </tr>
                </table>
                <p>
                    This will create 3 tables in the database, one for <u>Address</u>, one for <u>Account</u>, 
                    and a join table, as shown below.
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_N_uni_set_join_db.gif" border="0" alt=""/>
                <br/>
                <p>
                    The join table is used to link the 2 classes via foreign keys to their primary key. This is useful where you want to 
                    retain the independence of one class from the other class.
                </p>
                <p>
                    If you wish to fully define the schema table and column names etc, follow these tips
                </p>
                <ul>
                    <li>To specify the name of the table where a class is stored, specify the <i>table</i> attribute on the <b>class</b>
                        element</li>
                    <li>To specify the names of the columns where the fields of a class are stored, specify the <i>column</i> attribute
                        on the <b>field</b> element.</li>
                    <li>To specify the name of the join table, specify the <i>table</i> attribute on the <b>field</b> element
                        with the collection.</li>
                    <li>To specify the names of the join table columns, use the <i>column</i> attribute of <i>join</i>, <i>element</i>
                        elements.</li>
                    <li>To specify the foreign-key between container table and join table, specify &lt;foreign-key&gt; below
                        the &lt;join&gt; element.</li>
                    <li>To specify the foreign-key between join table and element table, specify &lt;foreign-key&gt; below
                        either the &lt;field&gt; element or the &lt;element&gt; element.</li>
                    <li>If you wish to share the join table with another relation then use the
                        <a href="one_to_many_collection.html#shared_join">DataNucleus "shared join table" extension</a></li>
                    <li>The join table will, by default, be given a primary key. If you want to omit this then you can turn it off
                        using the DataNucleus metadata extension "primary-key" (within &lt;join&gt;) set to false.</li>
                    <li>If you want the set to include nulls, you can turn on this behaviour by adding the extension
                        metadata "allow-nulls" to the &lt;field&gt; set to true</li>
                </ul>
                <br/>
            </subsection>

            <a name="fk_uni"/>
            <subsection name="Using Foreign-Key">
                <p>
                    In this relationship, the <u>Account</u> class has a List of <u>Address</u> objects, yet the <u>Address</u>
                    knows nothing about the <u>Account</u>. In this case we don't have a field in the Address to link back to the
                    Account and so DataNucleus has to use columns in the datastore representation of the <u>Address</u> class. So we define
                    the XML metadata like this
                </p>
                <source><![CDATA[
<package name="com.mydomain">
    <class name="Account">
        <field name="id" primary-key="true">
            <column name="ACCOUNT_ID"/>
        </field>
        ...
        <field name="addresses">
            <collection element-type="com.mydomain.Address"/>
            <element column="ACCOUNT_ID"/>
        </field>
    </class>

    <class name="Address">
        <field name="id" primary-key="true">
            <column name="ADDRESS_ID"/>
        </field>
        ...
    </class>
</package>]]></source>
                <p>or alternatively using annotations</p>
<source><![CDATA[
public class Account
{
    ...

    @Element(column="ACCOUNT_ID")
    Set<Address> addresses;
}

public class Address
{
    ...
}]]></source>
                <p> 
                    Again there will be 2 tables, one for <b>Address</b>, and one for <b>Account</b>.
                    Note that we have no "mapped-by" attribute specified, and also no "join" element. If you wish to specify
                    the names of the columns used in the schema for the foreign key in the <u>Address</u> table you should use
                    the <i>element</i> element within the field of the collection.
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_N_uni_set_fk_db.gif" border="0" alt=""/>
                <br/>
                <p>
                    In terms of operation within your classes of assigning the objects in the relationship. You have to take your 
                    <u>Account </u>object and add the <u>Address</u> to the <u>Account</u> collection field since the <u>Address</u> 
                    knows nothing about the <u>Account</u>. Also be aware that each <u>Address</u> object can have only one owner, 
                    since it has a single foreign key to the <u>Account</u>. If you wish to have an <u>Address</u> assigned to multiple 
                    <u>Accounts</u> then you should use the "Join Table" relationship above.
                </p>
                <p>
                    If you wish to fully define the schema table and column names etc, follow these tips
                </p>
                <ul>
                    <li>To specify the name of the table where a class is stored, specify the <i>table</i> attribute on the <b>class</b>
                        element</li>
                    <li>To specify the names of the columns where the fields of a class are stored, specify the <i>column</i> attribute
                        on the <b>field</b> element.</li>
                    <li>To specify the foreign-key between container table and element table, specify &lt;foreign-key&gt; below
                        either the &lt;field&gt; element or the &lt;element&gt; element.</li>
                </ul>
                <br/>
            </subsection>

        </section>

        <section name="1-N Set Bidirectional">
            <p>
                We have 2 sample classes <b>Account</b> and <b>Address</b>. These are related in such a way as <b>Account</b>
                contains a <i>Set</i> of objects of type <b>Address</b>, and each <b>Address</b> has a reference to the
				<b>Account</b> object that it relates to. Like this
            </p>
            <img src="../../images/orm/relationship_1_N_bi_set_class.jpg" border="0" alt=""/>
			<p>
				There are 2 ways that we can persist this relationship. These are shown below
			</p>

            <a name="join_bi"/>
            <subsection name="Using Join Table">
				<p>
                    If you define the XML Metadata for these classes as follows
                </p>
                <source><![CDATA[
<package name="com.mydomain">
    <class name="Account">
        <field name="id" primary-key="true">
            <column name="ACCOUNT_ID"/>
        </field>
        ...
        <field name="addresses" mapped-by="account">
            <collection element-type="com.mydomain.Address"/>
            <join/>
        </field>
    </class>

    <class name="Address">
        <field name="id" primary-key="true">
            <column name="ADDRESS_ID"/>
        </field>
        ...
        <field name="account"/>
    </class>
</package>]]></source>
                <p>or alternatively using annotations</p>
<source><![CDATA[
public class Account
{
    ...

    @Persistent(mappedBy="account")
    @Join
    Set<Address> addresses;
}

public class Address
{
    ...

    Account account;
}]]></source>
                <table>
                    <tr>
                        <td>The crucial part is the <i>join</i> element on the field element - this signals to JDO 
                            to use a join table.</td>
                    </tr>
                </table>
                <p>
                    This will create 3 tables in the database, one for <u>Address</u>, one for <u>Account</u>, 
                    and a join table, as shown below.
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_N_bi_set_join_db.gif" border="0" alt=""/>
                <br/>
                <p>
                    The join table is used to link the 2 classes via foreign keys to their primary key. This is useful where you want to 
                    retain the independence of one class from the other class.
                </p>
                <p>
                    If you wish to fully define the schema table and column names etc, follow these tips
                </p>
                <ul>
                    <li>To specify the name of the table where a class is stored, specify the <i>table</i> attribute on the <b>class</b>
                        element</li>
                    <li>To specify the names of the columns where the fields of a class are stored, specify the <i>column</i> attribute
                        on the <b>field</b> element.</li>
                    <li>To specify the name of the join table, specify the <i>table</i> attribute on the <b>field</b> element
                        with the collection.</li>
                    <li>To specify the names of the join table columns, use the <i>column</i> attribute of <i>join</i>, <i>element</i>
                        elements.</li>
                    <li>To specify the foreign-key between container table and join table, specify &lt;foreign-key&gt; below
                        the &lt;join&gt; element.</li>
                    <li>To specify the foreign-key between join table and element table, specify &lt;foreign-key&gt; below
                        either the &lt;field&gt; element or the &lt;element&gt; element.</li>
                    <li>If you wish to share the join table with another relation then use the
                        <a href="one_to_many_collection.html#shared_join">DataNucleus "shared join table" extension</a></li>
                    <li>The join table will, by default, be given a primary key. If you want to omit this then you can turn it off
                        using the DataNucleus metadata extension "primary-key" (within &lt;join&gt;) set to false.</li>
                    <li>When forming the relation please make sure that <b>you set the relation at BOTH sides</b> since DataNucleus
					    would have no way of knowing which end is correct if you only set one end.</li>
                    <li>If you want the set to include nulls, you can turn on this behaviour by adding the extension
                        metadata "allow-nulls" to the &lt;field&gt; set to true</li>
                </ul>
                <br/>
            </subsection>

            <a name="fk_bi"/>
            <subsection name="Using Foreign-Key">
                <p>Here we have the 2 classes with both knowing about the relationship with the other.</p>
                <p>
                    If you define the XML metadata for these classes as follows
                </p>
                <source><![CDATA[
<package name="com.mydomain">
    <class name="Account">
        <field name="id" primary-key="true">
            <column name="ACCOUNT_ID"/>
        </field>
        ...
        <field name="addresses" mapped-by="account">
            <collection element-type="com.mydomain.Address"/>
        </field>
    </class>

    <class name="Address">
        <field name="id" primary-key="true">
            <column name="ADDRESS_ID"/>
        </field>
        ...
        <field name="account">
            <column name="ACCOUNT_ID"/>
        </field>
    </class>
</package>]]></source>
                <p>or alternatively using annotations</p>
<source><![CDATA[
public class Account
{
    ...

    @Persistent(mappedBy="account")
    Set<Address> addresses;
}

public class Address
{
    ...

    Account account;
}]]></source>
                <table>
                    <tr>
                        <td>The crucial part is the <i>mapped-by</i> attribute of the field on the "1" side of the 
                            relationship. This tells the JDO implementation to look for a field called 
                            <i>account</i> on the <u>Address</u> class.</td>
                    </tr>
                </table>
                <p>
                    This will create 2 tables in the database, one for <u>Address</u> (including an 
                    <i>ACCOUNT_ID</i> to link to the <i>ACCOUNT</i> table), and one for <u>Account</u>. 
                    Notice the subtle difference to this set-up to that of the <b>Join Table</b> relationship earlier.
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_N_bi_set_fk_db.gif" border="0" alt=""/>
                <br/>
                <p>
                    If you wish to fully define the schema table and column names etc, follow these tips
                </p>
                <ul>
                    <li>To specify the name of the table where a class is stored, specify the <i>table</i> attribute on the <b>class</b>
                        element</li>
                    <li>To specify the names of the columns where the fields of a class are stored, specify the <i>column</i> attribute
                        on the <b>field</b> element.</li>
                    <li>To specify the foreign-key between container table and element table, specify &lt;foreign-key&gt; below
                        either the &lt;field&gt; element or the &lt;element&gt; element.</li>
                    <li>When forming the relation please make sure that <b>you set the relation at BOTH sides</b> since DataNucleus
					    would have no way of knowing which end is correct if you only set one end.</li>
                </ul>
                <br/>
            </subsection>
        </section>

        <section name="1-N Set of non-persistable objects">
            <a name="join_nonpc"/>
            <p>
                All of the examples above show a 1-N relationship between 2 <i>persistable</i> classes. DataNucleus can
                also cater for a Collection of primitive or Object types. For example, when you have a Collection of Strings.
                This will be persisted in the same way as the "Join Table" examples above. A join table is created to
                hold the collection elements. Let's take our example. We have an <b>Account</b> that stores a Collection
                of addresses. These addresses are simply Strings. We define the Meta-Data like this
            </p>
            <source><![CDATA[
<package name="com.mydomain">
    <class name="Account">
        <field name="id" primary-key="true">
            <column name="ACCOUNT_ID"/>
        </field>
        ...
        <field name="addresses" persistence-modifier="persistent">
            <collection element-type="java.lang.String"/>
            <join/>
            <element column="ADDRESS"/>
        </field>
    </class>]]></source>
                <p>or alternatively using annotations</p>
<source><![CDATA[
public class Account
{
    ...

    @Join
    @Element(column="ADDRESS")
    Set<String> addresses;
}]]></source>
            <p>
                In the datastore the following is created
            </p>
            <img src="../../images/orm/relationship_1_N_primitive_set_db.gif" border="0" alt=""/>
            <p>
                The ACCOUNT table is as before, but this time we only have the "join table". In our MetaData we used the &lt;element&gt;
                tag to specify the column name to use for the actual address String.
            </p>
            <p>
                Please note that the column ADPT_PK_IDX is added by DataNucleus when the column type of the element is not valid to be
                part of a primary key (with the RDBMS being used). If the column type of your element is acceptable for use as part
                of a primary key then you will not have this "ADPT_PK_IDX" column.
                You can control the name of this column by adding an &lt;order&gt; element and specifying the column name for the order column (within &lt;field&gt;).
            </p>
        </section>

        <section name="Embedded into a Join Table">
            <p>
                The above relationship types assume that both classes in the 1-N relation will have their own table.
                A variation on this is where you have a join table but you embed the elements of the collection into
                this join table. To do this you use the <i>embedded-element</i> attribute on the <i>collection</i>
                MetaData element.
                This is described in <a href="embedded.html#Collection">Embedded Collection Elements</a>.
            </p>
        </section>

        <section name="Serialised into a Join Table">
            <p>
                The above relationship types assume that both classes in the 1-N relation will have their own table.
                A variation on this is where you have a join table but you serialise the elements of the collection into
                this join table in a single column. To do this you use the <i>serialised-element</i> attribute on the
                <i>collection</i> MetaData element.
                This is described in <a href="serialised.html#CollectionElements">Serialised Collection Elements</a>
            </p>
        </section>
    </body>
</document>