<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>JDO Relationships</title>
    </properties>

    <body>
        <section name="JDO : Managing Relationships">
            <p>
                The power of a Java persistence solution like DataNucleus is demonstrated when persisting relationships between objects.
                There are many types of relationships.
            </p>
            <ul>
                <li><a href="one_to_one.html">1-1 relationships</a> - this is where you have an object A relates to a second
                    object B. 
                    The relation can be <i>unidirectional</i> where A knows about B, but B doesnt know about A.
                    The relation can be <i>bidirectional</i> where A knows about B and B knows about A.</li>
                <li><a href="one_to_many_collection.html">1-N relationships</a> - this is where you have an object A that
                    has a collection of other objects of type B. 
                    The relation can be <i>unidirectional</i> where A knows about the objects B but the Bs dont know about A. 
                    The relation can be <i>bidirectional</i> where A knows about the objects B and the Bs know about A</li>
                <li><a href="many_to_one.html">N-1 relationships</a> - this is where you have an object B1 that relates
                    to an object A, and an object B2 that relates to A also etc.
                    The relation can be <i>unidirectional</i> where the A doesnt know about the Bs.
                    The relation can be <i>bidirectional</i> where the A has a collection of the Bs.
                    [i.e a 1-N relationship but from the point of view of the element]</li>
                <li><a href="many_to_many.html">M-N relationships</a> - this is where you have objects of type A that
                    have a collection of objects of type B and the objects of type B also have a collection of objects of type A.
                    The relation is always <i>bidirectional</i> by definition</li>
                <li><a href="compound_identity.html">Compound Identity relationships</a> when you have a relation and part of the
                    primary key of the related object is the other persistent object.</li>
            </ul>

            <subsection name="Assigning Relationships">
                <p>
                    When the relation is <i>unidirectional</i> you simply set the related field to refer to the other object.
                    For example we have classes A and B and the class A has a field of type B. So we set it like this
                </p>
                <source>
A a = new A();
B b = new B();
a.setB(b); // "a" knows about "b"</source>
                <p>
                    When the relation is <i>bidirectional</i> you <b>have to set both sides</b> of the relation.
                    For example, we have classes A and B and the class A has a collection of elements of type B, and B has a
                    field of type A. So we set it like this
                </p>
                <source>
A a = new A();
B b1 = new B();
a.addElement(b1); // "a" knows about "b1"
b1.setA(a); // "b1" knows about "a"</source>
                <table class="infoTable"><tr>
                    <td><img src="../../images/lightbulb.png" border="0"/></td>
                    <td><b>With a <i>bidirectional</i> relation you must set both sides of the relation</b></td>
                </tr></table>
                <br/>
            </subsection>

            <a name="Reachability"/>
            <subsection name="Reachability">
                <p>
                    With JDO, when you persist an object, all related objects (reachable from the fields of the object being persisted) will be persisted
                    at the same time (unless already persistent). This is called <i>persistence-by-reachability</i>. For example
                </p>
<source>
A a = new A();
B b = new B();
a.setB(b);
pm.makePersistent(a); // "a" and "b" are now provisionally persistent
</source>
                <p>
                    This additionally applies when you have an object managed by the PersistenceManager, and you set a field to refer to a related object - 
                    this will make the related object provisionally persistent also. For example
                </p>
<source>
A a = new A();
pm.makePersistent(a); // "a" is now provisionally persistent
B b = new B();
a.setB(b); // "b" is now provisionally persistent
</source>
                <p>
                    <b>Persistence-By-Reachability-At-Commit</b> : One additional feature of JDO is the ability to re-run the <i>persistence-by-reachability</i> 
                    algorithm <b>at commit</b> so as to check whether the objects being made persistent should definitely be persisted. 
                    This is for the following situation.
                    <ul>
                        <li>Start a transaction</li>
                        <li>Persist object A. This persists related object B.</li>
                        <li>Delete object A from persistence</li>
                        <li>Commit the transaction.</li>
                    </ul>
                    If you have property <b>datanucleus.persistenceByReachabilityAtCommit</b> set to true (default) then this will recheck the persisted objects
                    should remain persistent. In this case it will find B and realise that it was only persisted due to A (which has since been deleted), hence B
                    will not remain persistent after the transaction.<br/>
                    If you had property <b>datanucleus.persistenceByReachabilityAtCommit</b> set to false then B will remain persistent after the transaction. 
                </p>
                <br/>
            </subsection>

            <a name="managed"/>
            <subsection name="Managed Relationships">
                <p>
                    As previously mentioned, users should really set both sides of a bidirectional relation.
                    DataNucleus provides a good level of <i>managed relations</i> in that it
                    will <i>attempt</i> to correct any missing information in relations to make both sides consistent.
                    What it provides is defined below
                </p>
                <p>
                    For a <i>1-1 bidirectional relation</i>, at persist you should set one side of the relation and 
                    the other side will be set to make it consistent. If the respective sides are set to inconsistent
                    objects then an exception will be thrown at persist. 
                    At update of owner/non-owner side the other side will also be updated to make them consistent.
                </p>
                <p>
                    For a <i>1-N bidirectional relation</i> and you only specify the element owner then the
                    collection must be Set-based since DataNucleus cannot generate indexing information for you in that
                    situation (you must position the elements).
                    At update of element or owner the other side will also be updated to make them consistent.
                    At delete of element the owner collection will also be updated to make them consistent.
                    <b>If you are using a List you MUST set both sides of the relation</b>
                </p>
                <p>
                    For an <i>M-N bidirectional relation</i>, at persist you MUST set one side and the other side
                    will be populated at commit/flush to make them consistent.
                </p>
                <p>
                    This management of relations can be turned on/off using a persistence property <b>datanucleus.manageRelationships</b>. 
                    If you always set both sides of a relation at persist/update then you could safely turn it off.
                </p>
                <table class="infoTable"><tr>
                    <td><img src="../../images/lightbulb.png" border="0"/></td>
                    <td>
                        When performing management of relations there are some checks implemented to spot typical errors in user operations 
                        e.g add an element to a collection and then remove it (why?!). 
                        You can disable these checks using <b>datanucleus.manageRelationshipsChecks</b>, set to false.
                    </td>
                </tr></table>
            </subsection>
        </section>

    </body>
</document>