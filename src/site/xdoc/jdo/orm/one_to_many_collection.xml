<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>JDO 1-N Relationships : Collection</title>
    </properties>

    <body>
        <section name="JDO : 1-N Relationships with Collections">
            <p>
				You have a 1-N (one to many) or N-1 (many to one) when you have one object of a class that has a Collection of objects of 
                another class.
                <b>Please note that Collections allow duplicates whilst Sets don't allow duplicates, and so the persistence process reflects this with the choice of primary keys.</b>. 
		    </p>
            <p>
                Various possible relationships are described below.
            </p>
            <ul>
                <li><a href="#join_uni">1-N Unidirectional using Join Table</a></li>
                <li><a href="#fk_uni">1-N Unidirectional using Foreign-Key</a></li>
                <li><a href="#join_bi">1-N Bidirectional using Join Table</a></li>
                <li><a href="#fk_bi">1-N Bidirectional using Foreign-Key</a></li>
                <li><a href="#join_nonpc">Collection of non-PC using Join Table</a></li>
                <li><a href="#converter_nonpc">Collection of non-PC using AttributeConverter into single column</a></li>
                <li><a href="embedded.html#Collection">1-N embedded elements using Join Table</a></li>
                <li><a href="serialised.html#Collection">1-N Serialised collection</a></li>
                <li><a href="#shared_join">1-N using shared join table</a> (DataNucleus Extension)</li>
                <li><a href="#shared_fk">1-N using shared foreign key</a> (DataNucleus Extension)</li>
                <li><a href="compound_identity.html#1_N_coll_bi">1-N Bidirectional "Compound Identity" (owner object as part of PK in element)</a></li>
            </ul>
            <p>
                <b>Important : If you declare a field as a Collection, you can instantiate it as either Set-based
                or as List-based. With a List an "ordering" column is required, whereas with a Set it isn't. Consequently
                DataNucleus needs to know if you plan on using it as Set-based or List-based. You do this by adding an "order"
                element to the field if it is to be instantiated as a List-based collection. If there is no "order"
                element, then it will be assumed to be Set-based.</b>
            </p>
            <p>
                <b>Please note that RDBMS supports the full range of options on this page, whereas other datastores
                (ODF, Excel, HBase, MongoDB, etc) persist the Collection in a column in the owner object (as well as a column
                in the non-owner object when bidirectional) rather than using join-tables or foreign-keys since 
                those concepts are RDBMS-only.</b>
            </p>

            <subsection name="equals() and hashCode()">
                <p>
                    <b>Important : The element of a Collection ought to define the methods <i>equals</i> and 
                    <i>hashCode</i> so that updates are detected correctly.</b> This is because any Java Collection will
                    use these to determine equality and whether an element is <i>contained</i> in the Collection.
                    Note also that the hashCode() should be consistent throughout the lifetime of a persistable
                    object. By that we mean that it should <b>not</b> use some basis before persistence and then use 
                    some other basis (such as the object identity) after persistence, for this reason we do not
                    recommend usage of <i>JDOHelper.getObjectId(obj)</i> in the equals/hashCode methods.
                </p>
            </subsection>
        </section>

        <section name="1-N Collection Unidirectional">
            <p>
                We have 2 sample classes <b>Account</b> and <b>Address</b>. These are related in such a way as <b>Account</b>
                contains a <i>Collection</i> of objects of type <b>Address</b>, yet each <b>Address</b> knows nothing about the
				<b>Account</b> objects that it relates to. Like this
            </p>
            <img src="../../images/orm/relationship_1_N_uni_collection_class.jpg" border="0" alt=""/>
			<p>
				There are 2 ways that we can persist this relationship. These are shown below
			</p>

            <a name="join_uni"/>
			<subsection name="Using Join Table">
                <p>
                    If you define the XML metadata for these classes as follows
                </p>
                <source><![CDATA[
<package name="com.mydomain">
    <class name="Account">
        <field name="id" primary-key="true">
            <column name="ACCOUNT_ID"/>
        </field>
        ...
        <field name="addresses" table="ACCOUNT_ADDRESSES">
            <collection element-type="com.mydomain.Address"/>
            <join column="ACCOUNT_ID_OID"/>
            <element column="ADDRESS_ID_EID"/>
        </field>
    </class>

    <class name="Address">
        <field name="id" primary-key="true">
            <column name="ADDRESS_ID"/>
        </field>
        ...
    </class>
</package>]]></source>
                <p>or alternatively using annotations</p>
<source><![CDATA[
public class Account
{
    ...

    @Persistent(table="ACCOUNT_ADDRESSES")
    @Join(column="ACCOUNT_ID_OID")
    @Element(column="ADDRESS_ID_EID")
    Collection<Address> addresses;
}

public class Address
{
    ...
}]]></source>
                <table>
                    <tr>
                        <td>The crucial part is the <i>join</i> element on the field element - this signals to 
                            JDO to use a join table.</td>
                    </tr>
                </table>
                <p>
                    This will create 3 tables in the database, one for <b>Address</b>, one for <b>Account</b>, 
                    and a join table, as shown below.
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_N_uni_collection_join_db.jpg" border="0" alt=""/>
                <br/>
                <p>
                    The join table is used to link the 2 classes via foreign keys to their primary key. This is useful where you want to 
                    retain the independence of one class from the other class.
                </p>
                <p>
                    If you wish to fully define the schema table and column names etc, follow these tips
                </p>
                <ul>
                    <li>To specify the name of the table where a class is stored, specify the <i>table</i> attribute on the <b>class</b> element</li>
                    <li>To specify the names of the columns where the fields of a class are stored, specify the <i>column</i> attribute on the <b>field</b> element.</li>
                    <li>To specify the name of the join table, specify the <i>table</i> attribute on the <b>field</b> element with the collection.</li>
                    <li>To specify the names of the join table columns, use the <i>column</i> attribute of <i>join</i>, <i>element</i> elements.</li>
                    <li>To specify the foreign-key between container table and join table, specify &lt;foreign-key&gt; below the &lt;join&gt; element.</li>
                    <li>To specify the foreign-key between join table and element table, specify &lt;foreign-key&gt; below
                        either the &lt;field&gt; element or the &lt;element&gt; element.</li>
                    <li>If you wish to share the join table with another relation then use the <a href="#shared_join">DataNucleus "shared join table" extension</a></li>
                    <li>The join table will, by default, be given a primary key. If you want to omit this then you can turn it off
                        using the DataNucleus metadata extension "primary-key" (within &lt;join&gt;) set to false.</li>
                    <li>The column "ADPT_PK_IDX" is added by DataNucleus so that duplicates can be stored. You can control this by
                        adding an &lt;order&gt; element and specifying the column name for the order column (within &lt;field&gt;).</li>
                    <li>If you want the set to include nulls, you can turn on this behaviour by adding the DataNucleus extension metadata "allow-nulls" to the &lt;field&gt; set to true</li>
                </ul>
                <br/>
            </subsection>

            <a name="fk_uni"/>
            <subsection name="Using Foreign-Key">
                <p>
                    In this relationship, the <b>Account</b> class has a List of <b>Address</b> objects, yet the <b>Address</b>
                    knows nothing about the <b>Account</b>. In this case we don't have a field in the Address to link back to the
                    Account and so DataNucleus has to use columns in the datastore representation of the <b>Address</b> class. So we define
                    the XML metadata like this
                </p>
                <source><![CDATA[
<package name="com.mydomain">
    <class name="Account">
        <field name="id" primary-key="true">
            <column name="ACCOUNT_ID"/>
        </field>
        ...
        <field name="addresses">
            <collection element-type="com.mydomain.Address"/>
            <element column="ACCOUNT_ID"/>
        </field>
    </class>

    <class name="Address">
        <field name="id" primary-key="true">
            <column name="ADDRESS_ID"/>
        </field>
        ...
    </class>
</package>]]></source>
                <p>or alternatively using annotations</p>
<source><![CDATA[
public class Account
{
    ...

    @Element(column="ACCOUNT_ID")
    Collection<Address> addresses;
}

public class Address
{
    ...
}]]></source>
                <p> 
                    Again there will be 2 tables, one for <b>Address</b>, and one for <b>Account</b>.
                    Note that we have no "mapped-by" attribute specified, and also no "join" element. If you wish to specify
                    the names of the columns used in the schema for the foreign key in the <b>Address</b> table you should use
                    the <i>element</i> element within the field of the collection.
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_N_uni_collection_fk_db.jpg" border="0" alt=""/>
                <br/>
                <p>
                    In terms of operation within your classes of assigning the objects in the relationship. You have to take your <b>Account</b> object and 
                    add the <b>Address</b> to the <b>Account</b> collection field since the <b>Address</b> knows nothing about the <b>Account</b>.
                </p>
                <p>
                    If you wish to fully define the schema table and column names etc, follow these tips
                </p>
                <ul>
                    <li>To specify the name of the table where a class is stored, specify the <i>table</i> attribute on the <b>class</b> element</li>
                    <li>To specify the names of the columns where the fields of a class are stored, specify the <i>column</i> attribute on the <b>field</b> element.</li>
                    <li>To specify the foreign-key between container table and element table, specify &lt;foreign-key&gt; below
                        either the &lt;field&gt; element or the &lt;element&gt; element.</li>
                </ul>
                <p>
                    <b>Limitation : </b> Since each Address object can have at most one owner (due to the "Foreign Key") this mode
                    of persistence will not allow duplicate values in the Collection. If you want to allow duplicate Collection entries, then
                    use the "Join Table" variant above.
                </p>
                <br/>
            </subsection>

        </section>

        <section name="1-N Collection Bidirectional">
            <p>
                We have 2 sample classes <b>Account</b> and <b>Address</b>. These are related in such a way as <b>Account</b>
                contains a <i>Collection</i> of objects of type <b>Address</b>, and each <b>Address</b> has a reference to the
				<b>Account</b> object that it relates to. Like this
            </p>
            <img src="../../images/orm/relationship_1_N_bi_collection_class.jpg" border="0" alt=""/>
			<p>
				There are 2 ways that we can persist this relationship. These are shown below
			</p>

            <a name="join_bi"/>
            <subsection name="Using Join Table">
				<p>
                    If you define the XML metadata for these classes as follows
                </p>
                <source><![CDATA[
<package name="com.mydomain">
    <class name="Account">
        <field name="id" primary-key="true">
            <column name="ACCOUNT_ID"/>
        </field>
        ...
        <field name="addresses" mapped-by="account">
            <collection element-type="com.mydomain.Address"/>
            <join/>
        </field>
    </class>

    <class name="Address">
        <field name="id" primary-key="true">
            <column name="ADDRESS_ID"/>
        </field>
        ...
        <field name="account"/>
    </class>
</package>]]></source>
                <p>or alternatively using annotations</p>
<source><![CDATA[
public class Account
{
    ...

    @Persistent(mappedBy="account")
    @Join
    Collection<Address> addresses;
}

public class Address
{
    ...
}]]></source>
                <table>
                    <tr>
                        <td>The crucial part is the <i>join</i> element on the field element - this signals to 
                            JDO to use a join table.</td>
                    </tr>
                </table>
                <p>
                    This will create 3 tables in the database, one for <b>Address</b>, one for <b>Account</b>, 
                    and a join table, as shown below.
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_N_bi_collection_join_db.jpg" border="0" alt=""/>
                <br/>
                <p>
                    The join table is used to link the 2 classes via foreign keys to their primary key. This is useful where you want to 
                    retain the independence of one class from the other class.
                </p>
                <p>
                    If you wish to fully define the schema table and column names etc, follow these tips
                </p>
                <ul>
                    <li>To specify the name of the table where a class is stored, specify the <i>table</i> attribute on the <b>class</b> element</li>
                    <li>To specify the names of the columns where the fields of a class are stored, specify the <i>column</i> attribute on the <b>field</b> element.</li>
                    <li>To specify the name of the join table, specify the <i>table</i> attribute on the <b>field</b> element with the collection.</li>
                    <li>To specify the names of the join table columns, use the <i>column</i> attribute of <i>join</i>, <i>element</i> elements.</li>
                    <li>To specify the foreign-key between container table and join table, specify &lt;foreign-key&gt; below the &lt;join&gt; element.</li>
                    <li>To specify the foreign-key between join table and element table, specify &lt;foreign-key&gt; below
                        either the &lt;field&gt; element or the &lt;element&gt; element.</li>
                    <li>If you wish to share the join table with another relation then use the <a href="#shared_join">DataNucleus "shared join table" extension</a></li>
                    <li>The join table will, by default, be given a primary key. If you want to omit this then you can turn it off
                        using the DataNucleus metadata extension "primary-key" (within &lt;join&gt;) set to false.</li>
                    <li>The column "ADPT_PK_IDX" is added by DataNucleus so that duplicates can be stored. You can control this by
                        adding an &lt;order&gt; element and specifying the column name for the order column (within &lt;field&gt;).</li>
                    <li>When forming the relation please make sure that <b>you set the relation at BOTH sides</b> since DataNucleus
					    would have no way of knowing which end is correct if you only set one end.</li>
                    <li>If you want the set to include nulls, you can turn on this behaviour by adding the extension metadata "allow-nulls" to the &lt;field&gt; set to true</li>
                </ul>
                <br/>
            </subsection>

            <a name="fk_bi"/>
            <subsection name="Using Foreign-Key">
                <p>Here we have the 2 classes with both knowing about the relationship with the other.</p>
                <p>
                    If you define the XML metadata for these classes as follows
                </p>
                <source><![CDATA[
<package name="com.mydomain">
    <class name="Account">
        <field name="id" primary-key="true">
            <column name="ACCOUNT_ID"/>
        </field>
        ...
        <field name="addresses" mapped-by="account">
            <collection element-type="com.mydomain.Address"/>
        </field>
    </class>

    <class name="Address">
        <field name="id" primary-key="true">
            <column name="ADDRESS_ID"/>
        </field>
        ...
        <field name="account">
            <column name="ACCOUNT_ID"/>
        </field>
    </class>
</package>]]></source>
                <p>or alternatively using annotations</p>
<source><![CDATA[
public class Account
{
    ...

    @Persistent(mappedBy="account")
    Collection<Address> addresses;
}

public class Address
{
    ...
}]]></source>
                <table>
                    <tr>
                        <td>The crucial part is the <i>mapped-by</i> on the "1" side of the relationship. 
                            This tells the JDO implementation to look for a field called <i>account</i> on the <b>Address</b> class.</td>
                    </tr>
                </table>
                <p>
                    This will create 2 tables in the database, one for <b>Address</b> (including an 
                    <i>ACCOUNT_ID</i> to link to the <i>ACCOUNT</i> table), and one for <b>Account</b>.
                    Notice the subtle difference to this set-up to that of the <b>Join Table</b> relationship earlier.
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_N_bi_collection_fk_db.jpg" border="0" alt=""/>
                <br/>
                <p>
                    If you wish to fully define the schema table and column names etc, follow these tips
                </p>
                <ul>
                    <li>To specify the name of the table where a class is stored, specify the <i>table</i> attribute on the <b>class</b> element</li>
                    <li>To specify the names of the columns where the fields of a class are stored, specify the <i>column</i> attribute on the <b>field</b> element.</li>
                    <li>To specify the foreign-key between container table and element table, specify &lt;foreign-key&gt; below
                        either the &lt;field&gt; element or the &lt;element&gt; element.</li>
                    <li>When forming the relation please make sure that <b>you set the relation at BOTH sides</b> since DataNucleus
					    would have no way of knowing which end is correct if you only set one end.</li>
                </ul>
                <p>
                    <b>Limitation : </b> Since each Address object can have at most one owner (due to the "Foreign Key") this mode
                    of persistence will not allow duplicate values in the Collection. If you want to allow duplicate Collection entries, then
                    use the "Join Table" variant above.
                </p>
                <br/>
            </subsection>
        </section>

        <section name="1-N Collection of non-persistable objects">
            <a name="join_nonpc"/>
            <p>
                All of the examples above show a 1-N relationship between 2 <i>persistable</i> classes. DataNucleus can
                also cater for a Collection of primitive or Object types. For example, when you have a Collection of Strings.
                This will be persisted in the same way as the "Join Table" examples above. A join table is created to
                hold the collection elements. Let's take our example. We have an <b>Account</b> that stores a Collection
                of addresses. These addresses are simply Strings. We define the XML metadata like this
            </p>
            <source><![CDATA[
<package name="com.mydomain">
    <class name="Account">
        <field name="id" primary-key="true">
            <column name="ACCOUNT_ID"/>
        </field>
        ...
        <field name="addresses" persistence-modifier="persistent">
            <collection element-type="java.lang.String"/>
            <join/>
            <element column="ADDRESS"/>
        </field>
    </class>]]></source>
                <p>or alternatively using annotations</p>
<source><![CDATA[
public class Account
{
    ...

    @Persistent
    @Join
    @Element(column="ADDRESS")
    Collection<String> addresses;
}]]></source>
            <p>
                In the datastore the following is created
            </p>
            <img src="../../images/orm/relationship_1_N_primitive_collection_db.gif" border="0" alt=""/>
            <p>
                The ACCOUNT table is as before, but this time we only have the "join table". In our MetaData we used the &lt;element&gt;
                tag to specify the column name to use for the actual address String.
            </p>
            <p>
                Please note that the column ADPT_PK_IDX is added by DataNucleus so that duplicates can be stored.
                You can control the name of this column by adding an &lt;order&gt; element and specifying the column name for the order column (within &lt;field&gt;).
            </p>
        </section>

        <section name="Collection of non-persistable objects using AttributeConverter">
            <a name="converter_nonpc"/>
            <p>
                Just like in the above example, here we have a Collection of simple types. In this case we are wanting to store this Collection into
                a single column in the owning table. We do this by using a JDO AttributeConverter.
            </p>
<source><![CDATA[
public class Account
{
    ...

    @Persistent
    @Convert(CollectionStringToStringConverter.class)
    @Column(name="ADDRESSES")
    Collection<String> addresses;
}]]></source>
            <p>
                and then define our converter. You can clearly define your conversion process how you want it. You could, for example, convert the
                Collection into comma-separated strings, or could use JSON, or XML, or some other format.
            </p>
<source><![CDATA[

public class CollectionStringToStringConverter implements AttributeConverter<Collection<String>, String>
{
    public String convertToDatastore(Collection<String> attribute)
    {
        if (attribute == null)
        {
            return null;
        }

        StringBuilder str = new StringBuilder();
        ... convert Collection to String
        return str.toString();
    }

    public Collection<String> convertToAttribute(String columnValue)
    {
        if (columnValue == null)
        {
            return null;
        }

        Collection<String> coll = new HashSet<String>();
        ... convert String to Collection
        return coll;
    }
}]]></source>
        </section>

        <section name="Embedded into a Join Table">
            <p>
                The above relationship types assume that both classes in the 1-N relation will have their own table.
                A variation on this is where you have a join table but you embed the elements of the collection into
                this join table. To do this you use the <i>embedded-element</i> attribute on the <i>collection</i>
                MetaData element.
                This is described in <a href="embedded.html#Collection">Embedded Collection Elements</a>.
            </p>
        </section>

        <section name="Serialised into a Join Table">
            <p>
                The above relationship types assume that both classes in the 1-N relation will have their own table.
                A variation on this is where you have a join table but you serialise the elements of the collection into
                this join table in a single column. To do this you use the <i>serialised-element</i> attribute on the
                <i>collection</i> MetaData element.
                This is described in <a href="serialised.html#CollectionElements">Serialised Collection Elements</a>
            </p>
        </section>
        
        <section name="Shared Join Tables">
        <a name="shared_join"/>
            <img src="../../images/nucleus_extension.gif" border="0" alt=""/>
            <p>
                The relationships using join tables shown above rely on the join table relating to the relation in question.
                DataNucleus allows the possibility of sharing a join table between relations. The example below
                demonstrates this. We take the example as <a href="#join_uni">show above</a> (1-N Unidirectional 
                Join table relation), and extend <b>Account</b> to have 2 collections of <b>Address</b> records. One for 
                home addresses and one for work addresses, like this
            </p>
            <img src="../../images/orm/relationship_1_N_uni_join_shared_class.gif" border="0" alt=""/>
            <p>
                We now change the metadata we had earlier to allow for 2 collections, but sharing the join table
            </p>
            <source><![CDATA[
<package name="com.mydomain">
    <class name="Account">
        <field name="id" primary-key="true">
            <column name="ACCOUNT_ID"/>
        </field>
        ...
        <field name="workAddresses" persistence-modifier="persistent" table="ACCOUNT_ADDRESSES">
            <collection element-type="com.mydomain.Address"/>
            <join column="ACCOUNT_ID_OID"/>
            <element column="ADDRESS_ID_EID"/>
            <extension vendor-name="datanucleus" key="relation-discriminator-column" value="ADDRESS_TYPE"/>
            <extension vendor-name="datanucleus" key="relation-discriminator-pk" value="true"/>
            <extension vendor-name="datanucleus" key="relation-discriminator-value" value="work"/>
        </field>
        <field name="homeAddresses" persistence-modifier="persistent" table="ACCOUNT_ADDRESSES">
            <collection element-type="com.mydomain.Address"/>
            <join column="ACCOUNT_ID_OID"/>
            <element column="ADDRESS_ID_EID"/>
            <extension vendor-name="datanucleus" key="relation-discriminator-column" value="ADDRESS_TYPE"/>
            <extension vendor-name="datanucleus" key="relation-discriminator-pk" value="true"/>
            <extension vendor-name="datanucleus" key="relation-discriminator-value" value="home"/>
        </field>
    </class>

    <class name="Address">
        <field name="id" primary-key="true">
            <column name="ADDRESS_ID"/>
        </field>
        ...
    </class>
</package>]]></source>
            <p>or with annotations</p>
<source><![CDATA[
import org.datanucleus.api.jdo.annotations.SharedRelation;

public class Account
{
    ...

    @Persistent
    @Join(table="ACCOUNT_ADDRESSES", columns={@Column(name="ACCOUNT_ID_OID")})
    @Element(columns={@Column(name="ADDRESS_ID_EID")})
    @SharedRelation(column="ADDRESS_TYPE", value="work")
    Collection<Address> workAddresses;

    @Persistent
    @Join(table="ACCOUNT_ADDRESSES", columns={@Column(name="ACCOUNT_ID_OID")})
    @Element(columns={@Column(name="ADDRESS_ID_EID")})
    @SharedRelation(column="ADDRESS_TYPE", value="home")
    Collection<Address> homeAddresses;

    ...
}]]></source>
            <p>
                So we have defined the same join table for the 2 collections "ACCOUNT_ADDRESSES", and the same columns
                in the join table, meaning that we will be sharing the same join table to represent both relations. The
                important step is then to define the 3 DataNucleus <i>extension</i> tags. These define a column in the join table
                (the same for both relations), and the value that will be populated when a row of that collection is
                inserted into the join table. In our case, all "home" addresses will have a value of "home" inserted into
                this column, and all "work" addresses will have "work" inserted. This means we can now identify easily which
                join table entry represents which relation field.
            </p>
            <p>
                This results in the following database schema
            </p>
            <img src="../../images/orm/relationship_1_N_uni_join_shared_db.gif" border="0" alt=""/>
        </section>

        <section name="Shared Foreign Key">
        <a name="shared_fk"/>
            <img src="../../images/nucleus_extension.gif" border="0" alt=""/>
            <p>
                The relationships using foreign keys shown above rely on the foreign key relating to the relation in question.
                DataNucleus allows the possibility of sharing a foreign key between relations between the same classes. 
                The example below demonstrates this. We take the example as <a href="#fk_uni">show above</a> (1-N Unidirectional 
                Foreign Key relation), and extend <b>Account</b> to have 2 collections of <b>Address</b> records. One for 
                home addresses and one for work addresses, like this
            </p>
            <img src="../../images/orm/relationship_1_N_uni_fk_shared_class.gif" border="0" alt=""/>
            <p>
                We now change the metadata we had earlier to allow for 2 collections, but sharing the join table
            </p>
            <source><![CDATA[
<package name="com.mydomain">
    <class name="Account">
        <field name="id" primary-key="true">
            <column name="ACCOUNT_ID"/>
        </field>
        ...
        <field name="workAddresses" persistence-modifier="persistent">
            <collection element-type="com.mydomain.Address"/>
            <element column="ACCOUNT_ID_OID"/>
            <extension vendor-name="datanucleus" key="relation-discriminator-column" value="ADDRESS_TYPE"/>
            <extension vendor-name="datanucleus" key="relation-discriminator-value" value="work"/>
        </field>
        <field name="homeAddresses" persistence-modifier="persistent">
            <collection element-type="com.mydomain.Address"/>
            <element column="ACCOUNT_ID_OID"/>
            <extension vendor-name="datanucleus" key="relation-discriminator-column" value="ADDRESS_TYPE"/>
            <extension vendor-name="datanucleus" key="relation-discriminator-value" value="home"/>
        </field>
    </class>

    <class name="Address">
        <field name="id" primary-key="true">
            <column name="ADDRESS_ID"/>
        </field>
        ...
    </class>
</package>]]></source>
            <p>or with annotations</p>
<source><![CDATA[
import org.datanucleus.api.jdo.annotations.SharedRelation;

public class Account
{
    ...

    @Persistent
    @SharedRelation(column="ADDRESS_TYPE", value="work")
    Collection<Address> workAddresses;

    @Persistent
    @SharedRelation(column="ADDRESS_TYPE", value="home")
    Collection<Address> homeAddresses;

    ...
}]]></source>
            <p>
                So we have defined the same foreign key for the 2 collections "ACCOUNT_ID_OID", The
                important step is then to define the 2 DataNucleus <i>extension</i> tags. These define a column in the element table
                (the same for both relations), and the value that will be populated when a row of that collection is
                inserted into the element table. In our case, all "home" addresses will have a value of "home" inserted into
                this column, and all "work" addresses will have "work" inserted. This means we can now identify easily which
                element table entry represents which relation field.
            </p>
            <p>
                This results in the following database schema
            </p>
            <img src="../../images/orm/relationship_1_N_uni_fk_shared_db.gif" border="0" alt=""/>
        </section>
    </body>
</document>