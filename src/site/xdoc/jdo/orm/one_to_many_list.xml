<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>JDO 1-N Relationships : List</title>
    </properties>

    <body>
        <section name="JDO : 1-N Relationships with Lists">
            <p>
				You have a 1-N (one to many) or N-1 (many to one) when you have one object of a class that has a List of objects of 
                another class. There are two ways in which you can represent this in a datastore.
                <b>Join Table</b> (where a join table is used to provide the relationship mapping between the objects), and 
                <b>Foreign-Key</b> (where a foreign key is placed in the table of the object contained in the List.
            </p>
            <p>
                The various possible relationships are described below.
            </p>
            <ul>
                <li><a href="#join_uni">1-N Unidirectional using Join Table</a></li>
                <li><a href="#fk_uni">1-N Unidirectional using Foreign-Key</a></li>
                <li><a href="#fk_ordered">1-N Ordered List using Foreign-Key</a></li>
                <li><a href="#join_bi">1-N Bidirectional using Join Table</a></li>
                <li><a href="#fk_bi">1-N Bidirectional using Foreign-Key</a></li>
                <li><a href="#join_nonpc">List of non-PC using Join Table</a></li>
                <li><a href="#converter_nonpc">List of non-PC using AttributeConverter into single column</a></li>
                <li><a href="embedded.html#Collection">1-N embedded elements using Join Table</a></li>
                <li><a href="serialised.html#Collection">1-N Serialised List</a></li>
                <li><a href="one_to_many_collection.html#shared_join">1-N using shared join table</a></li>
                <li><a href="one_to_many_collection.html#shared_fk">1-N using shared foreign key</a></li>
                <li><a href="compound_identity.html#1_N_coll_bi">1-N Bidirectional "Compound Identity" (owner object 
                as part of PK in element)</a></li>
            </ul>
            <p>
                This page is aimed at List fields and so applies to fields of Java type
                <i>java.util.ArrayList, java.util.LinkedList, java.util.List, java.util.Stack, java.util.Vector</i>
            </p>
            <table class="infoTable"><tr>
                <td><img src="../../images/lightbulb.png" border="0"/></td>
                <td>
                    Please note that RDBMS supports the full range of options on this page, whereas other datastores (ODF, Excel, HBase, MongoDB, etc) persist the List in a 
                    column in the owner object (as well as a column in the non-owner object when bidirectional) rather than using join-tables or foreign-keys since 
                    those concepts are RDBMS-only.
                </td>
            </tr></table>
            <br/>

            <subsection name="equals() and hashCode()">
                <p>
                    <b>Important : The element of a Collection ought to define the methods <i>equals</i> and 
                    <i>hashCode</i> so that updates are detected correctly.</b> This is because any Java Collection will
                    use these to determine equality and whether an element is <i>contained</i> in the Collection.
                    Note also that the hashCode() should be consistent throughout the lifetime of a persistable
                    object. By that we mean that it should <b>not</b> use some basis before persistence and then use 
                    some other basis (such as the object identity) after persistence, for this reason we do not
                    recommend usage of <i>JDOHelper.getObjectId(obj)</i> in the equals/hashCode methods.
                </p>
            </subsection>
        </section>

        <section name="1-N List Unidirectional">
            <p>
                We have 2 sample classes <b>Account</b> and <b>Address</b>. These are related in such a way as <b>Account</b>
                contains a <i>List</i> of objects of type <b>Address</b>, yet each <b>Address</b> knows nothing about the
				<b>Account</b> objects that it relates to. Like this
            </p>
            <img src="../../images/orm/relationship_1_N_uni_list_class.jpg" border="0" alt=""/>
			<p>
				There are 2 ways that we can persist this relationship. These are shown below
			</p>

            <a name="join_uni"/>
            <subsection name="Using Join Table">
                <p>
                    If you define the XML metadata for these classes as follows
                </p>
                <source><![CDATA[
<package name="com.mydomain">
    <class name="Account" identity-type="datastore">
        ...
        <field name="addresses">
            <collection element-type="com.mydomain.Address"/>
            <join/>
        </field>
    </class>

    <class name="Address" identity-type="datastore">
        ...
    </class>
</package>]]></source>
                <p>or alternatively using annotations</p>
<source><![CDATA[
public class Account
{
    ...

    @Join
    List<Address> addresses;
}

public class Address
{
    ...
}]]></source>
                <table class="infoTable"><tr>
                    <td><img src="../../images/lightbulb.png" border="0"/></td>
                    <td>The crucial part is the <i>join</i> element on the field element - this signals to JDO to use a join table.</td>
                </tr></table>
                <p>
                    There will be 3 tables, one for <b>Address</b>, one for <b>Account</b>, and the join table. 
                    The difference from Set is in the contents of the join table. An index column (INTEGER_IDX)
                    is added to keep track of the position of objects in the List.
                    The name of this column can be controlled using the &lt;order&gt; MetaData element.
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_N_uni_list_join_db.gif" border="0" alt=""/>
                <br/>
                <p>The join table is used to link the 2 classes via foreign keys to their primary key. This is useful where you want to 
                    retain the independence of one class from the other class.
                </p>
                <p>
                    If you wish to fully define the schema table and column names etc, follow these tips
                </p>
                <ul>
                    <li>To specify the name of the table where a class is stored, specify the <i>table</i> attribute on the <b>class</b>
                        element</li>
                    <li>To specify the names of the columns where the fields of a class are stored, specify the <i>column</i> attribute
                        on the <b>field</b> element.</li>
                    <li>To specify the name of the join table, specify the <i>table</i> attribute on the <b>field</b> element
                        with the collection.</li>
                    <li>To specify the names of the join table columns, use the <i>column</i> attribute of <i>join</i>, <i>element</i>
                        and <i>order</i> elements.</li>
                    <li>To specify the foreign-key between container table and join table, specify &lt;foreign-key&gt; below
                        the &lt;join&gt; element.</li>
                    <li>To specify the foreign-key between join table and element table, specify &lt;foreign-key&gt; below
                        either the &lt;field&gt; element or the &lt;element&gt; element.</li>
                    <li>If you wish to share the join table with another relation then use the
                        <a href="one_to_many_collection.html#shared_join">DataNucleus "shared join table" extension</a></li>
                    <li>The join table will, by default, be given a primary key. If you want to omit this then you can turn it off
                        using the DataNucleus metadata extension "primary-key" (within &lt;join&gt;) set to false.</li>
                    <li>The column "ADPT_PK_IDX" is added by DataNucleus so that duplicates can be stored. You can control this by
                        adding an &lt;order&gt; element and specifying the column name for the order column (within &lt;field&gt;).</li>
                    <li>If you want the set to include nulls, you can turn on this behaviour by adding the extension
                        metadata "allow-nulls" to the &lt;field&gt; set to true</li>
                </ul>
                <br/>
            </subsection>

            <a name="fk_uni"/>
            <subsection name="Using Foreign-Key">
                <p>
                    In this relationship, the <b>Account</b> class has a List of <b>Address</b> objects, yet the <b>Address</b>
                    knows nothing about the <b>Account</b>. In this case we don't have a field in the Address to link back to the
                    Account and so DataNucleus has to use columns in the datastore representation of the <b>Address</b> class. So we define
                    the XML metadata like this
                </p>
                <source><![CDATA[
<package name="com.mydomain">
    <class name="Account" identity-type="datastore">
        ...
        <field name="addresses">
            <collection element-type="com.mydomain.Address"/>
            <element column="ACCOUNT_ID"/>
        </field>
    </class>

    <class name="Address" identity-type="datastore">
        ...
    </class>
</package>]]></source>
                <p>or alternatively using annotations</p>
<source><![CDATA[
public class Account
{
    ...

    @Element(column="ACCOUNT_ID")
    List<Address> addresses;
}

public class Address
{
    ...
}]]></source>
                <p> 
                    Again there will be 2 tables, one for <b>Address</b>, and one for <b>Account</b>.
                    Note that we have no "mapped-by" attribute specified, and also no "join" element. If you wish to specify
                    the names of the columns used in the schema for the foreign key in the <b>Address</b> table you should use
                    the <i>element</i> element within the field of the collection.
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_N_uni_list_fk_db.gif" border="0" alt=""/>
                <br/>
                <p>
                    In terms of operation within your classes of assigning the objects in the relationship. With DataNucleus and List-based 
                    containers you have to take your <b>Account</b> object and add the <b>Address</b> to the <b>Account</b> collection 
                    field since the <b>Address</b> knows nothing about the <b>Account</b>.
                </p>
                <p>
                    If you wish to fully define the schema table and column names etc, follow these tips
                </p>
                <ul>
                    <li>To specify the name of the table where a class is stored, specify the <i>table</i> attribute on the <b>class</b>
                        element</li>
                    <li>To specify the names of the columns where the fields of a class are stored, specify the <i>column</i> attribute
                        on the <b>field</b> element.</li>
                    <li>To specify the foreign-key between container table and element table, specify &lt;foreign-key&gt; below
                        either the &lt;field&gt; element or the &lt;element&gt; element.</li>
                </ul>
                <p>
                    <b>Limitations</b>
                </p>
                <ul>
                    <li>Since each Address object can have at most one owner (due to the "Foreign Key") this mode of persistence 
                        will not allow duplicate values in the List. If you want to allow duplicate List entries, then use the 
                        "Join Table" variant above.</li>
                </ul>
                <br/>
            </subsection>

            <a name="fk_ordered"/>
            <subsection name="1-N Ordered List using Foreign-Key">
            <img src="../../images/nucleus_extension.gif" alt=""/>
                <p>
                    This is the same as the case above except that we don't want an indexing column adding to the element and
                    instead we define an "ordering" criteria. This is a DataNucleus extension to JDO.
                    So we define the XML metadata like this
                </p>
                <source><![CDATA[
<package name="com.mydomain">
    <class name="Account" identity-type="datastore">
        ...
        <field name="addresses">
            <collection element-type="com.mydomain.Address"/>
            <order>
                <extension vendor-name="datanucleus" key="list-ordering" value="city ASC"/>
            </order>
        </field>
    </class>

    <class name="Address" identity-type="datastore">
        ...
    </class>
</package>]]></source>
                <p>or alternatively using annotations</p>
<source><![CDATA[
public class Account
{
    ...

    @Order(extensions=@Extension(vendorName="datanucleus", key="list-ordering", value="city ASC"))
    List<Address> addresses;
}

public class Address
{
    ...
}]]></source>
                <p> 
                    As above there will be 2 tables, one for <b>Address</b>, and one for <b>Account</b>.
                    We have no indexing column, but instead we will order the elements using the "city" field in ascending
                    order.
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_N_ordered_list_fk_db.gif" border="0" alt=""/>
                <br/>
                <p>
                    In terms of operation within your classes of assigning the objects in the relationship. 
                    With DataNucleus and List-based containers you have to take your <b>Account</b> object and add the <b>Address</b> 
                    to the <b>Account</b> collection field since the <b>Address</b> knows nothing about the <b>Account</b>.
                </p>
                <p>
                    <b>Limitations</b>
                </p>
                <ul>
                    <li>Ordered lists are only ordered in the defined way <b>when retrieved</b> from the datastore.</li>
                </ul>
                <br/>
            </subsection>

		</section>

        <section name="1-N List Bidirectional">
            <p>
                We have 2 sample classes <b>Account</b> and <b>Address</b>. These are related in such a way as <b>Account</b>
                contains a <i>List</i> of objects of type <b>Address</b>, and each <b>Address</b> has a reference to the
				<b>Account</b> object that it relates to. Like this
            </p>
            <img src="../../images/orm/relationship_1_N_bi_list_class.jpg" border="0" alt=""/>
			<p>
				There are 2 ways that we can persist this relationship. These are shown below
			</p>

            <a name="join_bi"/>
            <subsection name="Using Join Table">
                <p>
                    If you define the XML metadata for these classes as follows
                </p>
                <source><![CDATA[
<package name="com.mydomain">
    <class name="Account" identity-type="datastore">
        ...
        <field name="addresses" mapped-by="account">
            <collection element-type="com.mydomain.Address"/>
            <join/>
        </field>
    </class>

    <class name="Address" identity-type="datastore">
        ...
        <field name="account"/>
    </class>
</package>]]></source>
                <p>or alternatively using annotations</p>
<source><![CDATA[
public class Account
{
    ...

    @Persistent(mappedBy="account")
    @Join
    List<Address> addresses;
}

public class Address
{
    ...

    Account account;
}]]></source>
                <table class="infoTable"><tr>
                    <td><img src="../../images/lightbulb.png" border="0"/></td>
                    <td>The crucial part is the <i>join</i> element on the field element - this signals to JDO to use a join table.</td>
                </tr></table>
                <p>
                    There will be 3 tables, one for <b>Address</b>, one for <b>Account</b>, and the join table. 
                    The difference from Set is in the contents of the join table. An index column (INTEGER_IDX) 
                    is added to keep track of the position of objects in the List.
                    The name of this column can be controlled using the &lt;order&gt; MetaData element.
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_N_bi_list_join_db.gif" border="0" alt=""/>
                <br/>
                <p>The join table is used to link the 2 classes via foreign keys to their primary key. This is useful where you want to 
                    retain the independence of one class from the other class.</p>
                <p>
                    If you wish to fully define the schema table and column names etc, follow these tips
                </p>
                <ul>
                    <li>To specify the name of the table where a class is stored, specify the <i>table</i> attribute on the <b>class</b>
                        element</li>
                    <li>To specify the names of the columns where the fields of a class are stored, specify the <i>column</i> attribute
                        on the <b>field</b> element.</li>
                    <li>To specify the name of the join table, specify the <i>table</i> attribute on the <b>field</b> element
                        with the collection.</li>
                    <li>To specify the names of the join table columns, use the <i>column</i> attribute of <i>join</i>, <i>element</i>
                        and <i>order</i> elements.</li>
                    <li>To specify the foreign-key between container table and join table, specify &lt;foreign-key&gt; below
                        the &lt;join&gt; element.</li>
                    <li>To specify the foreign-key between join table and element table, specify &lt;foreign-key&gt; below
                        either the &lt;field&gt; element or the &lt;element&gt; element.</li>
                    <li>If you wish to share the join table with another relation then use the
                        <a href="one_to_many_collection.html#shared_join">DataNucleus "shared join table" extension</a></li>
                    <li>The join table will, by default, be given a primary key. If you want to omit this then you can turn it off
                        using the DataNucleus metadata extension "primary-key" (within &lt;join&gt;) set to false.</li>
                    <li>The column "ADPT_PK_IDX" is added by DataNucleus so that duplicates can be stored. You can control this by
                        adding an &lt;order&gt; element and specifying the column name for the order column (within &lt;field&gt;).</li>
                    <li>When forming the relation please make sure that <b>you set the relation at BOTH sides</b> since DataNucleus
					    would have no way of knowing which end is correct if you only set one end.</li>
                    <li>If you want the set to include nulls, you can turn on this behaviour by adding the extension
                        metadata "allow-nulls" to the &lt;field&gt; set to true</li>
                </ul>
                <br/>
            </subsection>

            <a name="fk_bi"/>
            <subsection name="Using Foreign-Key">
                <p>Here we have the 2 classes with both knowing about the relationship with the other.</p>
                <p><b>Please note that an <i>Foreign-Key</i> List will NOT, by default, allow duplicates. This is because it stores 
                    the element position in the element table. If you need a List with duplicates we recommend that you use the 
                    <i>Join Table</i> List implementation above.</b> If you have an application identity element class then you 
                    <i>could</i> in principle add the element position to the primary key to allow duplicates, but this would imply 
                    changing your element class identity.
                </p>
                <p>
                    If you define the Meta-Data for these classes as follows
                </p>
                <source><![CDATA[
<package name="com.mydomain">
    <class name="Account" identity-type="datastore">
        ...
        <field name="addresses" mapped-by="account">
            <collection element-type="com.mydomain.Address"/>
        </field>
    </class>

    <class name="Address" identity-type="datastore">
        ...
        <field name="account">
            <column name="ACCOUNT_ID"/>
        </field>
    </class>
</package>]]></source>
                <p>or alternatively using annotations</p>
<source><![CDATA[
public class Account
{
    ...

    @Persistent(mappedBy="account")
    List<Address> addresses;
}

public class Address
{
    ...

    Account account;
}]]></source>
                <table class="infoTable"><tr>
                    <td><img src="../../images/lightbulb.png" border="0"/></td>
                    <td>The crucial part is the <i>mapped-by</i> attribute of the field on the "1" side of the relationship. 
                        This tells the JDO implementation to look for a field called <i>account</i> on the <b>Address</b> class.</td>
                </tr></table>
                <p>
                    Again there will be 2 tables, one for <b>Address</b>, and one for <b>Account</b>. The 
                    difference from the Set example is that the List index is placed in the table for 
                    <b>Address</b> whereas for a Set this is not needed.
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_N_bi_list_fk_db.gif" border="0" alt=""/>
                <br/>
                <p>
                    In terms of operation within your classes of assigning the objects in the relationship. <b>With DataNucleus and List-based 
                    containers you have to take your <b>Account</b> object and add the <b>Address</b> to the <b>Account</b> collection 
                    field (you can't just take the <b>Address</b> object and set its <b>Account</b> field since the position of the 
                    <b>Address</b> in the List needs setting, and this is done by adding the <b>Address</b> to the <b>Account</b>)</b>.
                    In addition, if you are removing an object from a List, <b>you cannot simply set the owner on the element to "null".
                    You have to remove it from the List end of the relationship.</b>
                </p>
                <p>
                    If you wish to fully define the schema table and column names etc, follow these tips
                </p>
                <ul>
                    <li>To specify the name of the table where a class is stored, specify the <i>table</i> attribute on the <b>class</b>
                        element</li>
                    <li>To specify the names of the columns where the fields of a class are stored, specify the <i>column</i> attribute
                        on the <b>field</b> element.</li>
                    <li>To specify the foreign-key between container table and element table, specify &lt;foreign-key&gt; below
                        either the &lt;field&gt; element or the &lt;element&gt; element.</li>
                    <li>When forming the relation please make sure that <b>you set the relation at BOTH sides</b> since DataNucleus
					    would have no way of knowing which end is correct if you only set one end.</li>
                </ul>
                <p>
                    <b>Limitation : </b> Since each Address object can have at most one owner (due to the "Foreign Key") this mode
                    of persistence will not allow duplicate values in the List. If you want to allow duplicate List entries, then
                    use the "Join Table" variant above.
                </p>
                <br/>
            </subsection>
        </section>

        <section name="List of non-persistable objects">
            <a name="join_nonpc"/>
            <p>
                All of the examples above show a 1-N relationship between 2 <i>persistable</i> classes. DataNucleus can
                also cater for a List of primitive or Object types. For example, when you have a List of Strings.
                This will be persisted in the same way as the "Join Table" examples above. A join table is created to
                hold the list elements. Let's take our example. We have an <b>Account</b> that stores a List
                of addresses. These addresses are simply Strings. We define the XML metadata like this
            </p>
            <source><![CDATA[
<package name="com.mydomain">
    <class name="Account" identity-type="datastore">
        ...
        <field name="addresses" persistence-modifier="persistent">
            <collection element-type="java.lang.String"/>
            <join/>
            <element column="ADDRESS"/>
        </field>
    </class>]]></source>
                <p>or alternatively using annotations</p>
<source><![CDATA[
public class Account
{
    ...

    @Join
    @Element(column="ADDRESS")
    List<String> addresses;
}]]></source>
            <p>
                In the datastore the following is created
            </p>
            <img src="../../images/orm/relationship_1_N_primitive_list_db.gif" border="0" alt=""/>
            <p>
                The ACCOUNT table is as before, but this time we only have the "join table". In our MetaData we used the &lt;element&gt;
                tag to specify the column name to use for the actual address String. In addition we have an additional index column to form
                part of the primary key (along with the FK back to the ACCOUNT table). You can override the default naming of this column
                by specifying the &lt;order&gt; tag.
            </p>
        </section>

        <section name="List of non-persistable objects using AttributeConverter">
            <a name="converter_nonpc"/>
            <p>
                Just like in the above example, here we have a List of simple types. In this case we are wanting to store this List into
                a single column in the owning table. We do this by using a JDO AttributeConverter.
            </p>
<source><![CDATA[
public class Account
{
    ...

    @Persistent
    @Convert(ListStringToStringConverter.class)
    @Column(name="ADDRESSES")
    List<String> addresses;
}]]></source>
            <p>
                and then define our converter. You can clearly define your conversion process how you want it. You could, for example, convert the
                Collection into comma-separated strings, or could use JSON, or XML, or some other format.
            </p>
<source><![CDATA[

public class ListStringToStringConverter implements AttributeConverter<List<String>, String>
{
    public String convertToDatastore(List<String> attribute)
    {
        if (attribute == null)
        {
            return null;
        }

        StringBuilder str = new StringBuilder();
        ... convert List to String
        return str.toString();
    }

    public List<String> convertToAttribute(String columnValue)
    {
        if (columnValue == null)
        {
            return null;
        }

        List<String> coll = new ArrayList<String>();
        ... convert String to List
        return coll;
    }
}]]></source>
        </section>

        <section name="Embedded into a Join Table">
            <p>
                The above relationship types assume that both classes in the 1-N relation will have their own table.
                A variation on this is where you have a join table but you embed the elements of the collection into
                this join table. To do this you use the <i>embedded-element</i> attribute on the <i>collection</i>
                MetaData element.
                This is described in <a href="embedded.html#Collection">Embedded Collection Elements</a>.
            </p>
        </section>

        <section name="Serialised into a Join Table">
            <p>
                The above relationship types assume that both classes in the 1-N relation will have their own table.
                A variation on this is where you have a join table but you serialise the elements of the collection into
                this join table in a single column. To do this you use the <i>serialised-element</i> attribute on the
                <i>collection</i> MetaData element.
                This is described in <a href="serialised.html#CollectionElements">Serialised Collection Elements</a>
            </p>
        </section>
    </body>
</document>