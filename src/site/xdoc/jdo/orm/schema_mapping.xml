<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>JDO Schema Mapping</title>
    </properties>

    <body>
        <section name="JDO : Schema Mapping">
            <p>
                You saw in our <a href="../class_mapping.html">basic class mapping guide</a> how you define MetaData for a classes basic persistence, notating which fields are persisted. 
                The next step is to define how it maps to the datastore. Fields of a class are mapped to <i>columns</i> of a <i>table</i> (note that with some datastores it is not called
                a 'table' or 'column', but the concept is similar and we use 'table' and 'column' here to represent the mapping). 
                If you don't specify the table and column names, then DataNucleus will generate table and column names for you.
                <b>You should specify your table and column names if you have an existing schema.</b> 
                Failure to do so will mean that DataNucleus uses its own names and these will almost certainly not match what you have in the datastore.
                There are several aspects to cover here
            </p>
            <ul>
                <li><a href="#names">Table and column names</a></li>
                <li><a href="#datastoreidentity">Column for datastore identity</a></li>
                <li><a href="#applicationidentity">Column(s) for application identity</a></li>
                <li><a href="#nullsdefaults">Column nullability and default value</a></li>
                <li><a href="#columntypes">Column Types</a></li>
                <li><a href="#unmapped">Columns with no field in the class</a></li>
                <li><a href="#columnposition">Position of a column in a table</a></li>
                <li><a href="#rdbmsviews">Mapping a class to an RDBMS View</a></li>
            </ul>

            <a name="names"/>
            <subsection name="Tables and Column names">
                <p> 
                    The main thing that developers want to do when they set up the persistence of their data is to control the names of the 
                    tables and columns used for storing the classes and fields. This is an essential step when mapping to an existing schema,
                    because it is necessary to map the classes onto the existing database entities. Let's take an example
                </p>
                <source>
public class Hotel
{
    private String name;
    private String address;
    private String telephoneNumber;
    private int numberOfRooms;
    ...
}</source>      
                <p>In our case we want to map this class to a table called <b>ESTABLISHMENT</b>, and has columns <i>NAME</i>, 
                    <i>DIRECTION</i>, <i>PHONE</i> and <i>NUMBER_OF_ROOMS</i> (amongst other things). So 
                    we define our Meta-Data like this</p>
                <source><![CDATA[
<class name="Hotel" table="ESTABLISHMENT">
    <field name="name">
        <column name="NAME"/>
    </field>
    <field name="address">
        <column name="DIRECTION"/>
    </field>
    <field name="telephoneNumber">
        <column name="PHONE"/>
    </field>
    <field name="numberOfRooms">
        <column name="NUMBER_OF_ROOMS"/>
    </field>
</class>]]></source>
                <p>
                    So we have defined the table and the column names.
                    It should be mentioned that if you don't specify the table and column names then DataNucleus will generate
                    names for the datastore identifiers. The table name will be based on the class name, and the column
                    names will be based on the field names and the role of the field (if part of a relationship).
                </p>
                <p>See also :-</p>
                <ul>
                    <li><a href="datastore_identifiers.html">Identifier Guide</a> - defining the identifiers to use for table/column names</li>
                    <li><a href="../metadata_xml.html#column">MetaData reference for &lt;column&gt; element</a></li>
                    <li><a href="../metadata_xml.html#primary-key">MetaData reference for &lt;primary-key&gt; element</a></li>
                    <li><a href="../annotations.html#Column">Annotations reference for @Column</a></li>
                    <li><a href="../annotations.html#PrimaryKey_Class">Annotations reference for @PrimaryKey</a></li>
                </ul>
                <br/>
            </subsection>

            <a name="datastoreidentity"/>
            <subsection name="Column names for datastore-identity">
                <p>
                    When you select <i>datastore-identity</i> a surrogate column will be added in the datastore. You need to be able
                    to define the column name if mapping to an existing schema (or wanting to control the schema). So lets say we have
                    the following
                </p>
                <source>
public class MyClass // persisted to table "MYCLASS"
{
    ...
}

public class MySubClass extends MyClass // persisted to table "MYSUBCLASS"
{
    ...
}</source>
                <p>
                    We want to define the names of the identity column in "MYCLASS" and "MYSUBCLASS". Here's how we do it
                </p>
                <source><![CDATA[
<class name="MyClass" table="MYCLASS">
    <datastore-identity>
        <column name="MY_PK_COLUMN"/>
    </datastore-identity>
    ...
</class>
<class name="MySubClass" table="MYSUBCLASS">
    <datastore-identity>
        <column name="MYSUB_PK_COLUMN"/>
    </datastore-identity>
    ...
</class>]]></source>
                <p>
                    So we will have a PK column "MY_PK_COLUMN" in the table "MYCLASS", and a PK column "MYSUB_PK_COLUMN" in the table
                    "MYSUBCLASS" (and that corresponds to the "MY_PK_COLUMN" value in "MYCLASS"). We could also do
                </p>
                <source><![CDATA[
<class name="MyClass" table="MYCLASS">
    <datastore-identity>
        <column name="MY_PK_COLUMN"/>
    </datastore-identity>
    ...
</class>
<class name="MySubClass" table="MYSUBCLASS">
    <inheritance strategy="new-table"/>
    <primary-key>
        <column name="MYSUB_PK_COLUMN"/>
    </primary-key>
    ...
</class>]]></source>
                <p>See also :-</p>
                <ul>
                    <li><a href="inheritance.html">Inheritance Guide</a> - defining how to use inheritance between classes</li>
                    <li><a href="../metadata_xml.html#column">MetaData reference for &lt;column&gt; element</a></li>
                    <li><a href="../metadata_xml.html#primary-key">MetaData reference for &lt;primary-key&gt; element</a></li>
                    <li><a href="../annotations.html#Column">Annotations reference for @Column</a></li>
                    <li><a href="../annotations.html#PrimaryKey_Class">Annotations reference for @PrimaryKey</a></li>
                </ul>
                <br/>
            </subsection>

            <a name="applicationidentity"/>
            <subsection name="Column names for application-identity">
                <p>
                    When you select <i>application-identity</i> you have some field(s) that form the "primary-key" of the class.
                    A common situation is that you have inherited classes and each class has its own table, and so the primary-key
                    column names can need defining for each class in the inheritance tree. So lets show an example how to do it
                </p>
                <source>
public class MyClass // persisted to table "MYCLASS"
{
    long id; // PK field
    ...
}

public class MySubClass extends MyClass // persisted to table "MYSUBCLASS"
{
    ...
}</source>
                <p>
                    Defining the column name for "MyClass.id" is easy since we use the same as shown previously "column" for the field.
                    Obviously the table "MYSUBCLASS" will also need a PK column. Here's how we define the column mapping
                </p>
                <source><![CDATA[
<class name="MyClass" identity-type="application" table="MYCLASS">
    <field name="myPrimaryKeyField" primary-key="true">
        <column name="MY_PK_COLUMN"/>
    </field>
    ...
</class>
<class name="MySubClass" identity-type="application" table="MYSUBCLASS">
    <inheritance strategy="new-table"/>
    <primary-key>
        <column name="MYSUB_PK_COLUMN" target="MY_PK_COLUMN"/>
    </primary-key>
    ...
</class>]]></source>
                <p>
                    So we will have a PK column "MY_PK_COLUMN" in the table "MYCLASS", and a PK column "MYSUB_PK_COLUMN" in the table
                    "MYSUBCLASS" (and that corresponds to the "MY_PK_COLUMN" value in "MYCLASS"). You can also use
                </p>
                <source><![CDATA[
<class name="MyClass" identity-type="application" table="MYCLASS">
    <field name="myPrimaryKeyField" primary-key="true">
        <column name="MY_PK_COLUMN"/>
    </field>
    ...
</class>
<class name="MySubClass" identity-type="application" table="MYSUBCLASS">
    <inheritance strategy="new-table">
        <join>
            <column name="MYSUB_PK_COLUMN" target="MY_PK_COLUMN"/>
        </join>
    </inheritance>
    ...
</class>]]></source>
                <p>See also :-</p>
                <ul>
                    <li><a href="inheritance.html">Inheritance Guide</a> - defining how to use inheritance between classes</li>
                    <li><a href="../metadata_xml.html#inheritance">MetaData reference for &lt;inheritance&gt; element</a></li>
                    <li><a href="../metadata_xml.html#column">MetaData reference for &lt;column&gt; element</a></li>
                    <li><a href="../metadata_xml.html#primary-key">MetaData reference for &lt;primary-key&gt; element</a></li>
                    <li><a href="../annotations.html#Inheritance">Annotations reference for @Inheritance</a></li>
                    <li><a href="../annotations.html#Column">Annotations reference for @Column</a></li>
                    <li><a href="../annotations.html#PrimaryKey_Class">Annotations reference for @PrimaryKey</a></li>
                </ul>
                <br/>
            </subsection>

            <a name="nullsdefaults"/>
            <subsection name="Column nullability and default values">
                <p>
                    So we've seen how to specify the basic structure of a table, naming the table and its columns, and how to control the 
                    types of the columns. We can extend this further to control whether the columns are allowed to contain nulls and to set 
                    a default value for a column if we ever have need to insert into it and not specify a particular column. Let's take a 
                    related class for our hotel. Here we have a class to model the payments made to the hotel.
                </p>
                <source>
public class Payment
{
    Customer customer;
    String bankTransferReference;
    String currency;
    double amount;
}</source>
                <p>
                    In this class we can model payments from a customer of an amount. Where the customer pays by bank transfer we can save the
                    reference number. Since our hotel is in the United Kingdom we want the default currency to be pounds, or to use its ISO4217
                    currency code "GBP". In addition, since the bank transfer reference is optional we want that column to be nullable. So let's
                    specify the MetaData for the class.
                </p>
                <source><![CDATA[
<class name="Payment">
    <field name="customer" persistence-capable="persistent" column="CUSTOMER_ID"/>
    <field name="bankTransferReference">
        <column name="TRANSFER_REF" allows-null="true"/>
    </field>
    <field name="currency">
        <column name="CURRENCY" default-value="GBP"/>
    </field>
    <field name="amount" column="AMOUNT"/>
</class>]]></source>
                <p>So we make use of the <i>allows-null</i> and <i>default-value</i> attributes. The table, when created by DataNucleus,
                    will then provide the default and nullability that we require.</p>
                <p>See also :-</p>
                <ul>
                    <li><a href="../metadata_xml.html#column">MetaData reference for &lt;column&gt; element</a></li>
                    <li><a href="../annotations.html#Column">Annotations reference for @Column</a></li>
                </ul>
                <br/>
            </subsection>

            <a name="columntypes"/>
            <subsection name="Column types">
                <p>
                    DataNucleus will provide a default type for any columns that it creates, but it will allow users to override this default.
                    The default that DataNucleus chooses is always based on the Java type for the field being mapped. For example a Java field
                    of type "int" will be mapped to a column type of INTEGER in RDBMS datastores. Similarly String will be mapped to
                    VARCHAR. To override the default setting (and always the best policy if you are wanting your MetaData to give the same
                    datastore definition with all JDO implementations) you do as follows
                </p>
                <source><![CDATA[
<class name="Payment">
    <field name="customer" persistence-capable="persistent" column="CUSTOMER_ID">
    <field name="bankTransferReference">
        <column name="TRANSFER_REF" jdbc-type="VARCHAR" length="255" allows-null="true"/>
    </field>
    <field name="currency">
        <column name="CURRENCY" jdbc-type="CHAR" length="3" default-value="GBP"/>
    </field>
    <field name="amount">
        <column name="AMOUNT" jdbc-type="DECIMAL" length="10" scale="2"/>
    </field>
</class>
]]></source>
                <p>
                    So we have defined TRANSFER_REF to use VARCHAR(255) column type, CURRENCY to use CHAR(3) column type, and AMOUNT to use
                    DECIMAL(10,2) column type. Please be aware that DataNucleus only supports persisting particular Java types to particular
                    JDBC/SQL types. We have demonstrated above the <i>jdbc-type</i> attribute, but there is also an <i>sql-type</i> 
                    attribute. This is to be used where you want to map to some specific SQL type (and will not be needed in the 
                    vast majority of cases - the <i>jdbc-type</i> should generally be used).
                </p>
                <p>See also :-</p>
                <ul>
                    <li><a href="../types.html">Types Guide</a> - defining persistence of Java types</li>
                    <li><a href="../../datastores/rdbms_datastore_types.html">RDBMS Types Guide</a> - defining mapping of Java types to available JDBC/SQL types</li>
                    <li><a href="../metadata_xml.html#column">MetaData reference for &lt;column&gt; element</a></li>
                    <li><a href="../annotations.html#Column">Annotations reference for @Column</a></li>
                </ul>
            </subsection>

            <a name="unmapped"/>
            <subsection name="Columns with no field in the class">
                <p>
                    DataNucleus supports mapping of columns in the datastore that have no associated field in
                    the java class. These are useful where you maybe have a table used by other applications and dont use
                    some of the information in your Java model. DataNucleus needs to know about these columns so that it can
                    validate the schema correctly, and also insert particular values when inserting objects into the table.
                    You could handle this by defining your schema yourself so that the particular columns have "DEFAULT"
                    settings, but this way you allow DataNucleus to know about all information. So to give an example
                </p>
                <source><![CDATA[
<class name="Hotel" table="ESTABLISHMENT">
    <field name="name">
        <column name="NAME"/>
    </field>
    <field name="address">
        <column name="DIRECTION"/>
    </field>
    <field name="telephoneNumber">
        <column name="PHONE"/>
    </field>
    <field name="numberOfRooms">
        <column name="NUMBER_OF_ROOMS"/>
    </field>
    <column name="YEAR_ESTABLISHED" jdbc-type="INTEGER" insert-value="1980"/>
    <column name="MANAGER_NAME" jdbc-type="VARCHAR" insert-value="N/A"/>
</class>]]></source>
                <p>
                    So in this example our table "ESTABLISHMENT" has the columns associated with the specified fields
                    and also has columns "YEAR_ESTABLISHED" (that is INTEGER-based and will be given a value of "1980"
                    on any inserts) and "MANAGER_NAME" (VARCHAR-based and will be given a value of "N/A" on any inserts).
                </p>
            </subsection>

            <a name="columnposition"/>
            <subsection name="Position of column in a table">
                <p>
                    With some datastores it is desirable to be able to specify the relative position of a column in the table schema. 
                    The default (for DataNucleus) is just to put them in ascending alphabetical order.
                    JDO allows definition of this using the <i>position</i> attribute on a <b>column</b>.
                    See <a href="../fields_properties.html#columnposition">fields/properties column positioning docs</a> for details.
                </p>
            </subsection>

            <a name="rdbmsviews"/>
            <subsection name="RDBMS : Views">
                <img src="../images/nucleus_extension.gif" alt=""/>
                <p>
                    The standard situation with an RDBMS datastore is to map classes to <b>Tables</b>. 
                    The majority of RDBMS also provide support for <b>Views</b>, providing the equivalent of a read-only SELECT across various tables. 
                    DataNucleus also provides support for querying such Views. This provides more flexibility to the user where they have data and need to display it in their application. 
                    Support for Views is described below.
                </p>
                <p>
                    When you want to access data according to a View, you are required to provide a class that will accept
                    the values from the View when queried, and Meta-Data for the class that defines the View and how
                    it maps onto the provided class. Let's take an example. We have a View SALEABLE_PRODUCT in our database 
                    as follows, defined based on data in a PRODUCT table.
                </p>
<source><![CDATA[
CREATE VIEW SALEABLE_PRODUCT (ID, NAME, PRICE, CURRENCY) AS
    SELECT ID, NAME, CURRENT_PRICE AS PRICE, CURRENCY FROM PRODUCT
    WHERE PRODUCT.STATUS_ID = 1]]></source>
                <p>
                    So we define a class to receive the values from this <b>View</b>.
                </p>
<source><![CDATA[
package mydomain.views;
public class SaleableProduct
{
    String id;
    String name;
    double price;
    String currency;

    public String getId()
    {
        return id;
    }

    public String getName()
    {
        return name;
    }

    public double getPrice()
    {
        return price;
    }

    public String getCurrency()
    {
        return currency;
    }
}]]></source>
                <p>
                    and then we define how this class is mapped to the <b>View</b>
                </p>
<source><![CDATA[
<?xml version="1.0"?>
<!DOCTYPE jdo SYSTEM "file:/javax/jdo/jdo.dtd">
<jdo>
    <package name="mydomain.views">
        <class name="SaleableProduct" identity-type="nondurable" table="SALEABLE_PRODUCT">
            <field name="id"/>
            <field name="name"/>
            <field name="price"/>
            <field name="currency"/>

            <!-- This is the "generic" SQL92 version of the view. -->
            <extension vendor-name="datanucleus" key="view-definition" value="
CREATE VIEW SALEABLE_PRODUCT
(
    {this.id},
    {this.name},
    {this.price},
    {this.currency}
) AS
SELECT ID, NAME, CURRENT_PRICE AS PRICE, CURRENCY FROM PRODUCT
WHERE PRODUCT.STATUS_ID = 1"/>
        </class>
    </package>
</jdo>]]></source>
                <p>
                    Please note the following
                </p>
                <ul>
                    <li>We've defined our class as using "nondurable" identity. This is an important step since rows of the <b>View</b>
                        typically don't operate in the same way as rows of a <b>Table</b>, not mapping onto a persisted updateable object as such</li>
                    <li>We've specified the "table", which in this case is the view name - otherwise DataNucleus would create a name
                       for the view based on the class name.</li>
                    <li>We've defined a DataNucleus extension <i>view-definition</i> that defines the view for this class. If the view
                        doesn't already exist it doesn't matter since DataNucleus (when used with <i>autoCreateSchema</i>) will execute this construction definition.</li>
                    <li>The <i>view-definition</i> can contain macros utilising the names of the fields in the class, and hence
                        borrowing their column names (if we had defined column names for the fields of the class).</li>
                    <li>You can also utilise other classes in the macros, and include them via a DataNucleus MetaData extension <i>view-imports</i> (not shown here)</li>
                    <li>If your <b>View</b> already exists you are still required to provide a <i>view-definition</i> even though
                        DataNucleus will not be utilising it, since it also uses this attribute as the flag for whether it is a <b>View</b>
                        or a <b>Table</b> - just make sure that you specify the "table" also in the MetaData.</li>
                </ul>
                <p>
                    We can now utilise this class within normal DataNucleus querying operation.
                </p>
<source><![CDATA[
Extent e = pm.getExtent(SaleableProduct.class);
Iterator iter = e.iterator();
while (iter.hasNext())
{
    SaleableProduct product = (SaleableProduct)iter.next();
}]]></source>
                <p>
                    Hopefully that has given enough detail on how to create and access views from with a DataNucleus-enabled application.
                </p>
            </subsection>
		</section>
	</body>
</document>