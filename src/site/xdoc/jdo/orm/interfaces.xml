<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>JDO Interfaces</title>
    </properties>

    <body>
        <section name="JDO : Interface Fields">
            <p>
                JDO requires that implementations support the persistence of interfaces as first class objects 
                (FCO's). DataNucleus provides this capability. It follows the same general process as for 
                <a href="objects.html">java.lang.Object</a> since both interfaces and java.lang.Object are 
                basically <i>references</i> to some persistable object.
            </p>
            <p>
                To demonstrate interface handling let's introduce some classes.
                Let's suppose you have an interface with a selection of classes implementing the interface 
                something like this
            </p>
            <br/>
            <img src="../../images/orm/interfaces_classes.gif" border="0" alt=""/>
            <br/>
            <p>
                You then have a class that contains an object of this interface type
            </p>
            <source>
public class ShapeHolder
{
    protected Shape shape=null;
    ...
}
            </source>
            <p>
                JDO doesn't define how an interface is persisted in the datastore. Obviously there can be
                many implementations and so no obvious solution. DataNucleus allows the following
            </p>
            <ul>
                <li><b>per-implementation</b> : a FK is created for each implementation so that the datastore
                    can provide referential integrity. The other advantage is that since there are FKs then
                    querying can be performed. The disadvantage is that if there are many
                    implementations then the table can become large with many columns not used</li>
                <li><b>identity</b> : a single column is added and this stores the class name of the
                    implementation stored, as well as the identity of the object. The advantage is that if you
                    have large numbers of implementations then this can cope with no schema change.
                    The disadvantages are that no querying can be performed, and that there is no 
                    referential integrity.</li>
                <li><b>xcalia</b> : a slight variation on "identity" whereby there is a single column
                    yet the contents of that column are consistent with what Xcalia XIC JDO implementation
                    stored there.</li>
            </ul>
            <p>
                The user controls which one of these is to be used by specifying the <i>extension</i>
                <b>mapping-strategy</b> on the field containing the interface. 
                The default is "per-implementation"
            </p>
            <p>
                In terms of the implementations of the interface, you can either leave the field to accept any
                <i>known about</i> implementation, or you can restrict it to only accept some implementations
                (see "implementation-classes" metadata extension).
                If you are leaving it to accept any persistable implementation class, then you need to be careful
                that such implementations are known to DataNucleus at the point of encountering the interface
                field. By this we mean, DataNucleus has to have encountered the metadata for the implementation
                so that it can allow for the implementation when handling the field. You can force DataNucleus
                to know about a persistable class by using an autostart mechanism, or using <i>persistence.xml</i>,
                or by placement of the <i>package.jdo</i> file so that when the owning class for the interface
                field is encountered so is the metadata for the implementations. 
            </p>
            <br/>

            <subsection name="1-1">
                <img src="../../images/jdo2.gif" alt=""/>
                <p>
                    To allow persistence of this interface field with DataNucleus you have 2 levels of control. 
                    The first level is global control. Since all of our <i>Square</i>, <i>Circle</i>, 
                    <i>Rectangle</i> classes implement <i>Shape</i> then we just define them in the MetaData as we 
                    would normally.
                </p>
                <source><![CDATA[
<package name="mydomain">
    <class name="Square">
        ...
    </class>
    <class name="Circle">
        ...
    </class>
    <class name="Rectangle">
        ...
    </class>
</package>]]></source>
                <p>
                    The global way means that when mapping that field DataNucleus will look at all persistable classes
                    it knows about that implement the specified interface.
                </p>
                <p>
                    JDO also allows users to specify a list of classes implementing the interface on a field-by-field 
                    basis, defining which of these implementations are accepted for a particular interface 
                    field. To do this you define the Meta-Data like this
                </p>
                <source><![CDATA[
<package name="mydomain">
    <class name="ShapeHolder">
        <field name="shape" persistence-modifier="persistent"
               field-type="mydomain.Circle,mydomain.Rectangle,mydomain.Square"/>
</class>]]></source>
                <p>
                    That is, for any interface object in a class to be persisted, you define the possible implementation
                    classes that can be stored there. DataNucleus interprets this information and will map the above example 
                    classes to the following in the database
                </p>
                <br/>
                <img src="../../images/orm/interfaces_db.gif" border="0" alt=""/>
                <br/>
                <p>
                    So DataNucleus adds foreign keys from the containers table to all of the possible implementation tables for 
                    the <i>shape</i> field.
                </p>
                <br/>
                <p>
                    If we use <b>mapping-strategy</b> of "identity" then we get a different datastore schema.
                </p>
                <source><![CDATA[
    <class name="ShapeHolder">
        <field name="shape" persistence-modifier="persistent">
            <extension vendor-name="datanucleus" key="mapping-strategy" value="identity"/>
        </field>
    </class>]]></source>
                <p>
                    and the datastore schema becomes
                </p>
                <img src="../../images/orm/interfaces_identity_1_1_db.gif" border="0" alt=""/>
                <p>
                    and the column "SHAPE" will contain strings such as 
                    <i>mydomain.Circle:1</i> allowing retrieval of the related implementation 
                    object.
                </p>
            </subsection>

            <subsection name="1-N">
                <p>
                    You can have a Collection/Map containing elements of an interface type. 
                    You specify this in the same way as you would any Collection/Map. <b>You can have a 
                    Collection of interfaces as long as you use a join table relation and it is 
                    unidirectional.</b>
                    The "unidirectional" restriction is that the interface is not persistent on its own and
                    so cannot store the reference back to the owner object.
                    Use the 1-N relationship guides for the metadata definition to use.
                </p>
                <p>
                    You need to use a DataNucleus extension tag "implementation-classes" if you want to
                    restrict the collection to only contain particular implementations of an interface.
                    For example
                </p>
                <source><![CDATA[
<class name="ShapeHolder">
    <field name="shapes" persistence-modifier="persistent">
        <collection element-type="mydomain.Shape"/>
        <join/>
        <extension vendor-name="datanucleus" key="implementation-classes" 
            value="mydomain.Circle,mydomain.Rectangle,mydomain.Square,mydomain.Triangle"/>
    </field>
</class>]]></source>
                <p>
                    So the <i>shapes</i> field is a Collection of <i>mydomain.Shape</i> and it will accept
                    the implementations of type <b>Circle</b>, <b>Rectangle</b>, <b>Square</b> and <b>Triangle</b>.
                    If you omit the implementation-classes tag then you have to give DataNucleus a way of finding the
                    metadata for the implementations prior to encountering this field.
                </p>
            </subsection>

            <subsection name="Dynamic Schema Updates">
                <p>
                    The default mapping strategy for interface fields and collections of interfaces is
                    to have separate FK column(s) for each possible implementation of the interface.
                    Obviously if you have an application where new implementations are added over time
                    the schema will need new FK column(s) adding to match. This is possible if you enable
                    the persistence property <b>datanucleus.rdbms.dynamicSchemaUpdates</b>, setting it
                    to <i>true</i>. With this set, any insert/update operation of an interface related field
                    will do a check if the implementation being stored is known about in the schema and,
                    if not, will update the schema accordingly.
                </p>
            </subsection>
        </section>

    </body>
</document>