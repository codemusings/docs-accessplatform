<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>JDO 1-1 Relationships</title>
    </properties>

    <body>
        <section name="JDO : 1-1 Relationships">
            <p>
                You have a 1-to-1 relationship when an object of a class has an associated object of another class (only 
                one associated object). It could also be between an object of a class and another object of the same class 
                (obviously). You can create the relationship in 2 ways depending on whether the 2 classes know about each 
                other (bidirectional), or whether only one of the classes knows about the other class (unidirectional). 
                These are described below.
            </p>
            <p>
                The various possible relationships are described below.
            </p>
            <ul>
                <li><a href="#uni">1-1 Unidirectional</a> (where only 1 object is aware of the other)</li>
                <li><a href="#bi">1-1 Bidirectional</a> (where both objects are aware of each other)</li>
                <li><a href="../identity.html#compound_1_1_uni">1-1 Unidirectional "Compound Identity"</a> (object as part of PK in other object)</li>
            </ul>
            <table class="infoTable"><tr>
                <td><img src="../../images/lightbulb.png" border="0"/></td>
                <td>
                    For RDBMS a 1-1 relation is stored as a foreign-key column(s).<br/>
                    For non-RDBMS it is stored as a String "column" storing the 'id' (possibly with the class-name included in the string) of the related object.
                </td>
            </tr></table>
            <br/>

            <a name="uni"/>
            <subsection name="Unidirectional">
                <p>
                    For this case you could have 2 classes, <b>User</b> and <b>Account</b>, as below.
                    <br/>
                    <img src="../../images/orm/relationship_1_1_uni_class.jpg" border="0" alt=""/>
                    <br/>
                    so the <b>Account</b> class knows about the <b>User</b> class, but not vice-versa. If you define the 
                    XML metadata for these classes as follows
                </p>
<source><![CDATA[
<package name="mydomain">
    <class name="User" table="USER">
        <field name="id" primary-key="true">
            <column name="USER_ID"/>
        </field>
        ...
    </class>

    <class name="Account" table="ACCOUNT">
        <field name="id" primary-key="true">
            <column name="ACCOUNT_ID"/>
        </field>
        ...
        <field name="user">
            <column name="USER_ID"/>
        </field>
    </class>
</package>]]></source>
                <p>or alternatively using annotations</p>
<source><![CDATA[
public class Account
{
    ...

    @Column(name="USER_ID")
    User user;
}

public class User
{
    ...
}]]></source>
                <p>
                    This will create 2 tables in the database, one for <b>User</b> (with name <i>USER</i>), and one for 
                    <b>Account</b> (with name <i>ACCOUNT</i> and a column <i>USER_ID</i>), as shown below.
                    <br/>
                    <img src="../../images/orm/relationship_1_1_uni_db.gif" border="0" alt=""/>
                    <br/>
                </p>
                <p>
                    Things to note :-
                </p>
                <ul>
                    <li><b>Account</b> has the object reference (and so owns the relation) to <b>User</b> and so its table 
                        holds the foreign-key</li>
                    <li>If you call <i>PM.deletePersistent()</i> on the end of a 1-1 unidirectional relation without the 
                        relation and that object is related to another object, an exception will typically be thrown 
                        (assuming the RDBMS supports foreign keys). To delete this record you should remove the other 
                        objects association first.</li>
                    <li>If you invoke an operation that will retrieve the one-to-one field, and you only want it
                        to get the foreign key value (and not join to the related table) you can add the metadata
                        extension <i>fetch-fk-only</i> (set to "true") to the field/property.</li>
                </ul>
                <br/>
            </subsection>

            <a name="bi"/>
            <subsection name="Bidirectional">
                <p>
                    For this case you could have 2 classes, <b>User</b> and <b>Account</b> again, but this time as below. 
                    Here the <b>Account</b> class knows about the <b>User</b> class, and also vice-versa.
                </p>
                <img src="../../images/orm/relationship_1_1_bi_class.jpg" border="0" alt=""/>
                <br/>
                <p>
                    Here we create the 1-1 relationship with a single foreign-key. 
                    To do this you define the XML metadata as
                </p>
<source><![CDATA[
<package name="mydomain">
    <class name="User" table="USER">
        <field name="id" primary-key="true">
            <column name="USER_ID"/>
        </field>
        ...
        <field name="account" mapped-by="user"/>
    </class>

    <class name="Account" table="ACCOUNT">
        <field name="id" primary-key="true">
            <column name="ACCOUNT_ID"/>
        </field>
        ...
        <field name="user">
            <column name="USER_ID"/>
        </field>
    </class>
</package>]]></source>
                <p>or alternatively using annotations</p>
<source><![CDATA[
public class Account
{
    ...

    @Column(name="USER_ID")
    User user;
}

public class User
{
    ...

    @Persistent(mappedBy="user")
    Account account;
}]]></source>
                <table>
                    <tr>
                        <td>The difference is that we added <i>mapped-by</i> to the field of <b>User</b>.
                        This represents the bidirectionality.</td>
                    </tr>
                </table>
                <p>
                    This will create 2 tables in the database, one for <b>User</b> (with name <i>USER</i>), and 
                    one for <b>Account</b> (with name <i>ACCOUNT</i>). With RDBMS the <i>ACCOUNT</i> table will have
                    a column <i>USER_ID</i> (since RDBMS will place the FK on the side without the "mapped-by"). Like this
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_1_bi_db_singlefk.gif" border="0" alt=""/>
                <br/>
                <p>
                    With non-RDBMS datastores both tables will have a column containing the "id" of the related object,
                    that is <i>USER</i> will have an ACCOUNT column, and <i>ACCOUNT</i> will have a USER_ID column.
                </p>
                <p>
                    Things to note :-
                </p>
                <ul>
                    <li>When forming the relation please make sure that <b>you set the relation at BOTH sides</b> 
                        since DataNucleus would have no way of knowing which end is correct if you only set one 
                        end.</li>
                    <li>If you invoke an operation that will retrieve the one-to-one field (of the non-owner side), 
                        and you only want it to get the foreign key value (and not join to the related table) you 
                        can add the metadata extension <i>fetch-fk-only</i> (set to "true") to the field/property.</li>
                </ul>
                <br/>
            </subsection>

            <subsection name="Embedded">
                <p>
                    The above 2 relationship types assume that both classes in the 1-1 relation will have their 
                    own table. You can, of course, embed the elements of one class into the table of the other. 
                    This is described in <a href="embedded.html#PC">Embedded PC Objects</a>.
                </p>
            </subsection>
        </section>

    </body>
</document>