<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>JDO Transactions</title>
    </properties>

    <body>
        <section name="JDO : Transactions">
            <p>
                A Transaction forms a unit of work. The Transaction manages what happens within that unit of work,
                and when an error occurs the Transaction can roll back any changes performed. Transactions can be 
                managed by the users application, or can be managed by a framework (such as Spring), or can be 
                managed by a JEE container. These are described below.
            </p>
            <ul>
                <li><a href="#local">Local transactions</a> : managed using the JDO Transaction API</li>
                <li><a href="#jta">JTA transactions</a> : managed using the JTA UserTransaction API, or using
                    the JDO Transaction API</li>
                <li><a href="#container">Container-managed transactions</a> : managed by a JEE environment</li>
                <li><a href="#spring">Spring-managed transactions</a> : managed by SpringFramework</li>
                <li><a href="#nontransactional">No transactions</a></li>
                <li><a href="#flushing">Flushing a Transaction</a></li>
                <li><a href="#isolation">Controlling transaction isolation level</a></li>
                <li><a href="#readonly">Read-Only transactions</a></li>
            </ul>
            <br/>

            <a name="local"/>
            <subsection name="Locally-Managed Transactions">
                <p>
                    When using a JDO implementation such as DataNucleus in a J2SE environment, the transactions
                    are by default <b>Locally Managed Transactions</b>. The users code will manage the 
                    transactions by starting, and commiting the transaction itself. With these transactions 
                    with JDO 
                    <a href="http://db.apache.org/jdo/api20/apidocs/javax/jdo/Transaction.html" target="_blank"><img src="../images/javadoc.gif" alt=""/></a>
                    you would do something like
                </p>
                <source><![CDATA[
PersistenceManager pm = pmf.getPersistenceManager();
Transaction tx = pm.currentTransaction();
try
{
    tx.begin();
    
    {users code to persist objects}
    
    tx.commit();
}
finally
{
    if (tx.isActive())
    {
        tx.rollback();
    }
}
pm.close();]]></source>
                <p>
                    The basic idea with <b>Locally-Managed transactions</b> is that you are 
                    managing the transaction start and end.
                </p>
                <br/>
            </subsection>

            <a name="jta"/>
            <subsection name="JTA Transactions">
                <p>
                    When using a JDO implementation such as DataNucleus in a J2SE environment, you can also
                    make use of <b>JTA Transactions</b>. <b>You define the persistence property
                    <i>javax.jdo.option.TransactionType</i> setting it to "JTA"</b>. 
                    Then you make use of JTA (or JDO) to demarcate the transactions. 
                    So you could do something like
                </p>
                <source><![CDATA[
UserTransaction ut = (UserTransaction)
    new InitialContext().lookup("java:comp/UserTransaction");
PersistenceManager pm = pmf.getPersistenceManager();
try
{
    ut.begin();
    
    {users code to persist objects}
    
    ut.commit();
}
finally
{
    pm.close();
}]]></source>
                <p>
                    So here we used the JTA API to begin/commit the controlling 
                    (<i>javax.transaction.UserTransaction</i>).
                </p>
                <p>
                    An alternative is where you don't have a UserTransaction started and just use the
                    JDO API, which will start the UserTransaction for you.
                </p>
                <source><![CDATA[
UserTransaction ut = (UserTransaction)
    new InitialContext().lookup("java:comp/UserTransaction");
PersistenceManager pm = pmf.getPersistenceManager();
Transaction tx = pm.currentTransaction();
try
{
    tx.begin(); // Starts the UserTransaction
    
    {users code to persist objects}
    
    tx.commit(); // Commits the UserTransaction
}
finally
{
    pm.close();
}]]></source>
                <p>
                    <b>Important</b> : please note that you need to set both transactional and 
                    nontransactional datasources, and <b>the nontransactional cannot be JTA</b>.
                </p>
                <br/>
            </subsection>

            <a name="container"/>
            <subsection name="Container-Managed Transactions">
                <p>
                    When using a JEE container you are giving over control of the transactions to the container. 
                    Here you have <b>Container-Managed Transactions</b>. In terms of your code, you would do like 
                    the previous example <b>except</b> that you would OMIT the <i>tx.begin(), tx.commit(), 
                    tx.rollback()</i> since the JEE container will be doing this for you.
            	</p>
                <br/>
            </subsection>

            <a name="spring"/>
            <subsection name="Spring-Managed Transactions">
                <p>
                    When you use a framework like <a href="http://www.springframework.org" target="_blank">Spring</a> 
                    you would not need to specify the <i>tx.begin(), tx.commit(), tx.rollback()</i> since that would 
                    be done for you.
            	</p>
                <br/>
            </subsection>

            <a name="nontransactional"/>
            <subsection name="No Transactions">
                <p>
                    DataNucleus allows the ability to operate without transactions. With JDO this is enabled by
                    default (see the 2 properties <b>datanucleus.NontransactionalRead</b>,
                    <b>datanucleus.NontransactionalWrite</b> set to <i>true</i>). This means that you can read objects
                    and make updates outside of transactions. This is
                    effectively "auto-commit" mode.
                </p>
                <source><![CDATA[
PersistenceManager pm = pmf.getPersistenceManager();
    
{users code to persist objects}

pm.close();]]></source>
                <p>
                    When using non-transactional operations, you need to pay attention to the persistence property
                    <b>datanucleus.nontx.atomic</b>. If this is true then any persist/delete/update will be committed
                    to the datastore immediately. If this is false then any persist/delete/update will be queued up until
                    the next transaction (or <i>pm.close()</i>) and committed with that.
                </p>
                <br/>
            </subsection>

            <a name="flushing"/>
            <subsection name="Flushing">
                <p>
                    During a transaction, depending on the configuration, operations don't necessarily go to the datastore
                    immediately, often waiting until <i>commit</i>. In some situations you need persists/updates/deletes
                    to be in the datastore so that subsequent operations can be performed that rely on those being
                    handled first. In this case you can <b>flush</b> all outstanding changes to the datastore using
                </p>
<source><![CDATA[
pm.flush();]]></source>
                <img src="../images/nucleus_extension.gif" alt="" border="0"/>
                <p>
                    A convenient vendor extension is to find which objects are waiting to be flushed at any time, like this
                </p>
<source><![CDATA[
List<ObjectProvider> objs = 
    ((JDOPersistenceManager)pm).getExecutionContext().getObjectsToBeFlushed();]]></source>
                <br/>
            </subsection>

            <a name="isolation"/>
            <subsection name="Transaction Isolation">
                <p>
                    JDO provides a mechanism for specification of the transaction isolation level. 
                    This can be specified globally via the PersistenceManagerFactory property 
                    <i>datanucleus.transactionIsolation</i> (javax.jdo.option.TransactionIsolationLevel).
                    It accepts the following values
                </p>
                <ul>
                    <li><b>read-uncommitted</b> : dirty reads, non-repeatable reads and phantom reads can occur</li>
                    <li><b>read-committed</b> : dirty reads are prevented; non-repeatable reads and phantom reads can occur</li>
                    <li><b>repeatable-read</b> : dirty reads and non-repeatable reads are prevented; phantom reads can occur</li>
                    <li><b>serializable</b> : dirty reads, non-repeatable reads and phantom reads are prevented</li>
                </ul>
                <p>
                    The default (in DataNucleus) is <u>read-committed</u>. An attempt to set the isolation level
                    to an unsupported value (for the datastore) will throw a JDOUserException.
                    As an alternative you can also specify it on a per-transaction basis as follows (using the 
                    names above).
                </p>
                <source>
Transaction tx = pm.currentTransaction();
...
tx.setIsolationLevel("read-committed");</source>
                <br/>
            </subsection>

            <subsection name="JDO Transaction Synchronisation">
                <p>
                    There are situations where you may want to get notified that a transaction is in course of 
                    being committed or rolling back. To make that happen, you would do something like
                </p>
                <source>
PersistenceManager pm = pmf.getPersistenceManager();
Transaction tx = pm.currentTransaction();
try
{
    tx.begin();

    tx.setSynchronization(new javax.transaction.Synchronization()
    {
        public void beforeCompletion()
        {
             // before commit or rollback
        }

        public void afterCompletion(int status)
        {
            if (status == javax.transaction.Status.STATUS_ROLLEDBACK)
            {
                // rollback
            }
            else if (status == javax.transaction.Status.STATUS_COMMITTED)
            {
                // commit
            }
        }
    });
    
    tx.commit();
}
finally
{
    if (tx.isActive())
    {
        tx.rollback();
    }
}
pm.close();</source>
                <br/>
            </subsection>

            <a name="readonly"/>
            <subsection name="Read-Only Transactions">
                <p>
                    Obviously transactions are intended for committing changes. If you come across a situation where
                    you don't want to commit anything under any circumstances you can mark the transaction
                    as "read-only" by calling
                </p>
                <source><![CDATA[
PersistenceManager pm = pmf.getPersistenceManager();
Transaction tx = pm.currentTransaction();
try
{
    tx.begin();
    tx.setRollbackOnly();

    {users code to persist objects}
    
    tx.rollback();
}
finally
{
    if (tx.isActive())
    {
        tx.rollback();
    }
}
pm.close();]]></source>
                <p>
                    Any call to <i>commit</i> on the transaction will throw an exception forcing the user to
                    roll it back.
                </p>
                <br/>
            </subsection>
        </section>

        <section name="JDO : Transaction Locking">
            <p>
                A Transaction forms a unit of work. The Transaction manages what happens within that unit of work, 
                and when an error occurs the Transaction can roll back any changes performed. 
                There are the following types of locking :-
            </p>
            <ul>
                <li>Transactions can lock all records in a datastore and keep them locked until they are ready 
                    to commit their changes. These are known as 
                    <a href="#pessimistic">Pessimistic (or datastore) Locking</a>.</li>
                <li>Transactions can simply assume that things in the datastore will not change until they are 
                    ready to commit, not lock any records and then just before committing make a check for changes. 
                    This is known as <a href="#optimistic">Optimistic Locking</a>.</li>
            </ul>

            <a name="pessimistic"/>
            <subsection name="Pessimistic (Datastore) Locking">
                <p>
                    <b>Pessimistic</b> locking is the default in JDO. It is 
                    suitable for short lived operations where no user interaction is taking place and so it is 
                    possible to block access to datastore entities for the duration of the transaction.
                </p>
                <p>
                    By default DataNucleus does not currently lock the objects fetched with pessimistic locking, 
                    but you can configure this behaviour for RDBMS datastores by setting the persistence property 
                    <b>datanucleus.SerializeRead</b> to <i>true</i>. 
                    This will result in all "SELECT ... FROM ..." statements being changed to be 
                    "SELECT ... FROM ... FOR UPDATE". This will be applied only where the underlying RDBMS 
                    supports the "FOR UPDATE" syntax. This can be done on a transaction-by-transaction basis
                    by doing
                </p>
                <source><![CDATA[
Transaction tx = pm.currentTransaction();
tx.setSerializeRead(true);]]></source>
                <p>
                    Alternatively, on a per query basis, you would do
                </p>
                <source><![CDATA[
Query q = pm.newQuery(...);
q.setSerializeRead(true);]]></source>
                <p>
                    With pessimistic locking DataNucleus will grab a datastore connection at the first 
                    operation, and maintain it for the duration of the transaction. A single connection is used for 
                    the transaction (with the exception of any 
                    <a href="value_generation.html">Identity Generation</a> operations which need datastore 
                    access, so these can use their own connection).
                </p>
                <p>
                    In terms of the process of pessimistic (datastore) locking, we demonstrate this below.
                </p>
                <table>
                    <tr>
                        <th>Operation</th>
                        <th>DataNucleus process</th>
                        <th>Datastore process</th>
                    </tr>
                    <tr>
                        <td>Start transaction</td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Persist object</td>
                        <td>Prepare object (1) for persistence</td>
                        <td><b>Open connection.</b><br/>
                            Insert the object (1) into the datastore</td>
                    </tr>
                    <tr>
                        <td>Update object</td>
                        <td>Prepare object (2) for update</td>
                        <td>Update the object (2) into the datastore</td>
                    </tr>
                    <tr>
                        <td>Persist object</td>
                        <td>Prepare object (3) for persistence</td>
                        <td>Insert the object (3) into the datastore</td>
                    </tr>
                    <tr>
                        <td>Update object</td>
                        <td>Prepare object (4) for update</td>
                        <td>Update the object (4) into the datastore</td>
                    </tr>
                    <tr>
                        <td>Flush</td>
                        <td>No outstanding changes so do nothing</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Perform query</td>
                        <td>Generate query in datastore language</td>
                        <td>Query the datastore and return selected objects</td>
                    </tr>
                    <tr>
                        <td>Persist object</td>
                        <td>Prepare object (5) for persistence</td>
                        <td>Insert the object (5) into the datastore</td>
                    </tr>
                    <tr>
                        <td>Update object</td>
                        <td>Prepare object (6) for update</td>
                        <td>Update the object (6) into the datastore</td>
                    </tr>
                    <tr>
                        <td>Commit transaction</td>
                        <td></td>
                        <td><b>Commit connection</b></td>
                    </tr>
                </table>
                <p>
                    So here whenever an operation is performed, DataNucleus pushes it straight to the datastore.
                    Consequently any queries will always reflect the current state of all objects in use.
                    However this mode of operation has no version checking of objects and so if they were updated
                    by external processes in the meantime then they will overwrite those changes.
                </p>
                <p>
                    It should be noted that DataNucleus provides two persistence properties that allow an amount of
                    control over when flushing happens with datastore transactions.
                </p>
                <ul>
                    <li><i>datanucleus.flush.mode</i> when set to MANUAL will try to
                    delay all datastore operations until commit/flush.</li>
                    <li><i>datanucleus.datastoreTransactionFlushLimit</i> represents the number of dirty objects
                    before a flush is performed. This defaults to 1.</li>
                </ul>

                <br/>
            </subsection>

            <a name="optimistic"/>
            <subsection name="Optimistic Locking">
                <p>
                    <b>Optimistic</b> locking is the other option in JDO. 
                    It is suitable for longer lived operations maybe where user interaction is taking place and 
                    where it would be undesirable to block access to datastore entities for the duration of the 
                    transaction. The assumption is that data altered in this transaction will not be updated by 
                    other transactions during the duration of this transaction, so the changes are not propagated 
                    to the datastore until commit()/flush(). The data is checked just before commit to ensure the 
                    integrity in this respect. The most convenient way of checking data for updates is to maintain 
                    a column on each table that handles optimistic locking data. The user will decide this 
                    when generating their MetaData.
                </p>
                <p>
                    Rather than placing version/timestamp columns on all user datastore tables, JDO2 allows
                    the user to notate particular classes as requiring <b>optimistic</b> treatment. This is 
                    performed by specifying in MetaData or annotations the details of the field/column to use for 
                    storing the version - see versioning for <a href="orm/versioning.html">JDO</a>. 
                    With JDO the version is added in a surrogate column, whereas a vendor extension allows
                    you to have a field in your class ready to store the version.
                </p>
                <p>
                    In JDO2 the version is stored in a surrogate column in the datastore so it also provides a 
                    method for accessing the version of an object. You can call <i>JDOHelper.getVersion(object)</i> 
                    and this returns the version as an Object (typically Long or Timestamp). This will return null 
                    for a transient object, and will return the version for a persistent object. If the object is 
                    not <i>persistable</i> then it will also return null.
                </p>
                <p>
                    In terms of the process of optimistic locking, we demonstrate this below.
                </p>
                <table>
                    <tr>
                        <th>Operation</th>
                        <th>DataNucleus process</th>
                        <th>Datastore process</th>
                    </tr>
                    <tr>
                        <td>Start transaction</td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Persist object</td>
                        <td>Prepare object (1) for persistence</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Update object</td>
                        <td>Prepare object (2) for update</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Persist object</td>
                        <td>Prepare object (3) for persistence</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Update object</td>
                        <td>Prepare object (4) for update</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Flush</td>
                        <td>Flush all outstanding changes to the datastore</td>
                        <td><b>Open connection.</b><br/>
                            Version check of object (1)<br/>
                            Insert the object (1) in the datastore.<br/>
                            Version check of object (2)<br/>
                            Update the object (2) in the datastore.<br/>
                            Version check of object (3)<br/>
                            Insert the object (3) in the datastore.<br/>
                            Version check of object (4)<br/>
                            Update the object (4) in the datastore.</td>
                    </tr>
                    <tr>
                        <td>Perform query</td>
                        <td>Generate query in datastore language</td>
                        <td>Query the datastore and return selected objects</td>
                    </tr>
                    <tr>
                        <td>Persist object</td>
                        <td>Prepare object (5) for persistence</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Update object</td>
                        <td>Prepare object (6) for update</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Commit transaction</td>
                        <td>Flush all outstanding changes to the datastore</td>
                        <td>Version check of object (5)<br/>
                            Insert the object (5) in the datastore<br/>
                            Version check of object (6)<br/>
                            Update the object (6) in the datastore.<br/>
                            <b>Commit connection.</b></td>
                    </tr>
                </table>
                <p>
                    Here no changes make it to the datastore until the user either commits the transaction, or
                    they invoke flush(). The impact of this is that when performing a query, by default, the results
                    may not contain the modified objects unless they are flushed to the datastore before invoking the
                    query. Depending on whether you need the modified objects to be reflected in the results of the
                    query governs what you do about that. If you invoke flush() just before running the query
                    the query results will include the changes. The obvious benefit of optimistic locking is that
                    all changes are made in a block and version checking of objects is performed before application 
                    of changes, hence this mode copes better with external processes updating the objects.
                </p>
                <p>
                    Please note that for some datastores (e.g RDBMS) the version check followed by update/delete is 
                    performed in a single statement.
                </p>

                <p>See also :-</p>
                <ul>
                    <li><a href="metadata_xml.html#version">JDO MetaData reference for &lt;version&gt; element</a></li>
                    <li><a href="annotations.html#Version">JDO Annotations reference for @Version</a></li>
                </ul>
                <br/>
            </subsection>

            <subsection name="Persistence-by-Reachability at commit()">
                <p>
                    When a transaction is committed JDO will, by default, run its reachability algorithm
                    to check if any reachable objects have been persisted and are no longer reachable.
                    If an object is found to be no longer reachable and was only persisted by being reachable
                    (not by an explicit persist operation) then it will be removed from the datastore.
                    You can turn off this reachability check for JDO by setting the persistence property
                    <b>datanucleus.persistenceByReachabilityAtCommit</b> to false.
                </p>
                <br/>
            </subsection>
        </section>
    </body>
</document>
