<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>JDO Queries - JDOQL</title>
    </properties>

    <body>
        <section name="JDO : JDOQL Queries">
            <p>
                JDO defines ways of querying objects persisted into the datastore. It provides its own object-based 
                query language (JDOQL). JDOQL is designed as the Java developers way of having the power of SQL 
                queries, yet retaining the Java object relationship that exist in their application model. 
                A typical JDOQL query may be created in several ways. 
                Here's an example expressed in the 3 supported ways
            </p>
            <source><![CDATA[
Single-String JDOQL :
Query q = pm.newQuery(
    "SELECT FROM mydomain.Person WHERE lastName == 'Jones' && " +
    "age < age_limit PARAMETERS int age_limit");
List<Person> results = (List<Person>)q.execute(20);

Declarative JDOQL :
Query q = pm.newQuery(Person.class);
q.setFilter("lastName == 'Jones' && age < age_limit");
q.declareParameters("int age_limit");
List<Person> results = (List<Person>)q.execute(20);

Typesafe JDOQL (DataNucleus) :
TypesafeQuery<Person> tq = pm.newTypesafeQuery(Person.class);
QPerson cand = QPerson.candidate();
List<Person> results = 
    tq.filter(cand.lastName.eq("Jones").and(cand.age.lt(tq.intParameter("age_limit"))))
        .setParameter("age_limit", "20").executeList();]]></source>
			<p>
                So here in our example we select all "Person" objects with surname of "Jones" and where the persons 
                age is below 20. The language is intuitive for Java developers, and is intended as their interface 
                to accessing the persisted data model. As can be seen above, the query is made up of distinct parts. 
                The class being selected (the SELECT clause in SQL), the filter (which equates to the WHERE clause 
                in SQL), together with any sorting (the ORDER BY clause in SQL), etc.
			</p>
			<p>
			    <b>In this section we will express all examples using the single-string format</b> since it is the
			    simplest to highlight how to use JDOQL, so please refer to the 
			    <a href="jdoql_declarative.html">Declarative JDOQL</a> and
			    <a href="jdoql_typesafe.html">Typesafe JDOQL</a> guides for details if wanting to use those.
			</p>
            <br/>

            <a name="singlestring"/>
            <subsection name="JDOQL Single-String syntax">
                <p>
                    JDOQL queries can be defined in a single-string form, as follows
                </p>
<source><![CDATA[
SELECT [UNIQUE] [<result>] [INTO <result-class>]
        [FROM <candidate-class> [EXCLUDE SUBCLASSES]]
        [WHERE <filter>]
        [VARIABLES <variable declarations>]
        [PARAMETERS <parameter declarations>]
        [<import declarations>]
        [GROUP BY <grouping>]
        [ORDER BY <ordering>]
        [RANGE <start>, <end>]>]]></source>
                <p>
                    The "keywords" in the query are shown in UPPER CASE but can be in <i>UPPER</i> or 
                    <i>lower</i> case (but not MiXeD case). So giving an example
                </p>
<source>SELECT UNIQUE FROM mydomain.Employee ORDER BY departmentNumber</source>
                <br/>
            </subsection>

            <a name="candidateclass"/>
            <subsection name="Candidate Class">
                <p>
                    By default the candidate "class" with JDOQL has to be a persistable class. This can then
                    be referred to in the query using the <i>this</i> keyword (just like in Java). Also by default
                    your query will return instances of subclasses of the candidate class. You can restrict to
                    just instances of the candidate by specifying to exclude subclasses (see EXCLUDE SUBCLASSES
                    in the single-string syntax, or by <i>setSubclasses(false)</i> when using the declarative API).
                </p>
                <img src="../images/nucleus_extension.gif" border="0" alt=""/>
                <p>
                    DataNucleus also allows you to specify a candidate class as persistent interface. This is used
                    where we want to query for instances of implementations of the interface. Let's take an example. 
                    We have an interface
                </p>
<source><![CDATA[
@PersistenceCapable
public interface ComputerPeripheral
{
    @PrimaryKey
    long getId();
    void setId(long val);

    @Persistent
    String getManufacturer();
    void setManufacturer(String name);

    @Persistent
    String getModel();
    void setModel(String name);
}]]></source>
                <p>and we have the following implementations</p>
<source><![CDATA[
@PersistenceCapable
public class Mouse implements ComputerPeripheral
{
    ...
}

@PersistenceCapable
public class Keyboard implements ComputerPeripheral
{
    ...
}]]></source>
                <p>
                    So we have made our interface persistable, and defined the identity property(ies) there. The
                    implementations of the interface will use the identity defined in the interface. 
                    To query it we simply do
                </p>
<source><![CDATA[
Query q = pm.newQuery("SELECT FROM " + ComputerPeripheral.class.getName());
List<ComputerPeripheral> results = (List<ComputerPeripheral>)q.execute();]]></source>
                <p>
                    The key rules are
                </p>
                <ul>
                    <li>You must define the interface as persistent</li>
                    <li>The interface must define the identity/primary key member(s)</li>
                    <li>The implementations must have the same definition of identity and primary key</li>
                </ul>
                <br/>
            </subsection>

            <a name="filter"/>
            <subsection name="Filter">
                <p>
                    The most important thing to remember when defining the <i>filter</i> for JDOQL is that
                    <b>think how you would write it in Java, and its likely the same</b>. The <i>filter</i>
                    has to be a boolean expression, and can include 
                    <a href="#candidateclass">the candidate</a>,
                    <a href="#fields_properties">fields/properties</a>,
                    <a href="#literals">literals</a>, <a href="#methods">methods</a>, 
                    <a href="#parameters">parameters</a>, <a href="#variables">variables</a>,
                    <a href="#operators">operators</a>, <a href="#instanceof">instanceof</a>,
                    <a href="#subqueries">subqueries</a>
                    and <a href="#casts">casts</a>.
                </p>
            </subsection>

            <a name="fields_properties"/>
            <subsection name="Fields/Properties">
                <p>
                    In JDOQL you refer to fields/properties in the query by referring to the field/bean name. 
                    For example, if you are querying a candidate class called <i>Product</i> and it has a field "price",
                    then you access it like this
                </p>
                <source><![CDATA[price < 150.0]]></source>
                <p>
                    Note that, just like in Java, if you want to refer to a field/property of the candidate
                    you can prefix the field by <i>this</i>
                </p>
                <source><![CDATA[this.price < 150.0]]></source>
                <p>
                    You can also chain field references if you have a candidate class Product with a field of
                    (persistable) type Inventory, which has a field <i>name</i>, so you could do
                </p>
                <source><![CDATA[this.inventory.name == 'Backup']]></source>
                <p>
                    In addition to the persistent fields, you can also access "public static final" fields of any 
                    class. You can do this as follows
                </p>
                <source><![CDATA[taxPercent < mydomain.Product.TAX_BAND_A]]></source>
                <p>
                    So this will find all products that include a tax percentage less than some "BAND A" level.
                    Where you are using "public static final" fields you can either fully-qualify the class name
                    or you can include it in the "imports" section of the query (see later).
                </p>
                <p>
                    <b>An important thing to remember with JDOQL is that you do not do explicit joins. You instead use the fields/properties
                    and navigate to the object you want to make use of in your query</b>. 
                </p>
                <p>
                    With 1-1/N-1 relations this is simply a reference to the field/property, and place some restriction on it, like this
                </p>
                <source><![CDATA[this.inventory.name == 'MyInventory']]></source>
                <p>
                    With 1-N/M-N relations you would use something like
                </p>
                <source><![CDATA[containerField.contains(elemVar)]]></source>
                <p>
                    and thereafter refer to <i>elemVar</i> for the element in the collection to place restrictions on the element. Similarly you can
                    use <i>elemVar</i> in the result clause
                </p>
                <br/>
            </subsection>

            <a name="methods"/>
            <subsection name="Methods">
                <p>
                    When writing the "filter" for a JDOQL Query you can make use of some methods on the various 
                    Java types. The range of methods included as standard in JDOQL is not as flexible as with
                    the true Java types, but the ones that are available are typically of much use.
                    While DataNucleus supports all of the methods in the JDO standard, it also supports several
                    yet to be standardised (extension) method. The tables below also mark whether a particular
                    method is supported for evaluation <a href="#inmemory">in-memory</a>.
                </p>
                <p>
                    <img src="../images/nucleus_plugin.gif" border="0" alt=""/>
                    Please note that you can easily add support for other methods for evaluation "in-memory" using this 
                    <a href="http://www.datanucleus.org/extensions/query_method_evaluators.html">DataNucleus plugin point</a>
                </p>
                <p>
                    <img src="../images/nucleus_plugin.gif" border="0" alt=""/>
                    Please note that you can easily add support for other methods with RDBMS datastore using this 
                    <a href="http://www.datanucleus.org/extensions/rdbms_sql_methods.html">DataNucleus plugin point</a>
                </p>

                <a name="methods_string"/>
                <h4>String Methods</h4>
                <table>
                    <tr>
                        <th width="220">Method</th>
                        <th>Description</th>
                        <th width="70">Standard</th>
                        <th width="70">In-Memory</th>
                    </tr>
                    <tr>
                        <td>startsWith(String)</td>
                        <td>Returns if the string starts with the passed string</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>startsWith(String, int)</td>
                        <td>Returns if the string starts with the passed string, from the passed position</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>endsWith(String)</td>
                        <td>Returns if the string ends with the passed string</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>indexOf(String)</td>
                        <td>Returns the first position of the passed string</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>indexOf(String,int)</td>
                        <td>Returns the position of the passed string, after the passed position</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>substring(int)</td>
                        <td>Returns the substring starting from the passed position</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>substring(int,int)</td>
                        <td>Returns the substring between the passed positions</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>toLowerCase()</td>
                        <td>Returns the string in lowercase</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>toUpperCase()</td>
                        <td>Retuns the string in UPPERCASE</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>matches(String pattern)</td>
                        <td>Returns whether string matches the passed expression. The pattern argument follows the rules of 
                            java.lang.String.matches method.</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>charAt(int)</td>
                        <td>Returns the character at the passed position</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>length()</td>
                        <td>Returns the length of the string</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>trim()</td>
                        <td>Returns a trimmed version of the string</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>concat(String)</td>
                        <td>Concatenates the current string and the passed string</td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>equals(String)</td>
                        <td>Returns if the strings are equal</td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>equalsIgnoreCase(String)</td>
                        <td>Returns if the strings are equal ignoring case</td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>replaceAll(String, String)</td>
                        <td>Returns the string with all instances of <i>str1</i> replaced by <i>str2</i></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>trimLeft()</td>
                        <td>Returns a trimmed version of the string (trimmed for leading spaces).
                            <b>Only on RDBMS</b></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>trimRight()</td>
                        <td>Returns a trimmed version of the string (trimmed for trailing spaces)
                            <b>Only on RDBMS</b></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                </table>
                <p>
                    Here's an example using a Product class, looking for objects which their abbreviation is the 
                    beginning of a trade name. The trade name is provided as parameter.
                </p>
                <source><![CDATA[
Declarative JDOQL :
Query query = pm.newQuery(mydomain.Product.class);
query.setFilter(":tradeName.startsWith(this.abbreviation)");
List results = (List)query.execute("Workbook Advanced");

Single-String JDOQL :
Query query = pm.newQuery(
    "SELECT FROM mydomain.Product " +
    "WHERE :tradeName.startsWith(this.abbreviation)");
List results = (List)query.execute("Workbook Advanced");]]></source>

                <a name="methods_collection"/>
                <h4>Collection Methods</h4>
                <table>
                    <tr>
                        <th width="220">Method</th>
                        <th>Description</th>
                        <th width="70">Standard</th>
                        <th width="70">In-Memory</th>
                    </tr>
                    <tr>
                        <td>isEmpty()</td>
                        <td>Returns whether the collection is empty</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>contains(value)</td>
                        <td>Returns whether the collection contains the passed element</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>size()</td>
                        <td>Returns the number of elements in the collection</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>get(int)</td>
                        <td>Returns the element at that position of the List</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                </table>
                <p>
                    Here's an example demonstrating use of contains(). We have an Inventory class that has a
                    Collection of Product objects, and we want to find the Inventory objects with 2 particular 
                    Products in it. Here we make use of a variable (<i>prd</i> to represent the Product being 
                    contained
                </p>
                <source><![CDATA[
Declarative JDOQL :
Query query = pm.newQuery(mydomain.Inventory.class);
query.setFilter("products.contains(prd) && (prd.name=='product 1' || prd.name=='product 2')");
List results = (List)query.execute();

Single-String JDOQL:
Query query = pm.newQuery(
    "SELECT FROM mydomain.Inventory " + 
    "WHERE products.contains(prd) && (prd.name=='product 1' || prd.name=='product 2')");
List results = (List)query.execute();]]></source>

                <a name="methods_map"/>
                <h4>Map Methods</h4>
                <table>
                    <tr>
                        <th width="220">Method</th>
                        <th>Description</th>
                        <th width="70">Standard</th>
                        <th width="70">In-Memory</th>
                    </tr>
                    <tr>
                        <td>isEmpty()</td>
                        <td>Returns whether the map is empty</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>containsKey(key)</td>
                        <td>Returns whether the map contains the passed key</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>containsValue(value)</td>
                        <td>Returns whether the map contains the passed value</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>get(key)</td>
                        <td>Returns the value from the map with the passed key</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>size()</td>
                        <td>Returns the number of entries in the map</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>containsEntry(key, value)</td>
                        <td>Returns whether the map contains the passed entry</td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                    </tr>
                </table>
                <p>
                    Here's an example using a Product class as a value in a Map. Our example represents an 
                    organisation that has several Inventories of products. Each Inventory of products is stored 
                    using a Map, keyed by the Product name. The query searches for all Inventories that contain a 
                    product with the name "product 1".
                </p>
                <source>
Declarative JDOQL :
Query query = pm.newQuery(mydomain.Inventory.class, "products.containsKey('product 1')");
List results = (List)query.execute();

Single-String JDOQL :
Query query = pm.newQuery(
    "SELECT FROM mydomain.Inventory " +
    "WHERE products.containsKey('product 1')");
List results = (List)query.execute();</source>
                <p>
                    Here's the source code for reference
                </p>
                <source><![CDATA[
class Inventory
{
    Map<String, Product> products;
    ...
}
class Product
{
    ...
}]]></source>
 
                <a name="methods_temporal"/>
                <h4>Temporal Methods</h4>
                <table>
                    <tr>
                        <th width="220">Method</th>
                        <th>Description</th>
                        <th width="70">Standard</th>
                        <th width="70">In-Memory</th>
                    </tr>
                    <tr>
                        <td>getDate()</td>
                        <td>Returns the day (of the month) for the date (java.util.Date types)</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>getMonth()</td>
                        <td>Returns the month for the date (java.util.Date types)</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>getYear()</td>
                        <td>Returns the year for the date (java.util.Date types)</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>getHour()</td>
                        <td>Returns the hour for the time (java.util.Date types)</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>getMinute()</td>
                        <td>Returns the minute for the time (java.util.Date types)</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>getSecond()</td>
                        <td>Returns the second for the time (java.util.Date types)</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                </table>

                <a name="methods_enum"/>
                <h4>Enum Methods</h4>
                <table>
                    <tr>
                        <th width="220">Method</th>
                        <th>Description</th>
                        <th width="70">Standard</th>
                        <th width="70">In-Memory</th>
                    </tr>
                    <tr>
                        <td>ordinal()</td>
                        <td>Returns the ordinal of the enum (not implemented for enum expression when
                            persisted as a string)</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>toString()</td>
                        <td>Returns the string form of the enum (not implemented for enum expression
                            when persisted as a numeric)</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                </table>

                <a name="methods_other"/>
                <h4>Other Methods</h4>
                <table>
                    <tr>
                        <th width="220">Class</th>
                        <th width="220">Method</th>
                        <th>Description</th>
                        <th width="70">Standard</th>
                        <th width="70">In-Memory</th>
                    </tr>
                    <tr>
                        <td>java.awt.Point</td>
                        <td>getX()</td>
                        <td>Returns the X coordinate.
                            <b>Only on RDBMS</b></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>java.awt.Point</td>
                        <td>getY()</td>
                        <td>Returns the Y coordinate.
                            <b>Only on RDBMS</b></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>java.awt.Rectangle</td>
                        <td>getX()</td>
                        <td>Returns the X coordinate.
                            <b>Only on RDBMS</b></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>java.awt.Rectangle</td>
                        <td>getY()</td>
                        <td>Returns the Y coordinate.
                            <b>Only on RDBMS</b></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>java.awt.Rectangle</td>
                        <td>getWidth()</td>
                        <td>Returns the width.
                            <b>Only on RDBMS</b></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>java.awt.Rectangle</td>
                        <td>getHeight()</td>
                        <td>Returns the height.
                            <b>Only on RDBMS</b></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>org.joda.time.Interval</td>
                        <td>getStart()</td>
                        <td>Returns the start date/time object.
                            <b>Only on RDBMS</b></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>org.joda.time.Interval</td>
                        <td>getEnd()</td>
                        <td>Returns the end date/time object.
                            <b>Only on RDBMS</b></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>{}</td>
                        <td>length</td>
                        <td>Returns the length of an array.
                            <b>Only on RDBMS</b></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                    </tr>                                        
                    <tr>
                        <td>{}</td>
                        <td>contains(object)</td>
                        <td>Returns true if the array contains the object.
                            <b>Only on RDBMS</b></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                    </tr>
                </table>

                <a name="methods_static"/>
                <h4>Static Methods</h4>
                <table>
                    <tr>
                        <th width="220">Method</th>
                        <th>Description</th>
                        <th width="70">Standard</th>
                        <th width="70">In-Memory</th>
                    </tr>
                    <tr>
                        <td>Math.abs(number)</td>
                        <td>Returns the absolute value of the passed number</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>Math.sqrt(number)</td>
                        <td>Returns the square root of the passed number</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>Math.cos(number)</td>
                        <td>Returns the cosine of the passed number</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>Math.sin(number)</td>
                        <td>Returns the absolute value of the passed number</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>Math.tan(number)</td>
                        <td>Returns the tangent of the passed number</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>Math.acos(number)</td>
                        <td>Returns the arc cosine of the passed number</td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>Math.asin(number)</td>
                        <td>Returns the arc sine of the passed number</td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>Math.atan(number)</td>
                        <td>Returns the arc tangent of the passed number</td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>Math.ceil(number)</td>
                        <td>Returns the ceiling of the passed number</td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>Math.exp(number)</td>
                        <td>Returns the exponent of the passed number</td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>Math.floor(number)</td>
                        <td>Returns the floor of the passed number</td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>Math.log(number)</td>
                        <td>Returns the log(base e) of the passed number</td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>JDOHelper.getObjectId(object)</td>
                        <td>Returns the object identity of the passed persistent object</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>JDOHelper.getVersion(object)</td>
                        <td>Returns the version of the passed persistent object</td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_success_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>SQL_rollup({object})</td>
                        <td>Perform a rollup operation over the results. 
                            <b>Only for some RDBMS e.g DB2, MSSQL, Oracle</b></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>SQL_cube({object})</td>
                        <td>Perform a cube operation over the results. 
                            <b>Only for some RDBMS e.g DB2, MSSQL, Oracle</b></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>SQL_boolean({sql})</td>
                        <td>Embed the provided SQL and return a boolean result.
                            <b>Only on RDBMS</b></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                    </tr>
                    <tr>
                        <td>SQL_numeric({sql})</td>
                        <td>Embed the provided SQL and return a numeric result.
                            <b>Only on RDBMS</b></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                        <td><img src="../images/icon_error_sml.gif" border="0" alt=""/></td>
                    </tr>
                </table>
                <br/>
            </subsection>

            <a name="literals"/>
            <subsection name="Literals">
                <p>
                    JDOQL supports literals of the following types : Number, boolean, character, String, and <i>null</i>.
                    When String literals are specified using single-string format they should be surrounded by single-quotes <i>'</i>.
                </p>
                <br/>
            </subsection>

            <a name="parameters"/>
            <subsection name="Parameters">
                <p>
                    With a query you can pass values into the query as parameters. This is useful where you don't
                    want to embed particular values in the query itself, so making it reusable with different values.
                    JDOQL allows two types of parameters.
                </p>
                <h4>Explicit Parameters</h4>
                <p>
                    If you <i>declare</i> the parameters when defining the query (using the PARAMETERS keyword in the
                    single-string form, or via the declareParameters method) then these are <b>explicit</b> parameters. 
                    This sets the type of the parameter, and when you pass the value in at <i>execute</i> it has to 
                    be of that type. For example
                </p>
                <source><![CDATA[
Query query = pm.newQuery(
    "SELECT FROM mydomain.Product WHERE price < limit PARAMETERS double limit");
List results = (List)query.execute(150.00);]]></source>
                <p>
                    Note that if declaring multiple parameters then they should be comma-separated.
                </p>
                <h4>Implicit Parameters</h4>
                <p>
                    If you don't declare the parameters when defining the query but instead prefix identifiers in 
                    the query with <b>:</b> (colon) then these are <b>implicit</b> parameters. For example
                </p>
                <source><![CDATA[
Query query = pm.newQuery(
    "SELECT FROM mydomain.Product WHERE price < :limit");
List results = (List)query.execute(150.00);]]></source>
                <img src="../images/nucleus_extension.gif" border="0" alt=""/>
                <p>
                    In some situations you may have a map of parameters keyed by their name, yet the query
                    in question doesn't need all parameters. Normal JDO execution would throw an exception
                    here since they are inconsistent with the query. You can omit this check by setting
                </p>
                <source>q.addExtension("datanucleus.query.ignoreParameterCountCheck", "true");</source>
                <br/>
            </subsection>

            <a name="variables"/>
            <subsection name="Variables">
                <p>
                    In JDOQL you can connect two parts of a query using something known as a variable. For example, 
                    we want to retrieve all objects with a collection that contains a particular element, and where
                    the element has a particular field value. We define a query like this
                </p>
                <source><![CDATA[
Query query = pm.newQuery("SELECT FROM mydomain.Supplier " +
    "WHERE products.contains(prod) && prod.name == 'Beans' VARIABLES mydomain.Product prod");]]></source>
                <p>
                    So we have a variable in our query called <i>prod</i> that connects the two parts.
                    You can declare your variables (using the VARIABLES keyword in the
                    single-string form, or via the declareVariables method) if you want to define the type like here 
                    (<b>explicit</b>), or you can leave them for the query compilation to determine (<b>implicit</b>).
                </p>
                <p>
                    Note that if declaring multiple variables then they should be semicolon-separated.
                </p>
                <br/>
            </subsection>

            <a name="imports"/>
            <subsection name="Imports">
                <p>
                    JDOQL uses the imports declaration to create a type namespace for the query. During query 
                    compilation, the classes used in the query, if not fully qualified, are searched in this 
                    namespace. The type namespace is built with primitives types, java.lang.* package, package of the 
                    candidate class, import declarations (if any).
                </p>
                <p>
                    To resolve a class, the JDOQL compiler will use the class fully qualified name to load it, but if 
                    the class is not fully qualified, it will search by prefixing the class name with the imported 
                    package names declared in the type namespace. All classes loaded by the query must be acessible by 
                    either the candidate class classloader, the PersistenceManager classloader or the current Thread 
                    classloader. The search algorithm for a class in the JDOQL compiler is the following:
                </p>
                <ul>
                    <li>if the class is fully qualified, load the class.</li>
                    <li>if the class is not fully qualified, iterate each package in the type namespace and try to 
                    load the class from that package. This is done until the class is loaded, or the type namespace 
                    package names are exausted. If the class cannot be loaded an exception is thrown.</li>
                </ul>
                <p>
                    Note that the search algorithm can be problematic in performance terms if the class is not fully 
                    qualified or declared in imports using package notation. To avoid such problems, either use fully 
                    qualified class names or import the class in the imports declaration.
                </p>
                <br/>
            </subsection>

            <a name="ifelse"/>
            <subsection name="IF ELSE expressions">
                <p>
                    For particular use in the <i>result</i> clause, you can make use of a <b>IF ELSE</b> expression where you want to
                    return different things based on some condition(s). Like this
                </p>
<source><![CDATA[
SELECT p.personNum, IF (p.age < 18) 'Youth' ELSE IF (p.age >= 18 && p.age < 65) 'Adult' ELSE 'Old' FROM mydomain.Person p");
]]></source>
                <p>
                    So in this case the second result value will be a String, either "Youth", "Adult" or "Old" depending on the age of the person.
                    <b>Note that this is not in any JDO spec yet, but should be soon</b>.
                    The BNF structure of the JDOQL IF ELSE expression is
                </p>
                <pre>
IF (conditional_expression) scalar_expression {ELSE IF (conditional_expression) scalar_expression}* ELSE scalar_expression
                </pre>
                <br/>
            </subsection>

            <a name="operators"/>
            <subsection name="Operators">
                <p>
                    The following list describes the operator precedence in JDOQL.
                </p>
                <ol>
                    <li>Cast</li>
                    <li>Unary ("~") ("!")</li>
                    <li>Unary ("+") ("-")</li>
                    <li>Multiplicative ("*") ("/") ("%")</li>
                    <li>Additive ("+") ("-")</li>
                    <li>Relational (">=") (">") ("&lt;=") ("&lt;") ("instanceof")</li>
                    <li>Equality ("==") ("!=")</li>
                    <li>Boolean logical AND ("&amp;")</li>
                    <li>Boolean logical OR ("|")</li>
                    <li>Conditional AND ("&amp;&amp;")</li>
                    <li>Conditional OR ("||")</li>
                </ol>
                <p>
                    The concatenation operator(+) concatenates a String to either another String or Number. 
                    Concatenations of String or Numbers to null results in null.
                </p>
            </subsection>

            <a name="instanceof"/>
            <subsection name="instanceof">
                <p>
                    JDOQL allows the Java keyword <b>instanceof</b> so you can compare objects against a class.
                </p>
                <p>
                    Let's take an example. We have a class A that has a field "b" of type B and B has subclasses 
                    B1, B2, B3. Clearly the field "b" of A can be of type B, B1, B2, B3 etc, and we want to find 
                    all objects of type A that have the field "b" that is of type B2. We do it like this
                </p>
                <source><![CDATA[
Declarative JDOQL :
Query query = pm.newQuery(A.class);
query.setFilter("b instanceof mydomain.B2");
List results = (List)query.execute();

Single-String JDOQL :
Query query = pm.newQuery("SELECT FROM mydomain.A WHERE b instanceof mydomain.B2");
List results = (List)query.execute();]]></source>
                <br/>
            </subsection>

            <a name="casts"/>
            <subsection name="casting">
                <p>
                    JDOQL allows use of Java-style casting so you can type-convert fields etc.
                </p>
                <p>
                    Let's take an example. We have a class A that has a field "b" of type B and B has subclasses 
                    B1, B2, B3. The B2 subtype has a field "other", and we know that the filtered A will have a B2. 
                    You could specify a filter using the "B2.other" field like this
                </p>
                <source><![CDATA[
((mydomain.B2)b).other == :someVal"]]></source>
                <br/>
            </subsection>

            <a name="subqueries"/>
            <subsection name="Subqueries">
                <p>
                    With JDOQL the user has a very flexible query syntax which allows for querying of the vast majority
                    of data components in a single query. In some situations it is desirable for the query to utilise
                    the results of a separate query in its calculations. JDO allows subqueries, so that both 
                    calculations can be performed in one query. Here's an example, using single-string JDOQL
                </p>
<source><![CDATA[
SELECT FROM org.datanucleus.Employee WHERE salary > 
    (SELECT avg(salary) FROM org.datanucleus.Employee e)]]></source>
                <p>
                    So we want to find all Employees that have a salary greater than the average salary.
                    In single-string JDOQL the subquery must be in parentheses (brackets). Note that we have defined
                    the subquery with an alias of "e", whereas in the outer query the alias is "this".
                </p>
                <p>
                    We can specify the same query using the Declarative API, like this
                </p>
<source><![CDATA[
Query averageSalaryQuery = pm.newQuery(Employee.class);
averageSalaryQuery.setResult("avg(this.salary)");

Query q = pm.newQuery(Employee.class, "salary > averageSalary");
q.declareVariables("double averageSalary");
q.addSubquery(averageSalaryQuery, "double averageSalary", null, null);
List results = (List)q.execute();]]></source>
                <p>
                    So we define a subquery as its own Query (that could be executed just like any query if so desired),
                    and the in the main query have an implicit variable that we define as being represented by the
                    subquery.
                </p>

                <h4>Referring to the outer query in the subquery</h4>
                <p>
                    JDOQL subqueries allows use of the outer query fields within the subquery if so desired.
                    Taking the above example and extending it, here is how we do it in single-string JDOQL
                </p>
                <source><![CDATA[
SELECT FROM org.datanucleus.Employee WHERE salary > 
    (SELECT avg(salary) FROM org.datanucleus.Employee e WHERE e.lastName == this.lastName)
]]></source>
                <p>
                    So with single-string JDOQL we make use of the alias identifier "this" to link back to
                    the outer query.
                </p>
                <p>
                    Using the Declarative API, to achieve the same thing we would do
                </p>
                <source><![CDATA[
Query averageSalaryQuery = pm.newQuery(Employee.class);
averageSalaryQuery.setResult("avg(this.salary)");
averageSalaryQuery.setFilter("this.lastName == :lastNameParam");

Query q = pm.newQuery(Employee.class, "salary > averageSalary");
q.declareVariables("double averageSalary");
q.addSubquery(averageSalaryQuery, "double averageSalary", null, "this.lastName");
List results = (List)q.execute();]]></source>
                <p>
                    So with the Declarative API we make use of parameters, and the last argument to <i>addSubquery</i>
                    is the value of the parameter <i>lastNameParam</i>.
                </p>

                <h4>Candidate of the subquery being part of the outer query</h4>
                <p>
                    There are occasions where we want the candidate of the subquery to be part of the 
                    outer query, so JDOQL subqueries has the notion of a <i>candidate expression</i>.
                    This is an expression relative to the candidate of the outer query. An example
                </p>
                <source><![CDATA[
SELECT FROM org.datanucleus.Employee WHERE this.weeklyhours > 
    (SELECT AVG(e.weeklyhours) FROM this.department.employees e)]]></source>
                <p>
                    so the candidate of the subquery is <i>this.department.employees</i>. If using a candidate
                    expression we must provide an alias.
                </p>
                <p>
                    You can do the same with the Declarative API. Like this
                </p>
                <source><![CDATA[
Query averageHoursQuery = pm.newQuery(Employee.class);
averageHoursQuery.setResult("avg(this.weeklyhours)");

Query q = pm.newQuery(Employee.class);
q.setFilter("this.weeklyhours > averageWeeklyhours");
q.addSubquery(averageHoursQuery, "double averageWeeklyhours", "this.department.employees", null);
                ]]></source>
                <p>
                    so now our subquery has a candidate related to the outer query candidate.
                </p>
                <br/>
            </subsection>

            <a name="result"/>
            <subsection name="Result clause">
                <p>
                    By default (when not specifying the result) the objects returned will be of the candidate class 
                    type, where they match the query filter. The <i>result</i> clause can contain (any of) the following
                </p>
                <ul>
                    <li>DISTINCT - optional keyword at the start of the results to make them distinct</li>
                    <li><i>this</i> - the candidate instance</li>
                    <li>A field name</li>
                    <li>A variable</li>
                    <li>A parameter (though why you would want a parameter returning is hard to see since you input 
                        the value in the first place)</li>
                    <li>An aggregate (count(), avg(), sum(), min(), max())</li>
                    <li>An expression involving a field (e.g "field1 + 1")</li>
                    <li>A navigational expression (navigating from one field to another ... e.g "field1.field4")</li>
                </ul>
                <p>
                    so you could specify something like
                </p>
                <source><![CDATA[count(field1), field2]]></source>
                <p>
                    There are situations when you want to return a single number for a column, representing an 
                    aggregate of the values of all records. There are 5 standard JDO aggregate functions available. 
                    These are
                </p>
                <ul>
                    <li><b>avg(val)</b> - returns the average of "val". "val" can be a field, numeric field expression 
                        or "distinct field". Returns double.</li>
                    <li><b>sum(val)</b> - returns the sum of "val". "val" can be a field, numeric field expression, 
                        or "distinct field". Returns the same type as the type being summed</li>
                    <li><b>count(val)</b> - returns the count of records of "val". "val" can be a field, or can be 
                        "this", or "distinct field". Returns long</li>
                    <li><b>min(val)</b> - returns the minimum of "val". "val" can be a field.
                        Returns the same type as the type used in "min"</li>
                    <li><b>max(val)</b> - returns the maximum of "val". "val" can be a field.
                        Returns the same type as the type used in "max"</li>
                </ul>
                <p>
                    So to utilise these you could specify a result like
                </p>
                <source><![CDATA[max(price), min(price)]]></source>
                <p>
                    This will return a single row of results with 2 values, the maximum price and the minimum price.
                </p>
                <p>
                    Note that what you specify in the <i>result</i> defines what form of result you get back
                    when executing the query.
                </p>
                <ul>
                    <li><b>{ResultClass}</b> - this is returned if you have only a single row in the results and
                        you specified a result class.</li>
                    <li><b>Object</b> - this is returned if you have only a single row in the results and a single 
                        column. This is achived when you specified either UNIQUE, or just an aggregate 
                        (e.g "max(field2)")</li>
                    <li><b>Object[]</b> - this is returned if you have only a single row in the results, but more 
                        than 1 column (e.g "max(field1), avg(field2)")</li>
                    <li><b>List&lt;{ResultClass}&gt;</b> - this is returned if you specified a result class.</li>
                    <li><b>List&lt;Object&gt;</b> - this is returned if you have only a single column in the result, 
                        and you don't have only aggregates in the result (e.g "field2")</li>
                    <li><b>List&lt;Object[]&gt;</b> - this is returned if you have more than 1 column in the result, 
                        and you don't have only aggregates in the result (e.g "field2, avg(field3)")</li>
                </ul>
                <br/>
            </subsection>

            <a name="resultclass"/>
            <subsection name="Result Class">
                <p>
                    By default a JDOQL query will return a result matching the result clause. You can override
                    this if you wish by specifying a result class. If your query has only a single row in the
                    results then you will get an object of your result class back, otherwise you get a List
                    of result class objects.
                    The <i>Result Class</i> has to meet certain requirements. These are
                </p>
                <ul>
                    <li>Can be one of Integer, Long, Short, Float, Double, Character, Byte, Boolean, String, 
                        java.math.BigInteger, java.math.BigDecimal, java.util.Date, java.sql.Date, java.sql.Time,
                        java.sql.Timestamp, or Object[]</li>
                    <li>Can be a user defined class, that has either a constructor taking arguments of the same type
                        as those returned by the query (in the same order), or has a public put(Object, Object) method, 
                        or public setXXX() methods, or public fields.</li>
                </ul>
                <p>
                    In terms of how the <i>Result Class</i> looks, you have two options
                </p>
                <ul>
                    <li>Constructor taking arguments of the same types and the same order as the result clause.
                        An instance of the result class is created using this constructor. For example
<source>
public class Price
{
    protected double amount = 0.0;
    protected String currency = null;

    public Price(double amount, String currency)
    {
        this.amount = amount;
        this.currency = currency;
    }

    ...
}</source></li>
                    <li>Default constructor, and setters for the different result columns, using the alias
                        name for each column as the property name of the setter. For example
<source>
public class Price
{
    protected double amount = 0.0;
    protected String currency = null;

    public Price()
    {
    }

    public void setAmount(double amt) {this.amount = amt;}
    public void setCurrency(String curr) {this.currency = curr;}

    ...
}</source></li>
                </ul>
                <br/>
            </subsection>

            <a name="grouping"/>
            <subsection name="Grouping of Results">
                <p>
                    By default your results will have no specified "grouping". You can specify a <i>grouping</i> with
                    optional <i>having</i> expression. When grouping is specified, each result expression must either 
                    be an expression contained in the grouping, or an aggregate evaluated once per group.
                </p>
                <br/>
            </subsection>

            <a name="ordering"/>
            <subsection name="Ordering of Results">
                <p>
                    By default your results will be returned in the order determined by the datastore, so don't rely
                    on any particular order. You can, of course, specify the order yourself. You do this
                    using field/property names and <i>ASC</i>/<i>DESC</i> keywords. For example
                </p>
                <source><![CDATA[field1 ASC, field2 DESC]]></source>
                <p>
                    which will sort primarily by <i>field1</i> in ascending order, then secondarily by
                    <i>field2</i> in descending order.
                </p>
                <img src="../images/nucleus_extension.gif" border="0" alt=""/>
                <p>
                    Although it is not (yet) standard JDOQL, DataNucleus also supports specifying a directive
                    for where NULL values of the ordered field/property go in the order, so the full syntax
                    supported is
                </p>
                <source><![CDATA[fieldName [ASC|DESC] [NULLS FIRST|NULLS LAST]]]></source>
                <p>
                    Note that this is only supported for a few RDBMS (H2, HSQLDB, PostgreSQL, DB2, Oracle, Derby, Firebird, SQLServer v11+).
                </p>
                <br/>
            </subsection>

            <a name="range"/>
            <subsection name="Range of Results">
                <p>
                    By default your query will return all results matching the specified filter. You can
                    select just a particular range of results by specifying the <i>RANGE</i> part of the query
                    (or by using <i>setRange</i> when using the declarative API). For example
                </p>
                <source><![CDATA[RANGE 10,20]]></source>
                <p>
                    which will return just the results numbers 10-19 inclusive. Obviously bear in mind that if
                    specifying the range then you should really specify an <a href="#ordering">ordering</a> otherwise
                    the range positions will be not defined.
                </p>
                <br/>
            </subsection>
        </section>

        <section name="JDOQL In-Memory queries">
            <img src="../images/nucleus_extension.gif" border="0" alt=""/>
            <a name="inmemory"/>
            <p>
                The typical use of a JDOQL query is to translate it into the native query language of the
                datastore and return objects matched by the query. Sometimes you want to query over a set of objects
                that you have to hand, or for some datastores it is simply impossible to support the full JDOQL syntax 
                in the datastore <i>native query language</i>. In these situation we need to evaluate the query 
                <i>in-memory</i>. 
                In the latter case of the datastore not supported the full JDOQL syntax we evaluate as much as we can 
                in the datastore and then instantiate those objects and evaluate further in-memory.
                Here we document the current capabilities of <i>in-memory evaluation</i> in DataNucleus.
            </p>
            <p>
                To enable evaluation in memory you specify the query extension
                <b>datanucleus.query.evaluateInMemory</b> to <i>true</i> as follows
            </p>
            <source>query.addExtension("datanucleus.query.evaluateInMemory","true");</source>
            <p>
                This is also useful where you have a Collection of (persisted) objects and want to run a
                query over the Collection. Simply turn on in-memory evaluation, and supply the candidate
                collection to the query, and no communication with the datastore will be needed.
            </p>

            <a name="candidates"/>
            <subsection name="Specify candidates to query over">
                <p>
                    With JDO you can define a set of candidate objects that should be queried, rather than just
                    going to the datastore to retrieve those objects. When you specify this you will automatically
                    be switched to evaluate the query in-memory. You set the candidates like this
                </p>
                <source><![CDATA[
Query query = pm.newQuery(...);
query.setCandidates(myCandidates);
List<Product> results = (List<Product>)query.execute();]]></source>
                <br/>
            </subsection>
        </section>

        <section name="Update/Delete queries">
            <p>
                JDOQL offers some possibilities for updating/deleting data in the datastore via query.
                Note that only the first of these is standard JDOQL, whereas the others are DataNucleus extensions.
            </p>
            <br/>

            <a name="deletebyquery"/>
            <subsection name="Deletion by Query">
                <p>
                    If you want to delete instances of a candidate using a query, you simply define
                    the query candidate/filter in the normal way, and then instead of calling <i>query.execute()</i>
                    you call <i>query.deletePersistentAll()</i>. Like this
                </p>
                <source><![CDATA[
Query query = pm.newQuery("SELECT FROM mydomain.A WHERE this.value < 50");
Long number = (Long)query.deletePersistentAll();]]></source>
                <p>
                    The value returned is the number of instances that were deleted. Note that this will perform
                    any cascade deletes that are defined for these instances. In addition, all instances in memory
                    will reflect this deletion.
                </p>
                <br/>
            </subsection>

            <a name="bulkdelete"/>
            <subsection name="Bulk Delete">
                <img src="../images/nucleus_extension.gif" alt=""/>
                <p>
                    DataNucleus provides an extension to allow bulk deletion. This differs from the "Deletion by Query"
                    above in that it simply goes straight to the datastore and performs a bulk delete, leaving it to
                    the datastore referential integrity to handle relationships. To enable "bulk delete" you need the
                    persistence property <b>datanucleus.query.jdoql.allowAll</b> set to <i>true</i>.
                    You then perform "bulk delete" like this
                </p>
                <source><![CDATA[
Query query = pm.newQuery("DELETE FROM mydomain.A WHERE this.value < 50");
Long number = (Long)query.execute();
]]></source>
                <p>
                    Again, the number returned is the number of records deleted.
                </p>
                <br/>
            </subsection>

            <a name="bulkupdate"/>
            <subsection name="Bulk Update">
                <img src="../images/nucleus_extension.gif" alt=""/>
                <p>
                    DataNucleus provides an extension to allow bulk update. This allows you to do bulk updates direct
                    to the datastore without having to load objects into memory etc. To enable "bulk update" you need 
                    the persistence property <b>datanucleus.query.jdoql.allowAll</b> set to <i>true</i>.
                    You then perform "bulk update" like this
                </p>
                <source><![CDATA[
Query query = pm.newQuery("UPDATE mydomain.A SET this.value=this.value-5.0 WHERE this.value > 100");
Long number = (Long)query.execute();
]]></source>
                <p>
                    Again, the number returned is the number of records updated.
                </p>
                <br/>
            </subsection>
        </section>

    </body>
</document>
