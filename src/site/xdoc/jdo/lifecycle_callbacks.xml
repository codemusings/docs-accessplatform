<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>Lifecycle Callbacks</title>
    </properties>

    <body>
        <section name="JDO : Lifecycle Callbacks">
            <p>
                JDO defines a mechanism whereby a persistable class can be marked as a listener for lifecycle 
                events. Alternatively a separate listener class can be defined to receive these events. Thereafter
                when entities of the particular class go through lifecycle changes events are passed to the
                provided methods. Let's look at the two different mechanisms
            </p>

            <a name="callbacks"/>
            <subsection name="Instance Callbacks">
                <p>
                    JDO defines an interface for persistable classes so that they can be notified 
                    of events in their own lifecycle and perform any additional operations that are needed at these
                    checkpoints. This is a complement to the <a href="#listeners">Lifecycle Listeners</a>
                    interface which provides listeners for all objects of particular classes, with the events sent 
                    to a listener. With <b>InstanceCallbacks</b> the <i>persistable</i> class is the 
                    destination of the lifecycle events. As a result the <b>Instance Callbacks</b> method is more 
                    intrusive than the method of <i>Lifecycle Listeners</i> in that it requires methods adding
                    to each class that wishes to receive the callbacks.
                </p>
                <p>
                    DataNucleus supports the <b>InstanceCallbacks</b> interface
                    <a href="http://db.apache.org/jdo/api20/apidocs//javax/jdo/InstanceCallbacks.html" target="_blank"><img src="../images/javadoc.gif" alt=""/></a>.
                </p>
                <p>
                    To give an example of this capability, let us define a class that needs to perform some operation just before
                    it's object is deleted.
                </p>
                <source>
public class MyClass implements InstanceCallbacks
{
    String name;

    ... (class methods)


    public void jdoPostLoad() {}
    public void jdoPreClear() {}
    public void jdoPreStore() {}

    public void jdoPreDelete()
    {
        // Perform some operation just before being deleted.
    }
}</source>
                <p>
                    So we have implemented <i>InstanceCallbacks</i> and have defined the 4 required methods. 
                    Only one of these is of importance in this example.
                </p>
                <p> 
                    These methods will be called just before storage in the data store (<i>jdoPreStore</i>), just 
                    before clearing (<i>jdoPreClear</i>), just after being loaded from the datastore 
                    (<i>jdoPostLoad</i>) and just before being deleted (<i>jdoPreDelete</i>).
                </p>
                <p>
                    JDO2 adds 2 new callbacks to complement <i>InstanceCallbacks</i>. These are 
                    <i>AttachCallback</i> 
                    <a href="http://db.apache.org/jdo/api20/apidocs/javax/jdo/listener/AttachCallback.html" target="_blank"><img src="../images/javadoc.gif" alt=""/></a>
                    and <i>DetachCallback</i>
                    <a href="http://db.apache.org/jdo/api20/apidocs/javax/jdo/listener/AttachCallback.html" target="_blank"><img src="../images/javadoc.gif" alt=""/></a>.
                    If you want to intercept attach/detach events your class can implement these interfaces. 
                    You will then need to implement the following methods
                </p>
                <source>
public interface AttachCallback
{
    public void jdoPreAttach();
    public void jdoPostAttach(Object attached);
}

public interface DetachCallback
{
    public void jdoPreDetach();
    public void jdoPostDetach(Object detached);
}</source>
                <br/>
            </subsection>

            <a name="listeners"/>
            <subsection name="Lifecycle Listeners">
                <p>
                    JDO defines an interface for the PersistenceManager and PersistenceManagerFactory whereby a
                    user can register a listener for persistence events. The user provides a listener for either all
                    classes, or a set of defined classes,  and the JDO implementation calls methods on the listener
                    when the required events occur. This provides the user application with the power to monitor the 
                    persistence process and, where necessary, append related behaviour. Specifying the listeners on 
                    the PersistenceManagerFactory has the benefits that these listeners will be added to all 
                    PersistenceManagers created by that factory, and so is for convenience really. This facility is a 
                    complement to the <a href="#callbacks">Instance Callbacks</a> facility which allows 
                    interception of events on an instance by instance basis. The <b>Lifecycle Listener</b> process is 
                    much less intrusive than the process provided by <i>Instance Callbacks</i>, allowing a class 
                    external to the persistence process to perform the listening.
                </p>
                <p>
                    DataNucleus supports the <b>InstanceLifecycleListener</b> interface.
                    <a href="http://db.apache.org/jdo/api20/apidocs/javax/jdo/listener/InstanceLifecycleListener.html" target="_blank"><img src="../images/javadoc.gif" alt=""/></a>.
                </p>
                <p>
                    To give an example of this capability, let us define a Listener for our persistence process.
                </p>
                <source>
public class LoggingLifecycleListener implements CreateLifecycleListener, 
    DeleteLifecycleListener, LoadLifecycleListener, StoreLifecycleListener
{
    public void postCreate(InstanceLifecycleEvent event)
    {
        log.info("Lifecycle : create for " + 
            ((Persistable)event.getSource()).dnGetObjectId());
    }

    public void preDelete(InstanceLifecycleEvent event)
    {
        log.info("Lifecycle : preDelete for " + 
            ((Persistable)event.getSource()).dnGetObjectId());
    }

    public void postDelete(InstanceLifecycleEvent event)
    {
        log.info("Lifecycle : postDelete for " + 
            ((Persistable)event.getSource()).dnGetObjectId());
    }

    public void postLoad(InstanceLifecycleEvent event)
    {
        log.info("Lifecycle : load for " + 
            ((Persistable)event.getSource()).dnGetObjectId());
    }

    public void preStore(InstanceLifecycleEvent event)
    {
        log.info("Lifecycle : preStore for " + 
            ((Persistable)event.getSource()).dnGetObjectId());
    }

    public void postStore(InstanceLifecycleEvent event)
    {
        log.info("Lifecycle : postStore for " + 
            ((Persistable)event.getSource()).dnGetObjectId());
    }
}</source>
                <p>
                    Here we've provided a listener to receive events for CREATE, DELETE, LOAD, and STORE of objects.
                    These are the main event types and in our simple case above we will simply log the event. All 
                    that remains is for us to register this listener with the PersistenceManager, or 
                    PersistenceManagerFactory
                </p>
                <source>pm.addInstanceLifecycleListener(new LoggingLifecycleListener(), null);</source>
                <p>
                    When using this interface the user should always remember that the listener is called within 
                    the same transaction as the operation being reported and so any changes they then make to the 
                    objects in question will be reflected in that objects state.
                </p>
                <p>
                    Register the listener with the PersistenceManager or PersistenceManagerFactory provide 
                    different effects. Registering with the PersistenceManagerFactory means that all 
                    PersistenceManagers created by it will have the listeners registered on the 
                    PersistenceManagerFactory called. Registering the listener with the PersistenceManager will 
                    only have the listener called only on events raised only by the PersistenceManager instance.
                </p>
    			<p>
                    <img src="../images/lifecyclelistener_pm.jpg" alt=""/><br/>
    				The above diagram displays the sequence of actions for a listener registered only in the 
                    PersistenceManager. Note that a second PersistenceManager will not make calls to the listener 
                    registered in the first PersistenceManager.
                </p>
    			<p>
                    <img src="../images/lifecyclelistener_pmf.jpg" alt=""/><br/>
    				The above diagram displays the sequence of actions for a listener registered in the 
                    PersistenceManagerFactory. All events raised in a PersistenceManager obtained from the 
                    PersistenceManagerFactory will make calls to the listener registered in the 
                    PersistenceManagerFactory.
                </p>
                <br/>
                <p>
                    DataNucleus supports the following instance lifecycle listener types
                </p>
                <ul>
                    <li><b>AttachLifecycleListener</b> - all attach events</li>
                    <li><b>ClearLifecycleListener</b> - all clear events</li>
                    <li><b>CreateLifecycelListener</b> - all object create events</li>
                    <li><b>DeleteLifecycleListener</b> - all object delete events</li>
                    <li><b>DetachLifecycleListener</b> - all detach events</li>
                    <li><b>DirtyLifecycleListener</b> - all dirty events</li>
                    <li><b>LoadLifecycleListener</b> - all load events</li>
                    <li><b>StoreLifecycleListener</b> - all store events</li>
                </ul>

                <img src="../images/nucleus_extension.gif" alt=""/>
                <p>
                    The default JDO2 lifecycle listener <i>StoreLifecycleListener</i> only informs the 
                    listener of the object being stored. It doesn't provide information about the fields 
                    being stored in that event. DataNucleus extends the JDO2 specification and on the 
                    "preStore" event it will return an instance of
                    <i>org.datanucleus.api.jdo.FieldInstanceLifecycleEvent</i> (which extends the JDO2 
                    InstanceLifecycleEvent) and provides access to the names of the fields being stored.
                </p>
                <source>
public class FieldInstanceLifecycleEvent extends InstanceLifecycleEvent
{
    ...

    /**
     * Accessor for the field names affected by this event
     * @return The field names
     */
    public String[] getFieldNames()
    ...
}</source>
                <p>
                    If the store event is the persistence of the object then this will return all field names.
                    If instead just particular fields are being stored then you just receive those fields in
                    the event. So the only thing to do to utilise this DataNucleus extension is cast the 
                    received event to <i>org.datanucleus.FieldInstanceLifecycleEvent</i>
                </p>
            </subsection>
        </section>
    </body>
</document>