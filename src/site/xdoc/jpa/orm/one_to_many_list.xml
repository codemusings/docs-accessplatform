<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>JPA 1-N Relationships : List</title>
    </properties>

    <body>
        <section name="JPA : 1-N Relationships with Lists">
            <p>
				You have a 1-N (one to many) when you have one object of a class that has a List of 
                objects of another class. There are two ways in which you can represent this in a datastore.
                <b>Join Table</b> (where a join table is used to provide the relationship mapping between the objects), and 
                <b>Foreign-Key</b> (where a foreign key is placed in the table of the object contained in the List.
            </p>
            <p>
                The various possible relationships are described below.
            </p>
            <ul>
                <li><a href="#join_uni">1-N Unidirectional using Join Table</a></li>
                <li><a href="#fk_uni">1-N Unidirectional using Foreign-Key</a></li>
                <li><a href="#join_bi">1-N Bidirectional using Join Table</a></li>
                <li><a href="#fk_bi">1-N Bidirectional using Foreign-Key</a></li>
                <li><a href="#join_nonpc">List of non-PC using Join Table</a></li>
                <li><a href="#converter_nonpc">Collection of non-persistable using AttributeConverter into single column</a></li>
            </ul>
            <p>
                This page is aimed at List fields and so applies to fields of Java type
                <i>java.util.ArrayList, java.util.LinkedList, java.util.List, java.util.Stack, java.util.Vector</i>
            </p>
            <table class="infoTable"><tr>
                <td><img src="../../images/lightbulb.png" border="0"/></td>
                <td>
                    Please note that RDBMS supports the full range of options on this page, whereas other datastores (ODF, Excel, HBase, MongoDB, etc) persist the List in a 
                    column in the owner object (as well as a column in the non-owner object when bidirectional) rather than using join-tables or foreign-keys since 
                    those concepts are RDBMS-only.
                </td>
            </tr></table>
            <p>
                <b>In JPA1 all List relationships are "ordered Lists"</b>. If a List is an "ordered List" 
                then the positions of the elements in the List at persistence are not preserved (are not 
                persisted) and instead an ordering is defined for their retrieval.
                <b>In JPA2 Lists can optionally use a surrogate column to handle the ordering</b>.
                This means that the positions of the elements in List at persistence are preserved. This
                is the same situation as JDO provides.
            </p>

            <subsection name="equals() and hashCode()">
                <p>
                    <b>Important : The element of a Collection ought to define the methods <i>equals</i> and 
                    <i>hashCode</i> so that updates are detected correctly.</b> This is because any Java Collection will
                    use these to determine equality and whether an element is <i>contained</i> in the Collection.
                    Note also that the hashCode() should be consistent throughout the lifetime of a persistable
                    object. By that we mean that it should <b>not</b> use some basis before persistence and then use 
                    some other basis (such as the object identity) after persistence, for this reason we do not
                    recommend usage of <i>JDOHelper.getObjectId(obj)</i> in the equals/hashCode methods.
                </p>
            </subsection>
        </section>

        <section name="1-N List Unidirectional">
            <p>
                We have 2 sample classes <b>Account</b> and <b>Address</b>. These are related in such a way as <b>Account</b>
                contains a <i>List</i> of objects of type <b>Address</b>, yet each <b>Address</b> knows nothing about the
				<b>Account</b> objects that it relates to. Like this
            </p>
            <img src="../../images/orm/relationship_1_N_uni_list_class.jpg" border="0" alt=""/>
			<p>
				There are 2 ways that we can persist this relationship. These are shown below
			</p>

            <a name="join_uni"/>
            <subsection name="Using Join Table">
                <p>
                    If you define the XML metadata for these classes as follows
                </p>
                <source><![CDATA[
<entity-mappings>
    <entity class="Account">
        <table name="ACCOUNT"/>
        <attributes>
            <id name="id">
                <column name="ACCOUNT_ID"/>
            </id>
            ...
            <one-to-many name="addresses" target-entity="com.mydomain.Address">
                <order-by>id</order-by>
                <join-table name="ACCOUNT_ADDRESSES">
                    <join-column name="ACCOUNT_ID_OID"/>
                    <inverse-join-column name="ADDRESS_ID_EID"/>
                </join-table>
            </one-to-many>
        </attributes>
    </entity>

    <entity class="Address">
        <table name="ADDRESS"/>
        <attributes>
            <id name="id">
                <column name="ADDRESS_ID"/>
            </id>
            ...
        </attributes>
    </entity>
</entity-mappings>]]></source>
                <p>
                    or alternatively using annotations
                </p>
                <source><![CDATA[
public class Account
{
    ...

    @OneToMany
    @OrderBy("id")
    @JoinTable(name="ACCOUNT_ADDRESSES", 
        joinColumns={@JoinColumn(name="ACCOUNT_ID_OID")},
        inverseJoinColumns={@JoinColumn(name="ADDRESS_ID_EID")})
    List<Address> addresses
}

public class Address
{
    ...
}]]></source>
                <table class="infoTable"><tr>
                    <td><img src="../../images/lightbulb.png" border="0"/></td>
                    <td>The crucial part is the <i>join-table</i> element on the field element (@JoinColumn annotation) - this signals to JPA to use a join table.</td>
                </tr></table>
                <p>
                    There will be 3 tables, one for <b>Address</b>, one for <b>Account</b>, and the join table. 
                    This is identical to the handling for Sets/Collections. 
                    Note that we specified &lt;order-by&gt; which defines the order the elements are 
                    retrieved in (the "id" is the field in the List element).
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_N_uni_set_join_db.gif" border="0" alt=""/>
                <br/>
                <p>
                    The join table is used to link the 2 classes via foreign keys to their primary key. 
                    This is useful where you want to retain the independence of one class from the other 
                    class.
                </p>
                <p>
                    If you wish to fully define the schema table and column names etc, follow these tips
                </p>
                <ul>
                    <li>To specify the name of the table where a class is stored, specify the <i>table</i> 
                        element below the <b>class</b> element</li>
                    <li>To specify the names of the columns where the fields of a class are stored, specify 
                        the <i>column</i> attribute on the <b>basic</b> element.</li>
                    <li>To specify the name of the join table, specify the <i>join-table</i> element below 
                        the <b>one-to-many</b> element with the collection.</li>
                    <li>To specify the names of the join table columns, use the <i>join-column</i> and 
                        <i>inverse-join-column</i> elements below the <i>join-table</i> element.</li>
                    <li>The join table will NOT be given a primary key (so that duplicates can be stored).</li>
                    <li>If you want to have a surrogate column added to contain the ordering you
                        should specify <i>order-column</i> (@OrderColumn) instead of <i>order-by</i>.
                        This is available from JPA2</li>
                </ul>
                <br/>
            </subsection>

            <a name="fk_uni"/>
            <subsection name="Using Foreign-Key">
                <p>
                    In this relationship, the <b>Account</b> class has a List of <b>Address</b> objects, yet 
                    the <b>Address</b> knows nothing about the <b>Account</b>. In this case we don't have a 
                    field in the Address to link back to the Account and so DataNucleus has to use columns 
                    in the datastore representation of the <b>Address</b> class. 
                    So we define the XML metadata like this
                </p>
                <source><![CDATA[
<entity-mappings>
    <entity class="Account">
        <table name="ACCOUNT"/>
        <attributes>
            <id name="id">
                <column name="ACCOUNT_ID"/>
            </id>
            ...
            <one-to-many name="addresses" target-entity="com.mydomain.Address">
                <order-by>city</order-by>
                <join-column name="ACCOUNT_ID"/>
            </one-to-many>
        </attributes>
    </entity>

    <entity class="Address">
        <table name="ADDRESS"/>
        <attributes>
            <id name="id">
                <column name="ADDRESS_ID"/>
            </id>
            ...
        </attributes>
    </entity>
</entity-mappings>]]></source>
                <p>
                    or alternatively using annotations
                </p>
                <source><![CDATA[
public class Account
{
    ...

    @OneToMany
    @OrderBy("city")
    @JoinColumn(name="ACCOUNT_ID")
    List<Address> addresses
}

public class Address
{
    ...
}]]></source>
                <table class="infoTable"><tr>
                    <td><img src="../../images/lightbulb.png" border="0"/></td>
                    <td>Note that you MUST specify the join-column here otherwise it defaults to a join table with JPA!</td>
                </tr></table>
                <p> 
                    Again there will be 2 tables, one for <b>Address</b>, and one for <b>Account</b>.
                    Note that we have no "mapped-by" attribute specified, and also no "join" element. If you 
                    wish to specify the names of the columns used in the schema for the foreign key in the 
                    <b>Address</b> table you should use the <i>element</i> element within the field of the 
                    collection.
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_N_uni_set_fk_db.gif" border="0" alt=""/>
                <br/>
                <p>
                    In terms of operation within your classes of assigning the objects in the relationship. 
                    With DataNucleus and List-based containers you have to take your <b>Account</b> object 
                    and add the <b>Address</b> to the <b>Account</b> collection field since the <b>Address</b>
                    knows nothing about the <b>Account</b>.
                </p>
                <p>
                    If you wish to fully define the schema table and column names etc, follow these tips
                </p>
                <ul>
                    <li>To specify the name of the table where a class is stored, specify the <i>table</i> 
                        element below the <b>class</b> element</li>
                    <li>To specify the names of the columns where the fields of a class are stored, specify 
                        the <i>column</i> attribute on the <b>basic</b> element.</li>
                </ul>
                <p>
                    <b>Limitations</b>
                </p>
                <ul>
                    <li>If we are using an "ordered List" and the primary key of the join table contains 
                        owner and element then duplicate elements can't be stored in a List. If you want to 
                        allow duplicate List entries, then use the "Join Table" variant above.</li>
                </ul>
                <br/>
            </subsection>

		</section>

        <section name="1-N List Bidirectional">
            <p>
                We have 2 sample classes <b>Account</b> and <b>Address</b>. These are related in such a way 
                as <b>Account</b> contains a <i>List</i> of objects of type <b>Address</b>, and each 
                <b>Address</b> has a reference to the <b>Account</b> object that it relates to. Like this
            </p>
            <img src="../../images/orm/relationship_1_N_bi_list_class.jpg" border="0" alt=""/>
			<p>
				There are 2 ways that we can persist this relationship. These are shown below
			</p>

            <a name="join_bi"/>
            <subsection name="Using Join Table">
                <p>
                    If you define the XML metadata for these classes as follows
                </p>
                <source><![CDATA[
<entity-mappings>
    <entity class="Account">
        <table name="ACCOUNT"/>
        <attributes>
            <id name="id">
                <column name="ACCOUNT_ID"/>
            </id>
            ...
            <one-to-many name="addresses" target-entity="com.mydomain.Address" mapped-by="account">
                <order-by>id</order-by>
                <join-table name="ACCOUNT_ADDRESSES">
                    <join-column name="ACCOUNT_ID_OID"/>
                    <inverse-join-column name="ADDRESS_ID_EID"/>
                </join-table>
            </one-to-many>
        </attributes>
    </entity>

    <entity class="Address">
        <table name="ADDRESS"/>
        <attributes>
            <id name="id">
                <column name="ADDRESS_ID"/>
            </id>
            ...
            <many-to-one name="account">
            </many-to-one>
        </attributes>
    </entity>
</entity-mappings>]]></source>
                <p>
                    or alternatively using annotations
                </p>
                <source><![CDATA[
public class Account
{
    ...

    @OneToMany(mappedBy="account")
    @OrderBy("id")
    @JoinTable(name="ACCOUNT_ADDRESSES", 
        joinColumns={@JoinColumn(name="ACCOUNT_ID_OID")},
        inverseJoinColumns={@JoinColumn(name="ADDRESS_ID_EID")})
    List<Address> addresses
}

public class Address
{
    ...

    @ManyToOne
    Account account;

    ...
}]]></source>
                <table class="infoTable"><tr>
                    <td><img src="../../images/lightbulb.png" border="0"/></td>
                    <td>The crucial part is the <i>join-table</i> element on the field element (@JoinTable annotation) - this signals to JPA to use a join table.</td>
                </tr></table>
                <p>
                    This will create 3 tables in the database, one for <b>Address</b>, 
                    one for <b>Account</b>, and a join table, as shown below.
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_N_bi_set_join_db.gif" border="0" alt=""/>
                <br/>
                <p>
                    The join table is used to link the 2 classes via foreign keys to their primary key. 
                    This is useful where you want to retain the independence of one class from the other class.
                </p>
                <p>
                    If you wish to fully define the schema table and column names etc, follow these tips
                </p>
                <ul>
                    <li>To specify the name of the table where a class is stored, specify the <i>table</i> element below the <b>class</b> element</li>
                    <li>To specify the names of the columns where the fields of a class are stored, specify the <i>column</i> attribute on the <b>basic</b> element.</li>
                    <li>To specify the name of the join table, specify the <i>join-table</i> element below the <b>one-to-many</b> element with the collection.</li>
                    <li>To specify the names of the join table columns, use the <i>join-column</i> and <i>inverse-join-column</i> elements below the <i>join-table</i> element.</li>
                    <li>The join table will NOT be given a primary key (so that duplicates can be stored).</li>
                    <li>When forming the relation please make sure that <b>you set the relation at BOTH sides</b> since 
                        DataNucleus would have no way of knowing which end is correct if you only set one end.</li>
                    <li>If you want to have a surrogate column added to contain the ordering you
                        should specify <i>order-column</i> (@OrderColumn) instead of <i>order-by</i>.</li>
                </ul>
                <br/>
            </subsection>

            <a name="fk_bi"/>
            <subsection name="Using Foreign-Key">
                <p>Here we have the 2 classes with both knowing about the relationship with the other.</p>
                <p>
                    <b>Please note that an <i>Foreign-Key</i> List will NOT, by default, allow duplicates. This is because it stores the element position in the element table. 
                        If you need a List with duplicates we recommend that you use the <i>Join Table</i> List implementation above.</b> 
                    If you have an application identity element class then you <i>could</i> in principle add 
                    the element position to the primary key to allow duplicates, but this would imply
                    changing your element class identity.
                </p>
                <p>
                    If you define the XML metadata for these classes as follows
                </p>
                <source><![CDATA[
<entity-mappings>
    <entity class="Account">
        <table name="ACCOUNT"/>
        <attributes>
            <id name="id">
                <column name="ACCOUNT_ID"/>
            </id>
            ...
            <one-to-many name="addresses" target-entity="com.mydomain.Address" mapped-by="account">
                <order-by>city ASC</order-by>
                <join-column name="ACCOUNT_ID"/>
            </one-to-many>
        </attributes>
    </entity>

    <entity class="Address">
        <table name="ADDRESS"/>
        <attributes>
            <id name="id">
                <column name="ADDRESS_ID"/>
            </id>
            ...
            <many-to-one name="account">
            </many-to-one>
        </attributes>
    </entity>
</entity-mappings>]]></source>
                <p>
                    or alternatively using annotations
                </p>
                <source><![CDATA[
public class Account
{
    ...

    @OneToMany(mappedBy="account")
    @OrderBy("city")
    @JoinColumn(name="ACCOUNT_ID")
    List<Address> addresses
}

public class Address
{
    ...

    @ManyToOne
    Account account;

    ...
}]]></source>
                <table class="infoTable"><tr>
                    <td><img src="../../images/lightbulb.png" border="0"/></td>
                    <td>The crucial part is the <i>mapped-by</i> attribute of the field on the "1" side of the relationship. 
                        This tells the JPA implementation to look for a field called <i>account</i> on the <b>Address</b> class.</td>
                </tr></table>
                <p>
                    This will create 2 tables in the database, one for 
                    <b>Address</b> (including an <i>ACCOUNT_ID</i> to link to the <i>ACCOUNT</i> table), and 
                    one for <b>Account</b>. Notice the subtle difference to this set-up to that of the 
                    <b>Join Table</b> relationship earlier.
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_N_bi_set_fk_db.gif" border="0" alt=""/>
                <br/>
                <p>
                    If you wish to fully define the schema table and column names etc, follow these tips
                </p>
                <ul>
                    <li>To specify the name of the table where a class is stored, specify the <i>table</i> 
                        element below the <b>class</b>element</li>
                    <li>To specify the names of the columns where the fields of a class are stored, specify 
                        the <i>column</i> attribute on the <b>basic</b> element.</li>
                    <li>When forming the relation please make sure that <b>you set the relation at BOTH sides</b> since 
                        DataNucleus would have no way of knowing which end is correct if you only set one end.</li>
                </ul>
                <p>
                    <b>Limitation : </b> Since each Address object can have at most one owner (due to the 
                    "Foreign Key") this mode of persistence will not allow duplicate values in the Collection.
                    If you want to allow duplicate Collection entries, then use the "Join Table" variant
                    above.
                </p>
                <br/>
            </subsection>
        </section>

        <section name="1-N Collection of non-Entity objects">
            <a name="join_nonpc"/>
            <p>
                All of the examples above show a 1-N relationship between 2 persistable classes. 
                If you want the element to be primitive or Object types then follow this section. For example, when you 
                have a List of Strings. This will be persisted in the same way as the "Join Table" 
                examples above. A join table is created to hold the collection elements. 
                Let's take our example. We have an <b>Account</b> that stores a Collection of addresses. 
                These addresses are simply Strings. We define the annotations like this
            </p>
<source><![CDATA[
@Entity
public class Account
{
    ...

    @ElementCollection
    @CollectionTable(name="ACCOUNT_ADDRESSES")
    Collection<String> addresses;
}]]></source>
            <p>or using XML metadata</p>
<source><![CDATA[
    <entity class="mydomain.Account">
        <attributes>
            ...
            <element-collection name="addresses">
                <collection-table name="ACCOUNT_ADDRESSES"/>
            </element-collection>
        </attributes>
    </entity>
]]></source>
            <p>
                In the datastore the following is created
            </p>
            <img src="../../images/orm/relationship_1_N_primitive_collection_db.gif" border="0" alt=""/>
            <p>
                The ACCOUNT table is as before, but this time we only have the "join table".
                Use @Column on the field/method to define the column details of the element in the join table.
            </p>
        </section>

        <section name="Collection of non-persistable objects using AttributeConverter">
            <a name="converter_nonpc"/>
            <p>
                Just like in the above example, here we have a List of simple types. In this case we are wanting to store this List into
                a single column in the owning table. We do this by using a JPA AttributeConverter.
            </p>
<source><![CDATA[
public class Account
{
    ...

    @ElementCollection
    @Convert(ListStringToStringConverter.class)
    @Column(name="ADDRESSES")
    List<String> addresses;
}]]></source>
            <p>
                and then define our converter. You can clearly define your conversion process how you want it. You could, for example, convert the
                List into comma-separated strings, or could use JSON, or XML, or some other format.
            </p>
<source><![CDATA[

public class ListStringToStringConverter implements AttributeConverter<List<String>, String>
{
    public String convertToDatabaseColumn(List<String> attribute)
    {
        if (attribute == null)
        {
            return null;
        }

        StringBuilder str = new StringBuilder();
        ... convert List to String
        return str.toString();
    }

    public List<String> convertToEntityAttribute(String columnValue)
    {
        if (columnValue == null)
        {
            return null;
        }

        List<String> list = new ArrayList<String>();
        ... convert String to List
        return list;
    }
}]]></source>
        </section>
    </body>
</document>