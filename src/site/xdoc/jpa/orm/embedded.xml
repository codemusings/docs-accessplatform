<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>JPA Embedded Objects</title>
    </properties>

    <body>
        <section name="JPA : Embedded Fields">
            <p>
                The JPA persistence strategy typically involves persisting the fields of any class into its 
                own table, and representing any relationships from the fields of that class across to other 
                tables. There are occasions when this is undesirable, maybe due to an existing datastore 
                schema, or because a more convenient datastore model is required. JPA allows the
                persistence of fields as <i>embedded</i> typically into the same table as the "owning" class.
            </p>

            <p>
                One important decision when defining objects of a type to be embedded into another type is 
                whether objects of that type will ever be persisted in their own right into their own table, 
                and have an identity. JPA provides a MetaData attribute that you can use to signal this.
            </p>
            <source><![CDATA[
<embeddable name="mydomain.MyClass">
    ...
</embeddable>]]></source>
            <p>
                or using annotations
            </p>
            <source><![CDATA[
@Embeddable
public class MyClass
{
    ...
}
]]></source>
            <p>
                With the above MetaData (using the <i>embeddable</i> definition), in our application any 
                objects of the class <b>MyClass</b> can be embedded into other objects.
            </p>
            <p>
                JPA's definition of embedding encompasses several types of fields. These are described below
            </p>
            <ul>
                <li><a href="#PC">Embedded Entities</a> - where you have a 1-1 relationship and you 
                    want to embed the other Entity into the same table as the your object.</li>
                <li><a href="#NestedPC">Embedded Nested Entities</a> - like the first example except 
                    that the other object also has another Entity that also should be embedded</li>
                <li><a href="#Collection">Embedded Collection elements</a> - where you want to embed the elements of a 
                    collection into a join table (instead of persisting them into their own table)</li>
                <li><a href="#Map">Embedded Map keys/values</a> - where you want to embed the keys/values of a map 
                    into a join table (instead of persisting them into their own table)</li>
            </ul>
            <p>
                Note that, for RDBMS, <b>there are some restrictions with respect to what types of fields you can have in an embedded class</b>. DataNucleus supports
                all basic types, as well as 1-1/N-1 relations (where the <i>foreign-key</i> is at the embedded object side). It does not support 1-N/M-N fields since the
                owner object of the collection element is not clearly defined (since an embedded class has no "identity" as such).
            </p>
            <table class="infoTable"><tr>
                <td><img src="../../images/lightbulb.png" border="0"/></td>
                <td>Please note that whilst nested embedded members are supported, you cannot use recursive embedded objects since that would require potentially infinite 
                    columns in the owner table, or infinite embedded join tables.</td>
            </tr></table>
            <br/>

            <a name="PC"/>
            <subsection name="Embedding entities (1-1)">
                <table class="datastoreTable"><tr><td>Applicable to RDBMS, Excel, OOXML, ODF, HBase, MongoDB, Neo4j, Cassandra, JSON.</td></tr></table>
                <p>
                    In a typical 1-1 relationship between 2 classes, the 2 classes in the relationship are 
                    persisted to their own table, and a foreign key is managed between them. With JPA and 
                    DataNucleus you can persist the related entity object as embedded into the same table. 
                    This results in a single table in the datastore rather than one for each of the 2 classes.
                </p>
                <p>
                    Let's take an example. We are modelling a <b>Computer</b>, and in our simple model our 
                    <b>Computer</b> has a graphics card and a sound card. So we model these cards using a
                    <b>ComputerCard</b> class. So our classes become
                </p>
                <source>
public class Computer
{
    private String operatingSystem;

    private ComputerCard graphicsCard;

    private ComputerCard soundCard;

    public Computer(String osName, ComputerCard graphics, ComputerCard sound)
    {
        this.operatingSystem = osName;
        this.graphicsCard = graphics;
        this.soundCard = sound;
    }

    ...
}

public class ComputerCard
{
    public static final int ISA_CARD = 0;
    public static final int PCI_CARD = 1;
    public static final int AGP_CARD = 2;

    private String manufacturer;

    private int type;

    public ComputerCard(String manufacturer, int type)
    {
        this.manufacturer = manufacturer;
        this.type = type;
    }

    ...
}</source>
                <p>
                    The traditional (default) way of persisting these classes would be to have a table to 
                    represent each class. So our datastore will look like this
                </p>
                <img src="../../images/orm/embedded_pc_traditional_db.gif" border="0" alt=""/><br/><br/>
                <p>
                    However we decide that we want to persist <b>Computer</b> objects into a table called 
                    COMPUTER and we also want to persist the PC cards into the <u>same table</u>. 
                    We define our MetaData like this
                </p>
                <source><![CDATA[
<entity name="mydomain.Computer">
    <attributes>
        <basic name="operatingSystem">
            <column="OS_NAME"/>
        </basic>
        <embedded name="graphicsCard">
            <attribute-override name="manufacturer">
                <column="GRAPHICS_MANUFACTURER"/>
            </attribute-override>
            <attribute-override name="type">
                <column="GRAPHICS_TYPE"/>
            </attribute-override>
        </embedded>
        <embedded name="soundCard">
            <attribute-override name="manufacturer">
                <column="SOUND_MANUFACTURER"/>
            </attribute-override>
            <attribute-override name="type">
                <column="SOUND_TYPE"/>
            </attribute-override>
        </embedded>
    </attributes>
</entity>
<embeddable name="mydomain.ComputerCard">
    <attributes>
        <basic name="manufacturer"/>
        <basic name="type"/>
    </attributes>
</embeddable>]]></source>
                <p>
                    So here we will end up with a TABLE called "COMPUTER" with columns "COMPUTER_ID", 
                    "OS_NAME", "GRAPHICS_MANUFACTURER", "GRAPHICS_TYPE", "SOUND_MANUFACTURER", "SOUND_TYPE". 
                    If we call persist() on any objects of type <b>Computer</b>, they will be persisted into
                    this table.
                </p>
                <img src="../../images/orm/embedded_pc_embedded_db.gif" border="0" alt=""/><br/>
                <p>
                    It should be noted that in this latter (embedded) case we can still persist objects of 
                    type <b>ComputerCard</b> into their own table - the MetaData definition for 
                    <b>ComputerCard</b> is used for the table definition in this case.
                </p>
                <p>
                    DataNucleus supports embedded persistable objects with the following proviso :-
                </p>
                <ul>
                    <li>You can represent inheritence of embedded objects using a discriminator (you must define it in 
                        the metadata of the embedded type. Note that this is a DataNucleus extension since JPA doesn't 
                        define any support for embedded inherited persistable objects</li>
                </ul>
                <p>See also :-</p>
                <ul>
                    <li><a href="../metadata_xml.html#embedded">MetaData reference for &lt;embedded&gt; element</a></li>
                    <li><a href="../annotations.html#Embeddable">Annotations reference for @Embeddable</a></li>
                    <li><a href="../annotations.html#Embedded">Annotations reference for @Embedded</a></li>
                </ul>
                <br/>
            </subsection>

            <a name="NestedPC"/>
            <subsection name="Embedding Nested Entities">
                <table class="datastoreTable"><tr><td>Applicable to RDBMS, Excel, OOXML, ODF, HBase, MongoDB, Neo4j, Cassandra, JSON.</td></tr></table>
                <p>
                    In the above example we had an embedded Entity within a persisted object. What 
                    if our embedded Persistable object also contain another Entity object. So, 
                    using the above example what if <b>ComputerCard</b> contains an object of type <b>Connector</b> ?
                </p>
                <source>
@Embeddable
public class ComputerCard
{
    @Embedded
    Connector connector;

    public ComputerCard(String manufacturer, int type, Connector conn)
    {
        this.manufacturer = manufacturer;
        this.type = type;
        this.connector = conn;
    }

    ...
}

@Embeddable
public class Connector
{
    int type;
}</source>
                <p>We want to store all of these objects into the same record in the COMPUTER table.</p>
                <source><![CDATA[
<entity name="mydomain.Computer">
    <attributes>
        <basic name="operatingSystem">
            <column="OS_NAME"/>
        </basic>
        <embedded name="graphicsCard">
            <attribute-override name="manufacturer">
                <column="GRAPHICS_MANUFACTURER"/>
            </attribute-override>
            <attribute-override name="type">
                <column="GRAPHICS_TYPE"/>
            </attribute-override>
            <attribute-override name="connector.type">
                <column="GRAPHICS_CONNECTOR_TYPE"/>
            </attribute-override>
        </embedded>
        <embedded name="soundCard">
            <attribute-override name="manufacturer">
                <column="SOUND_MANUFACTURER"/>
            </attribute-override>
            <attribute-override name="type">
                <column="SOUND_TYPE"/>
            </attribute-override>
            <attribute-override name="connector.type">
                <column="SOUND_CONNECTOR_TYPE"/>
            </attribute-override>
        </embedded>
    </attributes>
</entity>
<embeddable name="mydomain.ComputerCard">
    <attributes>
        <basic name="manufacturer"/>
        <basic name="type"/>
    </attributes>
</embeddable>
<embeddable name="mydomain.Connector">
    <attributes>
        <basic name="type"/>
    </attributes>
</embeddable>]]></source>
                <p>
                    So we simply nest the embedded definition of the <b>Connector</b> objects within the embedded 
                    definition of the <b>ComputerCard</b> definitions for <b>Computer</b>. JPA supports this to as 
                    many levels as you require! The <b>Connector</b> objects will be persisted into the 
                    GRAPHICS_CONNECTOR_TYPE, and SOUND_CONNECTOR_TYPE columns in the COMPUTER table.
                </p>
                <img src="../../images/orm/embedded_pc_nested_embedded_db.gif" border="0" alt=""/><br/>
                <br/>
            </subsection>

            <a name="Collection"/>
            <subsection name="Embedding Collection Elements">
                <table class="datastoreTable"><tr><td>Applicable to RDBMS, MongoDB</td></tr></table>
                <p>
                    In a typical 1-N relationship between 2 classes, the 2 classes in the relationship are persisted 
                    to their own table, and either a join table or a foreign key is used to relate them. With JPA and 
                    DataNucleus you have a variation on the join table relation where you can persist the objects of 
                    the "N" side into the join table itself so that they don't have their own identity, and aren't 
                    stored in the table for that class.
                    <b>This is supported in DataNucleus with the following provisos</b>
                </p>
                <ul>
                    <li>You can have inheritance in embedded keys/values and a discriminator is added (you must define 
                        the discriminator in the metadata of the embedded type).</li>
                    <li>When retrieving embedded elements, all fields are retrieved in one call. That is, fetch 
                        plans are not utilised. This is because the embedded element has no identity so we have to 
                        retrieve all initially.</li>
                </ul>
                <p>
                    It should be noted that where the collection "element" is not <i>Persistable</i> or of a 
                    "reference" type (Interface or Object) it will <u>always</u> be embedded, and this functionality 
                    here applies to <i>Persistable</i> elements only. DataNucleus doesn't support the embedding 
                    of reference type objects currently.
                </p>
                <p>
                    Let's take an example. We are modelling a <b>Network</b>, and in our simple model our 
                    <b>Network</b> has collection of <b>Device</b>s. So we define our classes as
                </p>
                <source><![CDATA[
@Entity
public class Network
{
    private String name;

    @Embedded
    @ElementCollection
    private Collection<Device> devices = new HashSet<>();

    public Network(String name)
    {
        this.name = name;
    }

    ...
}

@Embeddable
public class Device
{
    private String name;

    private String ipAddress;

    public Device(String name, String addr)
    {
        this.name = name;
        this.ipAddress = addr;
    }

    ...
}]]></source>
                <p>
                    We decide that instead of <b>Device</b> having its own table, we want to persist them into the join
                    table of its relationship with the <b>Network</b> since they are only used by the network itself.
                    We define our MetaData like this
                </p>
                <source><![CDATA[
<entity name="mydomain.Network">
    <attributes>
        <basic name="name">
            <column="NAME" length="40"/>
        </basic>
        <element-collection name="devices">
            <collection-table name="NETWORK_DEVICES">
                <join-column name="NETWORK_ID"/>
            </collection-table>
        </element-collection>
    </attributes>
</entity>
<embeddable name="mydomain.Device">
    <attributes>
        <basic name="name">
            <column="DEVICE_NAME"/>
        </basic>
        <basic name="ipAddress">
            <column="DEVICE_IP_ADDR"/>
        </basic>
    </attributes>
</embeddable>]]></source>
                <p>
                    So here we will end up with a table called "NETWORK" with columns "NETWORK_ID", and "NAME",
                    and a table called "NETWORK_DEVICES" with columns "NETWORK_ID", "ADPT_PK_IDX", "DEVICE_NAME",
                    "DEVICE_IP_ADDR". When we persist a <b>Network</b> object, any devices are persisted into the NETWORK_DEVICES table.
                </p>
                <img src="../../images/orm/embedded_collection_embedded_db.gif" border="0" alt=""/><br/><br/>
                <p>
                    Note that if you want to override the name of the fields of the embedded element in the table of the owner, you should use
                    @AttributeOverride (when using annotations) or &lt;attribute-override&gt; (when using XML).
                </p>

                <p>See also :-</p>
                <ul>
                    <li><a href="../metadata_xml.html#embeddable">MetaData reference for &lt;embeddable&gt; element</a></li>
                    <li><a href="../metadata_xml.html#embedded">MetaData reference for &lt;embedded&gt; element</a></li>
                    <li><a href="../metadata_xml.html#element-collection">MetaData reference for &lt;element-collection&gt; element</a></li>
                    <li><a href="../metadata_xml.html#collection-table">MetaData reference for &lt;collection-table&gt; element</a></li>
                    <li><a href="../annotations.html#Embeddable">Annotations reference for @Embeddable</a></li>
                    <li><a href="../annotations.html#Embedded">Annotations reference for @Embedded</a></li>
                    <li><a href="../annotations.html#ElementCollection">Annotations reference for @ElementCollection</a></li>
                </ul>
            </subsection>

            <a name="Map"/>
            <subsection name="Embedding Map Keys/Values">
                <table class="datastoreTable"><tr><td>Applicable to RDBMS, MongoDB</td></tr></table>
                <p>
                    In a typical 1-N map relationship between classes, the classes in the relationship are persisted 
                    to their own table, and a join table forms the map linkage. With JPA and DataNucleus you have a 
                    variation on the join table relation where you can persist either the key class or the value class,
                    or both key class and value class into the join table.
                    <b>This is supported in DataNucleus with the following provisos</b>
                </p>
                <ul>
                    <li>You can have inheritance in embedded keys/values and a discriminator is added (you must define the discriminator in the metadata of the embedded type).</li>
                    <li>When retrieving embedded keys/values, all fields are retrieved in one call. That is, entity graphs and fetch specifications are not utilised. 
                        This is because the embedded key/value has no identity so we have to retrieve all initially.</li>
                </ul>
                <p>
                    It should be noted that where the map "key"/"value" is not <i>persistable</i> or of a 
                    "reference" type (Interface or Object) it will <u>always</u> be embedded, and this functionality 
                    here applies to <i>persistable</i> keys/values only. 
                    DataNucleus doesn't support embedding reference type elements currently.
                </p>
                <p>
                    Let's take an example. We are modelling a <b>FilmLibrary</b>, and in our simple model our 
                    <b>FilmLibrary</b> has map of <b>Film</b>s, keyed by a String alias. So we define our classes as
                </p>
                <source><![CDATA[
@Entity
public class FilmLibrary
{
    private String owner;

    @Embedded
    @ElementCollection
    @CollectionTable(name="FILM_LIBRARY_FILMS")
    @MapKeyColumn(name="FILM_ALIAS")
    private Map<String, Film> films = new HashMap<>();

    public FilmLibrary(String owner)
    {
        this.owner = owner;
    }

    ...
}

public class Film
{
    @Column(name="FILM_NAME")
    private String name;

    @Column(name="FILM_DIRECTOR")
    private String director;

    public Film(String name, String director)
    {
        this.name = name;
        this.director = director;
    }

    ...
}]]></source>
                <p>
                    So here we will end up with a table called "FILM_LIBRARY" with columns "FILM_LIBRARY_ID", and "OWNER",
                    and a table called "FILM_LIBRARY_FILMS" with columns "FILM_LIBRARY_ID", "FILM_ALIAS", "FILM_NAME", "FILM_DIRECTOR".
                    When we persist a <b>FilmLibrary</b> object, any films are persisted into the FILM_LIBRARY_FILMS table.
                </p>
                <img src="../../images/orm/embedded_map_embedded_db.gif" border="0" alt=""/><br/><br/>
                <p>
                    Note that if you want to override the name of the fields of the embedded key/value in the table of the owner, you should use
                    @AttributeOverride (when using annotations) or &lt;attribute-override&gt; (when using XML). In the case of fields of an embedded key
                    you should set the name as "key.{fieldName}" and in the case of fields of an embedded value you should set the name as "value.{fieldName}".
                </p>
            </subsection>
        </section>

    </body>
</document>