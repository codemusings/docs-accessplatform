<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>JPA 1-N Relationships : Collection</title>
    </properties>

    <body>
        <section name="JPA : 1-N Relationships with Collections">
            <p>
                You have a 1-N (one to many) when you have one object of a class that has a Collection of objects of another class. 
				<b>Please note that Collections allow duplicates whilst Sets don't allow duplicates, and so the persistence process reflects this with the choice of primary keys</b>.
				There are two ways in which you can represent this in a datastore : <b>Join Table</b> (where a join table is used to provide the relationship mapping between the objects), 
                and <b>Foreign-Key</b> (where a foreign key is placed in the table of the object contained in the Collection.
            </p>
            <p>
                Various possible relationships are described below.
            </p>
            <ul>
                <li><a href="#join_uni">1-N Unidirectional using Join Table</a></li>
                <li><a href="#fk_uni">1-N Unidirectional using Foreign-Key</a></li>
                <li><a href="#join_bi">1-N Bidirectional using Join Table</a></li>
                <li><a href="#fk_bi">1-N Bidirectional using Foreign-Key</a></li>
                <li><a href="#join_nonpc">Collection of non-persistable using Join Table</a></li>
                <li><a href="#converter_nonpc">Collection of non-PC using converter into single column</a></li>
                <li><a href="#shared_join">1-N using shared join table</a> (DataNucleus Extension)</li>
                <li><a href="#shared_fk">1-N using shared foreign key</a> (DataNucleus Extension)</li>
            </ul>
            <p>
                <b>Please note that RDBMS supports the full range of options on this page, whereas other datastores
                (ODF, Excel, HBase, MongoDB, etc) persist the Collection in a column in the owner object rather than using
                join-tables or foreign-keys since those concepts are RDBMS-only</b>
            </p>

            <subsection name="equals() and hashCode()">
                <p>
                    <b>Important : The element of a Collection ought to define the methods <i>equals</i> and 
                    <i>hashCode</i> so that updates are detected correctly.</b> This is because any Java Collection will
                    use these to determine equality and whether an element is <i>contained</i> in the Collection.
                    Note also that the hashCode() should be consistent throughout the lifetime of a persistable
                    object. By that we mean that it should <b>not</b> use some basis before persistence and then use 
                    some other basis (such as the object identity) after persistence in the equals/hashCode methods.
                </p>
            </subsection>
        </section>

        <section name="1-N Collection Unidirectional">
            <p>
                We have 2 sample classes <b>Account</b> and <b>Address</b>. These are related in such a way as 
                <b>Account</b> contains a <i>Collection</i> of objects of type <b>Address</b>, yet each <b>Address</b> 
                knows nothing about the <b>Account</b> objects that it relates to. Like this
            </p>
            <img src="../../images/orm/relationship_1_N_uni_collection_class.jpg" border="0" alt=""/>
			<p>
				There are 2 ways that we can persist this relationship. These are shown below
			</p>

            <a name="join_uni"/>
			<subsection name="Using Join Table">
                <p>
                    If you define the XML metadata for these classes as follows
                </p>
                <source><![CDATA[
<entity-mappings>
    <entity class="Account">
        <table name="ACCOUNT"/>
        <attributes>
            <id name="id">
                <column name="ACCOUNT_ID"/>
            </id>
            ...
            <one-to-many name="addresses" target-entity="com.mydomain.Address">
                <join-table name="ACCOUNT_ADDRESSES">
                    <join-column name="ACCOUNT_ID_OID"/>
                    <inverse-join-column name="ADDRESS_ID_EID"/>
                </join-table>
            </one-to-many>
        </attributes>
    </entity>

    <entity class="Address">
        <table name="ADDRESS"/>
        <attributes>
            <id name="id">
                <column name="ADDRESS_ID"/>
            </id>
            ...
        </attributes>
    </entity>
</entity-mappings>]]></source>
                <p>
                    or alternatively using annotations
                </p>
                <source><![CDATA[
public class Account
{
    ...

    @OneToMany
    @JoinTable(name="ACCOUNT_ADDRESSES", 
        joinColumns={@JoinColumn(name="ACCOUNT_ID_OID")},
        inverseJoinColumns={@JoinColumn(name="ADDRESS_ID_EID")})
    Collection<Address> addresses
}

public class Address
{
    ...
}]]></source>
                <table>
                    <tr>
                        <td>The crucial part is the <i>join-table</i> element on the field element - this signals
                            to JPA to use a join table.</td>
                    </tr>
                </table>
                <p>
                    This will create 3 tables in the database, one for <b>Address</b>, one for <b>Account</b>, 
                    and a join table, as shown below.
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_N_uni_set_join_db.gif" border="0" alt=""/>
                <br/>
                <p>
                    The join table is used to link the 2 classes via foreign keys to their primary key. This is useful 
                    where you want to retain the independence of one class from the other class.
                </p>
                <p>
                    If you wish to fully define the schema table and column names etc, follow these tips
                </p>
                <ul>
                    <li>To specify the name of the table where a class is stored, specify the <i>table</i> element below 
                        the <b>class</b> element</li>
                    <li>To specify the names of the columns where the fields of a class are stored, specify the 
                        <i>column</i> attribute on the <b>basic</b> element.</li>
                    <li>To specify the name of the join table, specify the <i>join-table</i> element below the <b>one-to-many</b>
                        element with the collection.</li>
                    <li>To specify the names of the join table columns, use the <i>join-column</i> and 
                        <i>inverse-join-column</i> elements below the <i>join-table</i> element.</li>
                    <li>If the field type is a Set the join table will be given a primary key (since a Set cannot have duplicates), whilst for other Collection
                        types a primary key is not assigned (since they can have duplicates).</li>
                </ul>
                <br/>
            </subsection>

            <a name="fk_uni"/>
            <subsection name="Using Foreign-Key">
                <p>
                    In this relationship, the <b>Account</b> class has a List of <b>Address</b> objects, yet the 
                    <b>Address</b> knows nothing about the <b>Account</b>. In this case we don't have a field in the 
                    Address to link back to the Account and so DataNucleus has to use columns in the datastore representation of 
                    the <b>Address</b> class. So we define the XML metadata like this
                </p>
                <source><![CDATA[
<entity-mappings>
    <entity class="Account">
        <table name="ACCOUNT"/>
        <attributes>
            <id name="id">
                <column name="ACCOUNT_ID"/>
            </id>
            ...
            <one-to-many name="addresses" target-entity="com.mydomain.Address">
                <join-column name="ACCOUNT_ID"/>
            </one-to-many>
        </attributes>
    </entity>

    <entity class="Address">
        <table name="ADDRESS"/>
        <attributes>
            <id name="id">
                <column name="ADDRESS_ID"/>
            </id>
            ...
        </attributes>
    </entity>
</entity-mappings>]]></source>
                <p>
                    or alternatively using annotations
                </p>
                <source><![CDATA[
public class Account
{
    ...

    @OneToMany
    @JoinColumn(name="ACCOUNT_ID")
    Collection<Address> addresses
}

public class Address
{
    ...
}]]></source>
                <p><b>Note that you MUST specify the join-column here otherwise it defaults to a join table with JPA!</b></p>
                <p> 
                    There will be 2 tables, one for <b>Address</b>, and one for <b>Account</b>. If you wish to specify
                    the names of the column(s) used in the schema for the foreign key in the <b>Address</b> table you should
                    use the <i>join-column</i> element within the field of the collection.
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_N_uni_set_fk_db.gif" border="0" alt=""/>
                <br/>
                <p>
                    In terms of operation within your classes of assigning the objects in the relationship. You have to 
                    take your <b>Account</b> object and add the <b>Address</b> to the <b>Account</b> collection field since
                    the <b>Address</b> knows nothing about the <b>Account</b>.
                </p>
                <p>
                    If you wish to fully define the schema table and column names etc, follow these tips
                </p>
                <ul>
                    <li>To specify the name of the table where a class is stored, specify the <i>table</i> element below 
                        the <b>class</b> element</li>
                    <li>To specify the names of the columns where the fields of a class are stored, specify the
                        <i>column</i> attribute on the <b>basic</b> element.</li>
                </ul>
                <p>
                    <b>Limitation : </b> Since each Address object can have at most one owner (due to the "Foreign Key") 
                    this mode of persistence will not allow duplicate values in the Collection. If you want to allow 
                    duplicate Collection entries, then use the "Join Table" variant above.
                </p>
                <br/>
            </subsection>
        </section>

        <section name="1-N Collection Bidirectional">
            <p>
                We have 2 sample classes <b>Account</b> and <b>Address</b>. These are related in such a way as <b>Account</b>
                contains a <i>Collection</i> of objects of type <b>Address</b>, and each <b>Address</b> has a reference to the
				<b>Account</b> object that it relates to. Like this
            </p>
            <img src="../../images/orm/relationship_1_N_bi_collection_class.jpg" border="0" alt=""/>
			<p>
				There are 2 ways that we can persist this relationship. These are shown below
			</p>

            <a name="join_bi"/>
            <subsection name="Using Join Table">
				<p>
                    If you define the XML metadata for these classes as follows
                </p>
                <source><![CDATA[
<entity-mappings>
    <entity class="Account">
        <table name="ACCOUNT"/>
        <attributes>
            <id name="id">
                <column name="ACCOUNT_ID"/>
            </id>
            ...
            <one-to-many name="addresses" target-entity="com.mydomain.Address" mapped-by="account">
                <join-table name="ACCOUNT_ADDRESSES">
                    <join-column name="ACCOUNT_ID_OID"/>
                    <inverse-join-column name="ADDRESS_ID_EID"/>
                </join-table>
            </one-to-many>
        </attributes>
    </entity>

    <entity class="Address">
        <table name="ADDRESS"/>
        <attributes>
            <id name="id">
                <column name="ADDRESS_ID"/>
            </id>
            ...
            <many-to-one name="account"/>
        </attributes>
    </entity>
</entity-mappings>]]></source>
                <p>
                    or alternatively using annotations
                </p>
                <source><![CDATA[
public class Account
{
    ...

    @OneToMany(mappedBy="account")
    @JoinTable(name="ACCOUNT_ADDRESSES", 
        joinColumns={@JoinColumn(name="ACCOUNT_ID_OID")},
        inverseJoinColumns={@JoinColumn(name="ADDRESS_ID_EID")})
    Collection<Address> addresses
}

public class Address
{
    ...

    @ManyToOne
    Account account;

    ...
}]]></source>
                <table>
                    <tr>
                        <td>The crucial part is the <i>join</i> element on the field element - this signals to 
                            JPA to use a join table.</td>
                    </tr>
                </table>
                <p>
                    This will create 3 tables in the database, one for <b>Address</b>, one for <b>Account</b>, 
                    and a join table, as shown below.
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_N_bi_set_join_db.gif" border="0" alt=""/>
                <br/>
                <p>
                    The join table is used to link the 2 classes via foreign keys to their primary key. This is useful 
                    where you want to retain the independence of one class from the other class.
                </p>
                <p>
                    If you wish to fully define the schema table and column names etc, follow these tips
                </p>
                <ul>
                    <li>To specify the name of the table where a class is stored, specify the <i>table</i> element below 
                        the <b>class</b> element</li>
                    <li>To specify the names of the columns where the fields of a class are stored, specify the 
                        <i>column</i> attribute on the <b>basic</b> element.</li>
                    <li>To specify the name of the join table, specify the <i>join-table</i> element below the 
                        <b>one-to-many</b> element with the collection.</li>
                    <li>To specify the names of the join table columns, use the <i>join-column</i> and 
                        <i>inverse-join-column</i> elements below the <i>join-table</i> element.</li>
                    <li>If the field type is a Set the join table will be given a primary key (since a Set cannot have duplicates), whilst for other Collection
                        types a primary key is not assigned (since they can have duplicates).</li>
                    <li>When forming the relation please make sure that <b>you set the relation at BOTH sides</b> since 
                        DataNucleus would have no way of knowing which end is correct if you only set one end.</li>
                </ul>
                <br/>
            </subsection>

            <a name="fk_bi"/>
            <subsection name="Using Foreign-Key">
                <p>Here we have the 2 classes with both knowing about the relationship with the other.</p>
                <p>
                    If you define the XML metadata for these classes as follows
                </p>
                <source><![CDATA[
<entity-mappings>
    <entity class="Account">
        <table name="ACCOUNT"/>
        <attributes>
            <id name="id">
                <column name="ACCOUNT_ID"/>
            </id>
            ...
            <one-to-many name="addresses" target-entity="com.mydomain.Address" mapped-by="account">
                <join-column name="ACCOUNT_ID"/>
            </one-to-many>
        </attributes>
    </entity>

    <entity class="Address">
        <table name="ADDRESS"/>
        <attributes>
            <id name="id">
                <column name="ADDRESS_ID"/>
            </id>
            ...
            <many-to-one name="account"/>
        </attributes>
    </entity>
</entity-mappings>]]></source>
                <p>
                    or alternatively using annotations
                </p>
                <source><![CDATA[
public class Account
{
    ...

    @OneToMany(mappedBy="account")
    @JoinColumn(name="ACCOUNT_ID")
    Collection<Address> addresses
}

public class Address
{
    ...

    @ManyToOne
    Account account;

    ...
}]]></source>
                <table>
                    <tr>
                        <td>The crucial part is the <i>mapped-by</i> attribute of the field on the "1" side of
                            the relationship. This tells the JPA implementation to look for a field called 
                            <i>account</i> on the <b>Address</b> class.</td>
                    </tr>
                </table>
                <p>
                    This will create 2 tables in the database, one for <b>Address</b> (including an <i>ACCOUNT_ID</i> to 
                    link to the <i>ACCOUNT</i> table), and one for <b>Account</b>. Notice the subtle difference to this 
                    set-up to that of the <b>Join Table</b> relationship earlier.
                </p>
                <br/>
                <img src="../../images/orm/relationship_1_N_bi_set_fk_db.gif" border="0" alt=""/>
                <br/>
                <p>
                    If you wish to fully define the schema table and column names etc, follow these tips
                </p>
                <ul>
                    <li>To specify the name of the table where a class is stored, specify the <i>table</i> element below the
                        <b>class</b>element</li>
                    <li>To specify the names of the columns where the fields of a class are stored, specify the 
                        <i>column</i> attribute on the <b>basic</b> element.</li>
                    <li>When forming the relation please make sure that <b>you set the relation at BOTH sides</b> since 
                        DataNucleus would have no way of knowing which end is correct if you only set one end.</li>
                </ul>
                <p>
                    <b>Limitation : </b> Since each Address object can have at most one owner (due to the "Foreign Key") 
                    this mode of persistence will not allow duplicate values in the Collection. If you want to allow 
                    duplicate Collection entries, then use the "Join Table" variant above.
                </p>
                <br/>
            </subsection>
        </section>

        <section name="Collection of non-Entity objects">
            <a name="join_nonpc"/>
            <p>
                All of the examples above show a 1-N relationship between 2 persistable classes. 
                If you want the element to be primitive or Object types then follow this section. For example, when you 
                have a Collection of Strings. This will be persisted in the same way as the "Join Table" 
                examples above. A join table is created to hold the collection elements. 
                Let's take our example. We have an <b>Account</b> that stores a Collection of addresses. 
                These addresses are simply Strings. We define the annotations like this
            </p>
<source><![CDATA[
@Entity
public class Account
{
    ...

    @ElementCollection
    @CollectionTable(name="ACCOUNT_ADDRESSES")
    Collection<String> addresses;
}]]></source>
            <p>or using XML metadata</p>
<source><![CDATA[
    <entity class="mydomain.Account">
        <attributes>
            ...
            <element-collection name="addresses">
                <collection-table name="ACCOUNT_ADDRESSES"/>
            </element-collection>
        </attributes>
    </entity>
]]></source>
            <p>
                In the datastore the following is created
            </p>
            <img src="../../images/orm/relationship_1_N_primitive_collection_db.gif" border="0" alt=""/>
            <p>
                The ACCOUNT table is as before, but this time we only have the "join table".
                Use @Column on the field/method to define the column details of the element in the join table.
            </p>
        </section>

        <section name="Collection of non-persistable objects using AttributeConverter">
            <a name="converter_nonpc"/>
            <p>
                Just like in the above example, here we have a Collection of simple types. In this case we are wanting to store this Collection into
                a single column in the owning table. We do this by using a JPA AttributeConverter.
            </p>
<source><![CDATA[
public class Account
{
    ...

    @ElementCollection
    @Convert(CollectionStringToStringConverter.class)
    @Column(name="ADDRESSES")
    Collection<String> addresses;
}]]></source>
            <p>
                and then define our converter. You can clearly define your conversion process how you want it. You could, for example, convert the
                Collection into comma-separated strings, or could use JSON, or XML, or some other format.
            </p>
<source><![CDATA[

public class CollectionStringToStringConverter implements AttributeConverter<Collection<String>, String>
{
    public String convertToDatabaseColumn(Collection<String> attribute)
    {
        if (attribute == null)
        {
            return null;
        }

        StringBuilder str = new StringBuilder();
        ... convert Collection to String
        return str.toString();
    }

    public Collection<String> convertToEntityAttribute(String columnValue)
    {
        if (columnValue == null)
        {
            return null;
        }

        Collection<String> coll = new HashSet<String>();
        ... convert String to Collection
        return coll;
    }
}]]></source>
        </section>

        <section name="Shared Join Tables">
        <a name="shared_join"/>
            <img src="../../images/nucleus_extension.gif" border="0" alt=""/>
            <p>
                The relationships using join tables shown above rely on the join table relating to the relation in question.
                DataNucleus allows the possibility of sharing a join table between relations. The example below
                demonstrates this. We take the example as <a href="#join_uni">show above</a> (1-N Unidirectional 
                Join table relation), and extend <b>Account</b> to have 2 collections of <b>Address</b> records. One for 
                home addresses and one for work addresses, like this
            </p>
            <img src="../../images/orm/relationship_1_N_uni_join_shared_class.gif" border="0" alt=""/>
            <p>
                We now change the metadata we had earlier to allow for 2 collections, but sharing the join table
            </p>
            <source><![CDATA[
<entity-mappings>
    <entity class="Account">
        <table name="ACCOUNT"/>
        <attributes>
            <id name="id">
                <column name="ACCOUNT_ID"/>
            </id>
            ...
            <one-to-many name="workAddresses" target-entity="com.mydomain.Address">
                <join-table name="ACCOUNT_ADDRESSES">
                    <join-column name="ACCOUNT_ID_OID"/>
                    <inverse-join-column name="ADDRESS_ID_EID"/>
                </join-table>
                <extension key="relation-discriminator-column" value="ADDRESS_TYPE"/>
                <extension key="relation-discriminator-pk" value="true"/>
                <extension key="relation-discriminator-value" value="work"/>
            </one-to-many>
            <one-to-many name="homeAddresses" target-entity="com.mydomain.Address">
                <join-table name="ACCOUNT_ADDRESSES">
                    <join-column name="ACCOUNT_ID_OID"/>
                    <inverse-join-column name="ADDRESS_ID_EID"/>
                </join-table>
                <extension key="relation-discriminator-column" value="ADDRESS_TYPE"/>
                <extension key="relation-discriminator-pk" value="true"/>
                <extension key="relation-discriminator-value" value="home"/>
            </one-to-many>
        </attributes>
    </entity>
    <entity class="Address">
        <table name="ADDRESS"/>
        <attributes>
            <id name="id">
                <column name="ADDRESS_ID"/>
            </id>
            ...
        </attributes>
    </entity>
</entity-mappings>]]></source>
            <p>or with annotations</p>
<source><![CDATA[
public class Account
{
    ...
    @OneToMany
    @JoinTable(name="ACCOUNT_ADDRESSES", 
        joinColumns={@JoinColumn(name="ACCOUNT_ID_OID")},
        inverseJoinColumns={@JoinColumn(name="ADDRESS_ID_EID")})
    @Extensions({@Extension(key="relation-discriminator-column", value="ADDRESS_TYPE"),
             @Extension(key="relation-discriminator-pk", value="true"),
             @Extension(key="relation-discriminator-value", value="work")}
    Collection<Address> workAddresses;

    @OneToMany
    @JoinTable(name="ACCOUNT_ADDRESSES", 
        joinColumns={@JoinColumn(name="ACCOUNT_ID_OID")},
        inverseJoinColumns={@JoinColumn(name="ADDRESS_ID_EID")})
    @Extensions({@Extension(key="relation-discriminator-column", value="ADDRESS_TYPE"),
             @Extension(key="relation-discriminator-pk", value="true"),
             @Extension(key="relation-discriminator-value", value="home")}
    Collection<Address> homeAddresses;
    ...
}]]></source>
            <p>
                So we have defined the same join table for the 2 collections "ACCOUNT_ADDRESSES", and the same columns
                in the join table, meaning that we will be sharing the same join table to represent both relations. The
                important step is then to define the 3 DataNucleus <i>extension</i> tags. These define a column in the join table
                (the same for both relations), and the value that will be populated when a row of that collection is
                inserted into the join table. In our case, all "home" addresses will have a value of "home" inserted into
                this column, and all "work" addresses will have "work" inserted. This means we can now identify easily which
                join table entry represents which relation field.
            </p>
            <p>
                This results in the following database schema
            </p>
            <img src="../../images/orm/relationship_1_N_uni_join_shared_db.gif" border="0" alt=""/>
        </section>

        <section name="Shared Foreign Key">
        <a name="shared_fk"/>
            <img src="../../images/nucleus_extension.gif" border="0" alt=""/>
            <p>
                The relationships using foreign keys shown above rely on the foreign key relating to the relation in question.
                DataNucleus allows the possibility of sharing a foreign key between relations between the same classes. 
                The example below demonstrates this. We take the example as <a href="#fk_uni">show above</a> (1-N Unidirectional 
                Foreign Key relation), and extend <b>Account</b> to have 2 collections of <b>Address</b> records. One for 
                home addresses and one for work addresses, like this
            </p>
            <img src="../../images/orm/relationship_1_N_uni_fk_shared_class.gif" border="0" alt=""/>
            <p>
                We now change the metadata we had earlier to allow for 2 collections, but sharing the join table
            </p>
            <source><![CDATA[
<entity-mappings>
    <entity class="Account">
        <table name="ACCOUNT"/>
        <attributes>
            <id name="id">
                <column name="ACCOUNT_ID"/>
            </id>
            ...
            <one-to-many name="workAddresses" target-entity="com.mydomain.Address">
                <join-column name="ACCOUNT_ID_OID"/>
                <extension key="relation-discriminator-column" value="ADDRESS_TYPE"/>
                <extension key="relation-discriminator-value" value="work"/>
            </one-to-many>
            <one-to-many name="homeAddresses" target-entity="com.mydomain.Address">
                <join-column name="ACCOUNT_ID_OID"/>
                <extension key="relation-discriminator-column" value="ADDRESS_TYPE"/>
                <extension key="relation-discriminator-value" value="home"/>
            </one-to-many>
        </attributes>
    </entity>
    <entity class="Address">
        <table name="ADDRESS"/>
        <attributes>
            <id name="id">
                <column name="ADDRESS_ID"/>
            </id>
            ...
        </attributes>
    </entity>
</entity-mappings>]]></source>
            <p>or with annotations</p>
<source><![CDATA[
public class Account
{
    ...
    @OneToMany
    @Extensions({@Extension(key="relation-discriminator-column", value="ADDRESS_TYPE"),
             @Extension(key="relation-discriminator-value", value="work")}
    Collection<Address> workAddresses;
    @OneToMany
    @Extensions({@Extension(key="relation-discriminator-column", value="ADDRESS_TYPE"),
             @Extension(key="relation-discriminator-value", value="home")}
    Collection<Address> homeAddresses;
    ...
}]]></source>
            <p>
                So we have defined the same foreign key for the 2 collections "ACCOUNT_ID_OID", The
                important step is then to define the 2 DataNucleus <i>extension</i> tags. These define a column in the element table
                (the same for both relations), and the value that will be populated when a row of that collection is
                inserted into the element table. In our case, all "home" addresses will have a value of "home" inserted into
                this column, and all "work" addresses will have "work" inserted. This means we can now identify easily which
                element table entry represents which relation field.
            </p>
            <p>
                This results in the following database schema
            </p>
            <img src="../../images/orm/relationship_1_N_uni_fk_shared_db.gif" border="0" alt=""/>
        </section>
    </body>
</document>