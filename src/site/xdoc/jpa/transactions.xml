<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>JPA Transactions</title>
    </properties>

    <body>
        <section name="JPA : Transactions">
            <p>
                A Transaction forms a unit of work. The Transaction manages what happens within that unit of work, 
                and when an error occurs the Transaction can roll back any changes performed. Transactions can be 
                managed by the users application, or can be managed by a framework (such as Spring), or can be 
                managed by a JEE container. These are described below.
            </p>
            <ul>
                <li><a href="#local">Local transactions</a> : managed using the JPA Transaction API</li>
                <li><a href="#jta">JTA transactions</a> : managed using the JTA UserTransaction API</li>
                <li><a href="#container">Container-managed transactions</a> : managed by a JEE environment</li>
                <li><a href="#spring">Spring-managed transactions</a> : managed by SpringFramework</li>
                <li><a href="#nontransactional">No transactions</a> : "auto-commit" mode</li>
                <li><a href="#flushing">Flushing a Transaction</a></li>
                <li><a href="#isolation">Controlling transaction isolation level</a></li>
                <li><a href="#readonly">Read-Only transactions</a></li>
                <li><a href="#savepoint">RDBMS : Savepoints</a></li>
                <li><a href="#pessimistic">Pessimistic Locking of objects</a></li>
                <li><a href="#optimistic">Optimistic Locking of objects</a></li>
            </ul>
            <br/>

            <a name="local"/>
            <subsection name="Locally-Managed Transactions">
                <p>
                    If using DataNucleus JPA in a J2SE environment the normal type of transaction is <i>RESOURCE_LOCAL</i>.
                    With this type of transaction the user manages the transactions themselves, starting, committing
                    or rolling back the transaction. With these transactions with JPA
                    <a href="http://www.datanucleus.org/javadocs/javax.persistence/2.1/javax/persistence/EntityTransaction.html" target="_blank"><img src="../images/javadoc.gif" alt=""/></a> 
                    you would do something like
                </p>
                <source><![CDATA[
EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();
try
{
    tx.begin();
    
    {users code to persist objects}
    
    tx.commit();
}
finally
{
    if (tx.isActive())
    {
        tx.rollback();
    }
}
em.close();]]></source>
                <p>
                    In this case you will have defined your <a href="emf.html#persistenceunit">persistence-unit</a>
                    to be like this
                </p>
<source><![CDATA[
<persistence-unit name="MyUnit" transaction-type="RESOURCE_LOCAL">
    <properties>
        <property key="javax.persistence.jdbc.url" value="jdbc:mysql:..."/>
        ...
    </properties>
    ...
</persistence-unit>]]></source>
                <p>or</p>
<source><![CDATA[
<persistence-unit name="MyUnit" transaction-type="RESOURCE_LOCAL">
    <non-jta-data-source>java:comp/env/myDS</properties>
    ...
</persistence-unit>]]></source>
                <p>
                    The basic idea with <b>Locally-Managed transactions</b> is that you are 
                    managing the transaction start and end.
                </p>
                <br/>
            </subsection>

            <a name="jta"/>
            <subsection name="JTA Transactions">
                <p>
                    The other type of transaction with JPA is using JTA. With this type, where you have a JTA data source 
                    from which you have a <i>UserTransaction</i>. This <i>UserTransaction</i> can have resources "joined" 
                    to it. In the case of JPA, you have two scenarios. The first scenario is where you have the
                    <i>UserTransaction</i> created before you create your <i>EntityManager</i>. The create of
                    the <i>EntityManager</i> will automatically join it to the current <i>UserTransaction</i>, like this
                </p>
<source><![CDATA[
UserTransaction ut = (UserTransaction)new InitialContext().lookup("java:comp/UserTransaction");
ut.setTransactionTimeout(300);

EntityManager em = emf.createEntityManager();
try
{
    ut.begin();

    .. perform persistence/query operations

    ut.commit();
}
finally
{
    em.close();
}]]></source>
                <p>
                    so we control the transaction using the <i>UserTransaction</i>.
                </p>
                <p>
                    The second scenario is where the <i>UserTransaction</i> is started after you have the <i>EntityManager</i>. 
                    In this case we need to join our <i>EntityManager</i> to the newly created <i>UserTransaction</i>, like this
                </p>
<source><![CDATA[
EntityManager em = emf.createEntityManager();
try
{
    .. perform persistence, query operations

    UserTransaction ut = (UserTransaction)new InitialContext().lookup("java:comp/UserTransaction");
    ut.setTransactionTimeout(300);
    ut.begin();

    // Join the EntityManager operations to this UserTransaction
    em.joinTransaction();

    // Commit the persistence/query operations performed above
    ut.commit();
}
finally
{
    em.close();
}]]></source>
                <p>
                    In the JTA case you will have defined your <a href="emf.html#persistenceunit">persistence-unit</a>
                    to be like this
                </p>
<source><![CDATA[
<persistence-unit name="MyUnit" transaction-type="JTA">
    <jta-data-source>java:comp/env/myDS</properties>
    ...
</persistence-unit>]]></source>
                <br/>
            </subsection>

            <a name="container"/>
            <subsection name="Container-Managed Transactions">
                <p>
                    When using a JEE container you are giving over control of the transactions to the container. 
                    Here you have <b>Container-Managed Transactions</b>. In terms of your code, you would do like 
                    the above examples <b>except</b> that you would OMIT the <i>tx.begin(), tx.commit(), 
                    tx.rollback()</i> since the JEE container will be doing this for you.
            	</p>
                <br/>
            </subsection>

            <a name="spring"/>
            <subsection name="Spring-Managed Transactions">
                <p>
                    When you use a framework like <a href="http://www.springframework.org" target="_blank">Spring</a> 
                    you would not need to specify the <i>tx.begin(), tx.commit(), tx.rollback()</i> since that would 
                    be done for you.
            	</p>
                <br/>
            </subsection>

            <a name="nontransactional"/>
            <subsection name="No Transactions">
                <p>
                    DataNucleus allows the ability to operate without transactions. With JPA this is enabled 
                    by default (see the 2 properties <b>datanucleus.NontransactionalRead</b>,
                    <b>datanucleus.NontransactionalWrite</b> set to <i>true</i>). This means that you can read objects
                    and make updates outside of transactions. This is
                    effectively an "auto-commit" mode.
                </p>
                <source><![CDATA[
EntityManager em = emf.createEntityManager();
    
{users code to persist objects}

em.close();]]></source>
                <p>
                    When using non-transactional operations, you need to pay attention to the persistence property
                    <b>datanucleus.nontx.atomic</b>. If this is true then any persist/delete/update will be committed
                    to the datastore immediately. If this is false then any persist/delete/update will be queued up until
                    the next transaction (or <i>em.close()</i>) and committed with that.
                </p>
                <br/>
            </subsection>

            <a name="flushing"/>
            <subsection name="Flushing">
                <p>
                    During a transaction, depending on the configuration, operations don't necessarily go to the datastore
                    immediately, often waiting until <i>commit</i>. In some situations you need persists/updates/deletes
                    to be in the datastore so that subsequent operations can be performed that rely on those being
                    handled first. In this case you can <b>flush</b> all outstanding changes to the datastore using
                </p>
<source><![CDATA[
em.flush();]]></source>
                <img src="../images/nucleus_extension.gif" alt="" border="0"/>
                <p>
                    A convenient vendor extension is to find which objects are waiting to be flushed at any time, like this
                </p>
<source><![CDATA[
List<ObjectProvider> objs = 
    ((JPAEntityManager)pm).getExecutionContext().getObjectsToBeFlushed();]]></source>
                <br/>
            </subsection>

            <a name="isolation"/>
            <subsection name="Transaction Isolation">
                <img src="../images/nucleus_extension.gif" alt=""/>
                <p>
                    DataNucleus also allows specification of the transaction isolation level. This is specified 
                    via the EntityManagerFactory property <i>datanucleus.transactionIsolation</i>.
                    It accepts the standard JDBC values of
                </p>
                <ul>
                    <li><b>read-uncommitted (1)</b> : dirty reads, non-repeatable reads and phantom reads can occur</li>
                    <li><b>read-committed (2)</b> : dirty reads are prevented; non-repeatable reads and phantom reads can occur</li>
                    <li><b>repeatable-read (4)</b> : dirty reads and non-repeatable reads are prevented; phantom reads can occur</li>
                    <li><b>serializable (8)</b> : dirty reads, non-repeatable reads and phantom reads are prevented</li>
                </ul>
                <p>
                    The default is <u>read-committed</u>. If the datastore doesn't support a particular 
                    isolation level then it will silently be changed to one that is supported. As an alternative you 
                    can also specify it on a per-transaction basis as follows (using the values in parentheses 
                    above).
                </p>
                <source>
org.datanucleus.api.jpa.JPAEntityTransaction tx = 
        (org.datanucleus.api.jpa.JPAEntityTransaction)pm.currentTransaction();
tx.setOption("transaction.isolation", 2);</source>
                <br/>
            </subsection>

            <a name="readonly"/>
            <subsection name="Read-Only Transactions">
                <p>
                    Obviously transactions are intended for committing changes. If you come across a situation where
                    you don't want to commit anything under any circumstances you can mark the transaction
                    as "read-only" by calling
                </p>
                <source><![CDATA[
EntityManager em = emf.createEntityManager();
Transaction tx = em.getTransaction();
try
{
    tx.begin();
    tx.setRollbackOnly();

    {users code to persist objects}
    
    tx.rollback();
}
finally
{
    if (tx.isActive())
    {
        tx.rollback();
    }
}
em.close();]]></source>
                <p>
                    Any call to <i>commit</i> on the transaction will throw an exception forcing the user to
                    roll it back.
                </p>
                <br/>
            </subsection>

            <a name="savepoint"/>
            <subsection name="RDBMS : Savepoints">
                <img src="../images/nucleus_extension.gif" border="0" alt=""/>
                <p>
                    JDBC provides the ability to specify a point in a transaction and rollback to that point if required, assuming the JDBC driver supports it.
                    DataNucleus provides this as a vendor extension, as follows
                </p>
                <source><![CDATA[
import org.datanucleus.api.jpa.JPAEntityTransaction;


EntityManager em = emf.createEntityManager();
JPAEntityTransaction tx = (JPAEntityTransaction)pm.getTransaction();
try
{
    tx.begin();

    {users code to persist objects}
    tx.setSavepoint("Point1");

    {more user code to persist objects}
    tx.rollbackToSavepoint("Point1");

    tx.releaseSavepoint("Point1");
    tx.rollback();
}
finally
{
    if (tx.isActive())
    {
        tx.rollback();
    }
}
em.close();]]></source>
                <br/>
            </subsection>
        </section>

        <section name="JPA : Transaction Locking">
            <p>
                A Transaction forms a unit of work. The Transaction manages what happens within that unit of work, 
                and when an error occurs the Transaction can roll back any changes performed. 
                There are the following locking types for a transaction.
            </p>
            <ul>
                <li>Transactions can lock all records in a datastore and keep them locked until they are ready 
                    to commit their changes. These are known as 
                    <a href="#pessimistic">Pessimistic (or datastore) Locking</a>.</li>
                <li>Transactions can simply assume that things in the datastore will not change until they are 
                    ready to commit, not lock any records and then just before committing make a check for changes. 
                    This is known as <a href="#optimistic">Optimistic Locking</a>.</li>
            </ul>

            <a name="pessimistic"/>
            <subsection name="Pessimistic (Datastore) Locking">
                <img src="../images/nucleus_extension.gif" border="0" alt=""/>
                <p>
                    <b>Pessimistic</b> locking isn't directly supported in JPA but are provided as a vendor extension. 
                    It is suitable for short lived operations where no user interaction is taking place and 
                    so it is possible to block access to datastore entities for the duration of the transaction.
                    You would select pessimistic locking by adding the persistence property
                    <b>datanucleus.Optimistic</b> as <i>false</i>.
                </p>
                <p>
                    By default DataNucleus does not currently lock the objects fetched in pessimistic locking, 
                    but you can configure this behaviour for RDBMS datastores by setting the persistence property 
                    <i>datanucleus.rdbms.useUpdateLock</i> to <u>true</u>. 
                    This will result in all "SELECT ... FROM ..." statements being changed to be 
                    "SELECT ... FROM ... FOR UPDATE". This will be applied only where the underlying RDBMS 
                    supports the "FOR UPDATE" syntax.
                </p>
                <p>
                    With pessimistic locking DataNucleus will grab a datastore connection at the first 
                    operation, and maintain it for the duration of the transaction. 
                    A single connection is used for the transaction (with the exception of any 
                    <a href="value_generation.html">Identity Generation</a> operations which need datastore 
                    access, so these can use their own connection).
                </p>
                <p>
                    In terms of the process of pessimistic (datastore) locking, we demonstrate this below.
                </p>
                <table>
                    <tr>
                        <th>Operation</th>
                        <th>DataNucleus process</th>
                        <th>Datastore process</th>
                    </tr>
                    <tr>
                        <td>Start transaction</td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Persist object</td>
                        <td>Prepare object (1) for persistence</td>
                        <td><b>Open connection.</b><br/>
                            Insert the object (1) into the datastore</td>
                    </tr>
                    <tr>
                        <td>Update object</td>
                        <td>Prepare object (2) for update</td>
                        <td>Update the object (2) into the datastore</td>
                    </tr>
                    <tr>
                        <td>Persist object</td>
                        <td>Prepare object (3) for persistence</td>
                        <td>Insert the object (3) into the datastore</td>
                    </tr>
                    <tr>
                        <td>Update object</td>
                        <td>Prepare object (4) for update</td>
                        <td>Update the object (4) into the datastore</td>
                    </tr>
                    <tr>
                        <td>Flush</td>
                        <td>No outstanding changes so do nothing</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Perform query</td>
                        <td>Generate query in datastore language</td>
                        <td>Query the datastore and return selected objects</td>
                    </tr>
                    <tr>
                        <td>Persist object</td>
                        <td>Prepare object (5) for persistence</td>
                        <td>Insert the object (5) into the datastore</td>
                    </tr>
                    <tr>
                        <td>Update object</td>
                        <td>Prepare object (6) for update</td>
                        <td>Update the object (6) into the datastore</td>
                    </tr>
                    <tr>
                        <td>Commit transaction</td>
                        <td></td>
                        <td><b>Commit connection</b></td>
                    </tr>
                </table>
                <p>
                    So here whenever an operation is performed, DataNucleus pushes it straight to the datastore.
                    Consequently any queries will always reflect the current state of all objects in use.
                    However this mode of operation has no version checking of objects and so if they were updated
                    by external processes in the meantime then they will overwrite those changes.
                </p>
                <p>
                    It should be noted that DataNucleus provides two persistence properties that allow an amount of
                    control over when flushing happens with pessimistic locking
                </p>
                <ul>
                    <li><i>datanucleus.flush.mode</i> when set to MANUAL will try to
                    delay all datastore operations until commit/flush.</li>
                    <li><i>datanucleus.datastoreTransactionFlushLimit</i> represents the number of dirty objects
                    before a flush is performed. This defaults to 1.</li>
                </ul>

                <br/>
            </subsection>

            <a name="optimistic"/>
            <subsection name="Optimistic Locking">
                <p>
                    <b>Optimistic</b> locking is the only official option in JPA. 
                    It is suitable for longer lived operations maybe where user interaction is taking place and 
                    where it would be undesirable to block access to datastore entities for the duration of the 
                    transaction. The assumption is that data altered in this transaction will not be updated by 
                    other transactions during the duration of this transaction, so the changes are not propagated 
                    to the datastore until commit()/flush(). The data is checked just before commit to ensure the 
                    integrity in this respect. The most convenient way of checking data for updates is to maintain 
                    a column on each table that handles optimistic locking data. The user will decide this 
                    when generating their MetaData.
                </p>
                <p>
                    Rather than placing version/timestamp columns on all user datastore tables, JPA allows
                    the user to notate particular classes as requiring <b>optimistic</b> treatment. This is 
                    performed by specifying in MetaData or annotations the details of the field/column to use for 
                    storing the version - see versioning for <a href="orm/versioning.html">JPA</a>. 
                    With JPA you must have a field in your class ready to store the version.
                </p>
                <p>
                    In JPA you can read the version by inspecting the field marked as storing the version value.
                </p>
                <p>
                    In terms of the process of optimistic locking, we demonstrate this below.
                </p>
                <table>
                    <tr>
                        <th>Operation</th>
                        <th>DataNucleus process</th>
                        <th>Datastore process</th>
                    </tr>
                    <tr>
                        <td>Start transaction</td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Persist object</td>
                        <td>Prepare object (1) for persistence</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Update object</td>
                        <td>Prepare object (2) for update</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Persist object</td>
                        <td>Prepare object (3) for persistence</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Update object</td>
                        <td>Prepare object (4) for update</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Flush</td>
                        <td>Flush all outstanding changes to the datastore</td>
                        <td><b>Open connection.</b><br/>
                            Version check of object (1)<br/>
                            Insert the object (1) in the datastore.<br/>
                            Version check of object (2)<br/>
                            Update the object (2) in the datastore.<br/>
                            Version check of object (3)<br/>
                            Insert the object (3) in the datastore.<br/>
                            Version check of object (4)<br/>
                            Update the object (4) in the datastore.</td>
                    </tr>
                    <tr>
                        <td>Perform query</td>
                        <td>Generate query in datastore language</td>
                        <td>Query the datastore and return selected objects</td>
                    </tr>
                    <tr>
                        <td>Persist object</td>
                        <td>Prepare object (5) for persistence</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Update object</td>
                        <td>Prepare object (6) for update</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Commit transaction</td>
                        <td>Flush all outstanding changes to the datastore</td>
                        <td>Version check of object (5)<br/>
                            Insert the object (5) in the datastore<br/>
                            Version check of object (6)<br/>
                            Update the object (6) in the datastore.<br/>
                            <b>Commit connection.</b></td>
                    </tr>
                </table>
                <p>
                    Here no changes make it to the datastore until the user either commits the transaction, or
                    they invoke flush(). The impact of this is that when performing a query, by default, the results
                    may not contain the modified objects unless they are flushed to the datastore before invoking the
                    query. Depending on whether you need the modified objects to be reflected in the results of the
                    query governs what you do about that. If you invoke flush() just before running the query
                    the query results will include the changes. The obvious benefit of optimistic locking is that
                    all changes are made in a block and version checking of objects is performed before application 
                    of changes, hence this mode copes better with external processes updating the objects.
                </p>
                <p>
                    Please note that for some datastores (e.g RDBMS) the version check followed by update/delete is 
                    performed in a single statement.
                </p>

                <p>See also :-</p>
                <ul>
                    <li><a href="metadata_xml.html#version">JPA MetaData reference for &lt;version&gt; element</a></li>
                    <li><a href="annotations.html#Version">JPA Annotations reference for @Version</a></li>
                </ul>
                <br/>
            </subsection>
        </section>
    </body>
</document>
