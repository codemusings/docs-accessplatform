<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>JPA Queries</title>
    </properties>

    <body>
        <section name="JPA : Query API">
            <p>
                Once you have persisted objects you need to query them. For example if you have a web application 
                representing an online store, the user asks to see all products of a particular type, ordered by 
                the price. This requires you to query the datastore for these products. JPA specifies support for 
                <a href="jpql.html">a pseudo-OO query language (JPQL)</a>, 
                <a href="native_query.html">"native" query language for the datastore</a> (for RDBMS this is SQL, for Cassandra it is CQL), and
                <a href="stored_procedures.html">(RDBMS) Stored Procedures</a> (JPA2.1+).
            </p>
            <p>
                Which query language is used is down to the developer. The data-tier of an application could be 
                written by a primarily Java developer, who would typically think in an object-oriented way and so 
                would likely prefer <b>JPQL</b>. On the other hand the data-tier could be written by a datastore 
                developer who is more familiar with SQL concepts and so could easily make more use of <b>SQL</b>.
                This is the power of an implementation like DataNucleus in that it provides the flexibility for 
                different people to develop the data-tier utilising their own skills to the full without having 
                to learn totally new concepts.
            </p>
            <p>
                There are 2 categories of queries with JPA :-
            </p>
            <ul>
                <li><b>Programmatic Query</b> where the query is defined using the JPA Query API.</li>
                <li><b>Named Query</b> where the query is defined in MetaData and referred 
                    to by its name at runtime(for <a href="jpql.html#named">JPQL</a>, <a href="native_query.html#named">Native Query</a>
                    and <a href="stored_procedures.html#named">Stored Procedures</a>).</li>
            </ul>

            <p>
                Let's now try to understand the Query API in JPA
                <a href="http://docs.oracle.com/javaee/7/api/javax/persistence/Query.html" target="_blank"><img src="../images/javadoc.gif" alt=""/></a>,
                We firstly need to look at a typical Query. We'll take 2 examples
            </p>

            <subsection name="JPQL Query">
                <p>
                    Let's create a JPQL query to highlight its usage
                </p>
                <source>
Query q = em.createQuery("SELECT p FROM Product p WHERE p.param2 &lt; :threshold ORDER BY p.param1 ascending");
q.setParameter("threshold", my_threshold);
List results = q.getResultList();</source>
                <p>
                    In this Query, we implicitly select JPQL by using the method <i>EntityManager.createQuery()</i>, and the query is specified 
                    to return all objects of type <i>Product</i> (or subclasses) which have the field <i>param2</i> less than some threshold 
                    value ordering the results by the value of field <i>param1</i>. We've specified the query like this because we want to pass 
                    the threshold value in as a parameter (so maybe running it once with one value, and once with a different value).
                    We then set the parameter value of our <i>threshold</i> parameter. The Query is then executed to return a List of results. 
                    The example is to highlight the typical methods specified for a (JPQL) Query.
                </p>
            </subsection>

            <subsection name="SQL Query">
                <p>
                    Let's create an SQL query to highlight its usage
                </p>
                <source>
Query q = em.createNativeQuery("SELECT * FROM Product p WHERE p.param2 &lt; ?1");
q.setParameter(1, my_threshold);
List results = q.getResultList();</source>
                <p>
                    So we implicitly select SQL by using the method <i>EntityManager.createNativeQuery()</i>, and the query is specified
                    like in the JPQL case to return all instances of type <i>Product</i> (using the table name in this SQL query) where the column
                    <i>param2</i> is less than some threshold value.
                </p>
                <br/>
            </subsection>

            <a name="Range"/>
            <subsection name="setFirstResult(), setMaxResults()">
                <p>
                    In JPA to specify the range of a query you have two methods available.
                    So you could do
                </p>
                <source><![CDATA[
Query q = em.createQuery("SELECT p FROM Product p WHERE p.param2 < :threshold ORDER BY p.param1 ascending");
q.setFirstResult(1);
q.setMaxResults(3);]]></source>
                <p>
                    so we will get results 1, 2, and 3 returned only. The first result starts at 0 by default.
                </p>
                <br/>
            </subsection>

            <a name="Extensions"/>
            <subsection name="setHint()">
                <p>
                    JPA's query API allows implementations to support extensions ("hints") and provides a simple 
                    interface for enabling the use of such extensions on queries.
                </p>
                <source>q.setHint("extension_name", value);</source>
                <p>
                    JPA supports some standard hints, namely
                    <b>javax.persistence.fetchgraph</b>, <b>javax.persistence.loadgraph</b>, <b>javax.persistence.query.timeout</b>, <b>javax.persistence.lock.timeout</b>.
                    DataNucleus provides various vendor-specific hints for different types of queries (see different parts of this documentation).
                </p>
                <br/>
            </subsection>

            <a name="Parameters"/>
            <subsection name="setParameter()">
                <p>
                    JPA's query API supports named and numbered parameters and provides method for setting
                    the value of particular parameters. To set a named parameter, for example, you could do
                </p>
                <source><![CDATA[
Query q = em.createQuery("SELECT p FROM Product p WHERE p.param2 < :threshold ORDER BY p.param1 ascending");
q.setParameter("threshold", value);]]></source>
                <p>
                    To set a numbered parameter you could do
                </p>
                <source><![CDATA[
Query q = em.createQuery("SELECT p FROM Product p WHERE p.param2 < ?1 ORDER BY p.param1 ascending");
q.setParameter(1, value);]]></source>
                <p>
                    Numbered parameters are numbered from 1.
                </p>
                <br/>
            </subsection>

            <a name="ExecuteList"/>
            <subsection name="getResultList()">
                <p>
                    To execute a JPA query you would typically call <i>getResultList</i>. This will return
                    a List of results. This should not be called when the query is an "UPDATE"/"DELETE".
                </p>
                <source><![CDATA[
Query q = em.createQuery("SELECT p FROM Product p WHERE p.param2 < :threshold ORDER BY p.param1 ascending");
q.setParameter("threshold", value);
List results = q.getResultList();]]></source>
                <br/>
            </subsection>

            <a name="ExecuteSingle"/>
            <subsection name="getSingleResult()">
                <p>
                    To execute a JPA query where you are expecting a single value to be returned you would 
                    call <i>getSingleResult</i>. This will return the single Object. If the query returns more than
                    one result then you will get an Exception.
                    This should not be called when the query is an "UPDATE"/"DELETE".
                </p>
                <source><![CDATA[
Query q = em.createQuery("SELECT p FROM Product p WHERE p.param2 = :value");
q.setParameter("value", val1);
Product prod = q.getSingleResult();]]></source>
                <br/>
            </subsection>

            <a name="ExecuteUpdate"/>
            <subsection name="executeUpdate()">
                <p>
                    To execute a JPA UPDATE/DELETE query you would call <i>executeUpdate</i>. 
                    This will return the number of objects changed by the call.
                    This should not be called when the query is a "SELECT".
                </p>
                <source><![CDATA[
Query q = em.createQuery("DELETE FROM Product p");
int number = q.executeUpdate();]]></source>
                <br/>
            </subsection>

            <a name="flushmode"/>
            <subsection name="setFlushMode()">
                <p>
                    By default, when a query is executed it will be evaluated against the contents of
                    the datastore at the point of execution. If there are any outstanding changes waiting to be
                    flushed then these will not feature in the results. To make sure all outstanding changes
                    are respected
                </p>
                <source><![CDATA[
q.setFlushMode(FlushModeType.AUTO);]]></source>
                <br/>
            </subsection>

            <a name="lockmode"/>
            <subsection name="setLockMode()">
                <p>
                    JPA allows control over whether objects found by a fetch (JPQL query) are locked during that
                    transaction so that other transactions can't update them in the meantime. For example
                </p>
                <source><![CDATA[
q.setLockMode(LockModeType.PESSIMISTIC_READ);]]></source>
                <p>
                    You can also specify this for all queries for all EntityManagers using a persistence property 
                    <b>datanucleus.rdbms.useUpdateLock</b>.
                </p>
                <br/>
            </subsection>

            <a name="loadResultsAtCommit"/>
            <subsection name="Large Result Sets : Loading Results at Commit()">
                <img src="../images/nucleus_extension.gif" border="0" alt=""/>
                <p>
                    When a transaction is committed by default all remaining results for a query are loaded so that the query is usable thereafter. 
                    With a large result set you clearly don't want this to happen. So in this case you should set the query hint <b>datanucleus.query.loadResultsAtCommit</b> to <i>false</i>.
                </p>
                <p>
                    To do this on a per query basis for JPA you would do
                </p>
                <source>
query.setHint("datanucleus.query.loadResultsAtCommit", "false");</source>
                <br/>
            </subsection>

            <a name="resultCacheType"/>
            <subsection name="Result Set : Caching of Results">
                <img src="../images/nucleus_extension.gif" border="0" alt=""/>
                <p>
                    When you execute a query, the query results are typically loaded when the user accesses each row. Results that have been read can then be cached locally.
                    You can control this caching to optimise it for your memory requirements. 
                    You can set the query hint <b>datanucleus.query.resultCacheType</b> and it has the following possible values
                </p>
                <ul>
                    <li><i>weak</i> : use a weak reference map for caching (default)</li>
                    <li><i>soft</i> : use a soft reference map for caching</li>
                    <li><i>hard</i> : use a Map for caching (objects not garbage collected)</li>
                    <li><i>none</i> : no caching (hence uses least memory)</li>
                </ul>
                <p>
                    To do this on a per query basis, you would do
                </p>
<source>query.setHint("datanucleus.query.resultCacheType", "weak");</source>
                <br/>
            </subsection>

            <a name="resultSizeMethod"/>
            <subsection name="Large Result Sets : Size">
                <img src="../images/nucleus_extension.gif" border="0" alt=""/>
                <p>
                    If you have a large result set you clearly don't want to instantiate all objects since this would hit the memory footprint of your application. 
                    To get the number of results many JDBC drivers, for example, will load all rows of the result set. This is to be avoided so DataNucleus 
                    provides control over the mechanism for getting the size of results.
                    The persistence property <b>datanucleus.query.resultSizeMethod</b> has a default of <i>last</i> (which means navigate to the last object, 
                    hence hitting the JDBC driver problem). On RDBMS, if you set this to <i>count</i> then it will use a simple "count()" query to get the size.
                </p>
                <p>
                    To do this on a per query basis you would do
                </p>
<source>query.setHint("datanucleus.query.resultSizeMethod", "count");</source>
                <br/>
            </subsection>

            <a name="resultSetType"/>
            <subsection name="RDBMS : Result Set Type">
                <img src="../images/nucleus_extension.gif" border="0" alt=""/>
                <p>
                    For RDBMS datastores, <i>java.sql.ResultSet</i> defines three possible result set types.
                </p>
                <ul>
                    <li><i>forward-only</i> : the result set is navegable forwards only</li>
                    <li><i>scroll-sensitive</i> : the result set is scrollable in both directions and is sensitive to changes in the datastore</li>
                    <li><i>scroll-insensitive</i> : the result set is scrollable in both directions and is insensitive to changes in the datastore</li>
                </ul>
                <p>
                    DataNucleus allows specification of this type as a query extension <b>datanucleus.rdbms.query.resultSetType</b>.
                </p>
                <p>
                    To do this on a per query basis you would do
                </p>
<source>query.setHint("datanucleus.rdbms.query.resultSetType", "scroll-insensitive");</source>
                <p>
                    The default is <i>forward-only</i>. The benefit of the other two is that the result set will be scrollable and hence objects will only be read 
                    in to memory when accessed. So if you have a large result set you should set this to one of the scrollable values.
                </p>
                <br/>
            </subsection>

            <a name="resultSetControl"/>
            <subsection name="RDBMS : Result Set Control">
                <img src="../images/nucleus_extension.gif" border="0" alt=""/>
                <p>
                    DataNucleus RDBMS provides a useful extension allowing control over the ResultSet's that are created by queries. 
                    You have at your convenience some properties that give you the power to control whether the result set is read only, 
                    whether it can be read forward only, the direction of fetching etc. 
                </p>
                <p>
                    To do this on a per query basis you would do
                </p>
                <source>
query.setHint("datanucleus.rdbms.query.fetchDirection", "forward");
query.setHint("datanucleus.rdbms.query.resultSetConcurrency", "read-only");</source>
                <p>
                    Alternatively you can specify these as persistence properties so that they apply to all queries for that PMF/EMF. Again, the properties are
                </p>
                <ul>
                    <li><b>datanucleus.rdbms.query.fetchDirection</b> - controls the direction that the ResultSet is navigated. 
                        By default this is forwards only. Use this property to change that.</li>
                    <li><b>datanucleus.rdbms.query.resultSetConcurrency</b> - controls whether the ResultSet is read only or updateable.</li>
                </ul>
                <p>
                    Bear in mind that not all RDBMS support all of the possible values for these options. That
                    said, they do add a degree of control that is often useful.
                </p>
                <br/>
            </subsection>

        </section>
    </body>
</document>