<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>Enhancer</title>
    </properties>

    <body>
        <section name="DataNucleus Enhancer">
            <p>
                As is described in the <a href="#enhancement">Class Enhancement guide below</a>, 
                DataNucleus utilises the common technique of byte-code manipulation to make your normal Java classes 
                "persistable". The mechanism provided by DataNucleus is to use an "enhancer" process to perform this 
                manipulation before you use your classes at runtime. The process is very quick and easy.
            </p>
            <p>
                How to use the DataNucleus Enhancer depends on what environment you are using. Below are some typical examples. 
            </p>
            <ul>
                <li>Post-compilation
                <ul>
                    <li><a href="#maven">Using Maven via the DataNucleus Maven plugin</a></li>
                    <li><a href="#ant">Using Ant</a></li>
                    <li><a href="#manual">Manual invocation at the command line</a></li>
                    <li><a href="guides/eclipse/index.html">Using the Eclipse DataNucleus plugin</a></li>
                </ul></li>
                <li>At runtime
                <ul>
                    <li><a href="#runtime">Runtime Enhancement</a></li>
                    <li><a href="#api">Programmatically via an API</a></li>
                </ul></li>
            </ul>

			<a name="maven"/>
            <subsection name="Maven">
                <p>
                    Maven operates from a series of plugins. There is a DataNucleus plugin for Maven that 
                    allows enhancement of classes. Go to the Download section of the website and download this.
                    Once you have the Maven plugin, you then need to set any properties for the plugin in 
                    your <i>pom.xml</i> file. 
                    Some properties that you may need to change are below
                </p>
                <table>
                    <tr>
                        <th>Property</th>
                        <th>Default</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>persistenceUnitName</td>
                        <td></td>
                        <td>Name of the persistence-unit to enhance. <b>Mandatory</b></td>
                    </tr>
                    <tr>
                        <td>log4jConfiguration</td>
                        <td></td>
                        <td>Config file location for Log4J (if using it)</td>
                    </tr>
                    <tr>
                        <td>jdkLogConfiguration</td>
                        <td></td>
                        <td>Config file location for JDK1.4 logging (if using it)</td>
                    </tr>
                    <tr>
                        <td>api</td>
                        <td>JDO</td>
                        <td>API to enhance to (JDO, JPA). <b>Mandatory : Set this to JPA</b></td>
                    </tr>
                    <tr>
                        <td>verbose</td>
                        <td>false</td>
                        <td>Verbose output?</td>
                    </tr>
                    <tr>
                        <td>quiet</td>
                        <td>false</td>
                        <td>No output?</td>
                    </tr>
                    <tr>
                        <td>targetDirectory</td>
                        <td></td>
                        <td>Where the enhanced classes are written (default is to overwrite them)</td>
                    </tr>
                    <tr>
                        <td>fork</td>
                        <td>true</td>
                        <td>Whether to fork the enhancer process (e.g if you get a command line too long with Windows).</td>
                    </tr>
                    <tr>
                        <td>generatePK</td>
                        <td>true</td>
                        <td>Generate a PK class (of name {MyClass}_PK) for cases where there are multiple
                            PK fields yet no PK class is defined.</td>
                    </tr>
                    <tr>
                        <td>generateConstructor</td>
                        <td>true</td>
                        <td>Generate a default constructor if not defined for the class being enhanced.</td>
                    </tr>
                    <tr>
                        <td>detachListener</td>
                        <td>false</td>
                        <td>Whether to enhance classes to make use of a detach listener for attempts to access
                            an undetached field.</td>
                    </tr>
                </table>
                <p>
                    You will need to add <i>(org.datanucleus) datanucleus-api-jpa</i> into the CLASSPATH (of the plugin, 
                    or your project) for the enhancer to operate. Similarly <i>persistence-api</i> (but then you almost
                    certainly will have that in your project CLASSPATH anyway).
                </p>
                <p>
                    You then run the Maven DataNucleus plugin, as follows
                </p>
                <source>mvn datanucleus:enhance</source>
                <p>
                    This will enhance all classes for the specified persistence-unit. If you want to check the 
                    current status of enhancement you can also type
                </p>
                <source>mvn datanucleus:enhance-check</source>
                <p>
                    Or alternatively, you could add the following to your POM 
                </p>
                <source><![CDATA[
    <build>
        ...
        <plugins>
            <plugin>
                <groupId>org.datanucleus</groupId>
                <artifactId>datanucleus-maven-plugin</artifactId>
                <version>4.0.0-m2</version>
                <configuration>
                    <api>JPA</api>
                    <persistenceUnitName>MyUnit</persistenceUnitName>
                    <log4jConfiguration>${basedir}/log4j.properties</log4jConfiguration>
                    <verbose>true</verbose>
                </configuration>
                <executions>
                    <execution>
                        <phase>process-classes</phase>
                        <goals>
                            <goal>enhance</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
        ...
    </build>]]></source>
                <p>
                    So you then get auto-enhancement after each compile. 
                    Please refer to the <a href="maven.html">Maven JPA guide</a> for more details.
                </p>
                <br/>
            </subsection>

            <a name="ant"/>
            <subsection name="Ant">
                <p>
                    Ant provides a powerful framework for performing tasks. DataNucleus provides an Ant task to 
                    enhance classes. DataNucleus provides an Enhancer in <i>datanucleus-core.jar</i>.
                    You need to make sure that the <i>datanucleus-core.jar</i>, 
                    <i>datanucleus-api-jpa.jar</i>, <i>log4j.jar</i> (optional),
                    and <i>persistence-api.jar</i> are in your CLASSPATH.
                    In the DataNucleus Enhancer Ant task, the following parameters are available
                </p>
                <table>
                    <tr>
                        <th>Parameter</th>
                        <th>Description</th>
                        <th>values</th>
                    </tr>
                    <tr>
                        <td>destination</td>
                        <td>Optional. Defining a directory where enhanced classes will be written. 
                            If omitted, the original classes are updated.</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>api</td>
                        <td>Defines the API to be used when enhancing</td>
                        <td>Set this to <b>JPA</b></td>
                    </tr>
                    <tr>
                        <td>persistenceUnit</td>
                        <td>Defines the "persistence-unit" to enhance.</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>checkonly</td>
                        <td>Whether to just check the classes for enhancement status. Will respond for each class with 
                            "ENHANCED" or "NOT ENHANCED". <b>This will disable the enhancement process and just perform these 
                            checks.</b></td>
                        <td>true, <b>false</b></td>
                    </tr>
                    <tr>
                        <td>verbose</td>
                        <td>Whether to have verbose output.</td>
                        <td>true, <b>false</b></td>
                    </tr>
                    <tr>
                        <td>quiet</td>
                        <td>Whether to have no output.</td>
                        <td>true, <b>false</b></td>
                    </tr>
                    <tr>
                        <td>generatePK</td>
                        <td>Whether to generate PK classes as required.</td>
                        <td><b>true</b>, false</td>
                    </tr>
                    <tr>
                        <td>generateConstructor</td>
                        <td>Whether to generate a default constructor as required.</td>
                        <td><b>true</b>, false</td>
                    </tr>
                    <tr>
                        <td>if</td>
                        <td>Optional. The name of a property that must be set in order to the Enhancer Ant Task to execute.</td>
                        <td></td>
                    </tr>                   
                </table>
                <p>
                    The enhancer task extends the Apache Ant <a href="http://ant.apache.org/manual/CoreTasks/java.html">Java task</a>, 
                    thus all parameters available to the Java task are also available to the enhancer task.
                </p>
                <p>
                    So you could define something <i>like</i> the following, setting up the parameter <b>enhancer.classpath</b>,
                    and <b>log4j.config.file</b> to suit your situation.
                </p>
                <source><![CDATA[
<target name="enhance" description="DataNucleus enhancement">
    <taskdef name="datanucleusenhancer" classpathref="enhancer.classpath" 
                classname="org.datanucleus.enhancer.EnhancerTask" />

    <datanucleusenhancer
        persistenceUnit="MyUnit" failonerror="true" verbose="true">
        <jvmarg line="-Dlog4j.configuration=${log4j.config.file}"/>
        <classpath>
            <path refid="enhancer.classpath"/>
        </classpath>
    </datanucleusenhancer>
</target>]]></source>
            </subsection>

			<a name="manual"/>
            <subsection name="Manually">
                <p>
                    DataNucleus provides an Enhancer in <i>datanucleus-core.jar</i>. If you are 
                    building your application manually and want to enhance your classes you follow the 
                    instructions in this section. You invoke the enhancer as follows
                </p>
                <source>
java -cp classpath  org.datanucleus.enhancer.DataNucleusEnhancer [options] 
    where options can be
        -pu {persistence-unit-name} : Name of a "persistence-unit" to enhance the classes for
        -d {target-dir-name} : Write the enhanced classes to the specified directory
        -api {api-name} : Name of the API we are enhancing for (JDO, JPA). Set this to JPA
        -checkonly : Just check the classes for enhancement status
        -v : verbose output
        -q : quiet mode (no output, overrides verbose flag too)
        -generatePK {flag} : generate any PK classes where needed 
                             ({flag} should be true or false - default=true)
        -generateConstructor {flag} : generate default constructor where needed 
                             ({flag} should be true or false - default=true)

    where "mapping-files" and "class-files" are provided when not enhancing a persistence-unit, 
        and give the paths to the mapping files and class-files that define the classes being enhanced.

    where classpath must contain the following
        datanucleus-core.jar
        datanucleus-api-jpa.jar
        persistence-api.jar
        log4j.jar (optional)
        your classes
        your meta-data files</source>
                <p>
                    The input to the enhancer should be the name of the "persistence-unit" to enhance.
                    To give an example of how you would invoke the enhancer
                </p>
                <source>
Linux/Unix :
java -cp target/classes:lib/datanucleus-core.jar:lib/datanucleus-api-jpa.jar:lib/persistence-api.jar:lib/log4j.jar
     -Dlog4j.configuration=file:log4j.properties
     org.datanucleus.enhancer.DataNucleusEnhancer
     -api JPA -pu MyUnit

Windows :
java -cp target\classes;lib\datanucleus-core.jar;lib\datanucleus-api-jpa.jar;lib\persistence-api.jar;lib\log4j.jar
     -Dlog4j.configuration=file:log4j.properties
     org.datanucleus.enhancer.DataNucleusEnhancer 
     -api JPA -pu MyUnit

[should all be on same line. Shown like this for clarity]</source>
                <p>
                    So you pass in the persistence-unit name as the final argument(s) in the list, 
                    and include the respective JAR's in the classpath (-cp). The enhancer responds as follows
                </p>
                <source>
DataNucleus Enhancer (version 4.0.0.m2) for API "JPA"

DataNucleus Enhancer : Classpath
>>  /home/andy/work/myproject//target/classes
>>  /home/andy/work/myproject/lib/log4j.jar
>>  /home/andy/work/myproject/lib/persistence-api.jar
>>  /home/andy/work/myproject/lib/datanucleus-core.jar
>>  /home/andy/work/myproject/lib/datanucleus-api-jpa.jar

ENHANCED (persistable): org.mydomain.mypackage1.Pack
ENHANCED (persistable): org.mydomain.mypackage1.Card
DataNucleus Enhancer completed with success for 2 classes. Timings : input=422 ms, enhance=490 ms, total=912 ms.
     ... Consult the log for full details</source>
                <p>
                    If you have errors here relating to "Log4J" then you must fix these first. If you receive no output about 
                    which class was ENHANCED then you should look in the DataNucleus enhancer log for errors. The enhancer performs
                    much error checking on the validity of the passed MetaData and the majority of errors are caught at this
                    point. You can also use the DataNucleus Enhancer to check whether classes are enhanced. To invoke the enhancer 
                    in this mode you specify the <b>checkonly</b> flag. This will return a list of the classes, stating 
                    whether each class is enhanced for persistence under JDO or not. The classes need to be in the CLASSPATH 
                    <i>(Please note that a CLASSPATH should contain a set of JAR's, and a set of directories. It should NOT 
                        explictly include class files, and should NOT include parts of the package names. If in doubt please 
                        consult a Java book).</i>
                </p>
                <br/>
            </subsection>

			<a name="runtime"/>
            <subsection name="Runtime Enhancement">
                <p>
                    Enhancement of persistent classes at runtime is possible when using JRE 1.5 or superior 
                    versions. Runtime Enhancement requires the <i>datanucleus-core</i> jar be in the CLASSPATH
                    but then you'd have that if using DataNucleus.
                </p>
                <p>
                    When operating in a JavaEE environment (JBoss, WebSphere, etc) instead set the persistence 
                    property <a href="emf.html">datanucleus.jpa.addClassTransformer</a> to <i>true</i>.
                    Note that this is only for a real JavaEE server that implements the JavaEE parts of the JPA spec.
                </p>
                <p>
                    To enable runtime enhancement in other environments, the <i>javaagent</i> option must be set 
                    in the java command line. For example,
                </p>
                <source>java -javaagent:datanucleus-core.jar=-api=JPA Main</source>
                <p>
                    The statement above will mean that all classes, when being loaded, will be processed by the
                    ClassFileTransformer (except class in packages "java.*", "javax.*", "org.datanucleus.*").
                    This means that it can be slow since the MetaData search algorithm will be utilised for each.
                    To speed this up you can specify an argument to that command specifying the names of package(s)
                    that should be processed (and all others will be ignored). Like this
                </p>
                <source>java -javaagent:datanucleus-core.jar=-api=JPA,mydomain.mypackage1,mydomain.mypackage2 Main</source>
                <p>
                    so in this case only classes being loaded that are in <i>mydomain.mypackage1</i>
                    and <i>mydomain.mypackage2</i> will be attempted to be enhanced.
                </p>
                <p>
                    Please take care over the following when using runtime enhancement
                </p>
                <ul>
                    <li>When you have a class with a field of another persistable type
                        make sure that you mark that field as "persistent" (@Persistent, or in XML)
                        since with runtime enhancement at that point the related class is likely
                        not yet enhanced so will likely not be marked as persistent otherwise.
                        <b>Be explicit</b></li>
                    <li>
                        If the agent jar is not found make sure it is specified with an absolute path.
                    </li>
                </ul>
                <br/>
            </subsection>

            <a name="api"/>
            <subsection name="Programmatic API">
                <p>
                    You could alternatively programmatively enhance classes from within your application.
                    This is done as follows.
                </p>
                <source>
import org.datanucleus.enhancer.DataNucleusEnhancer;

DataNucleusEnhancer enhancer = new DataNucleusEnhancer("JPA", null);
enhancer.setVerbose(true);
enhancer.addPersistenceUnit("MyPersistenceUnit");
enhancer.enhance();</source>
                <p>
                    This will look in META-INF/persistence.xml and enhance all classes defined by that unit.
                    <b>Please note that you will need to load the enhanced version of the class into a
                    different ClassLoader after performing this operation to use them</b>.
                    See <a href="http://www.datanucleus.org/servlet/wiki/pages/viewpage.action?pageId=6619188">this guide</a>
                </p>
                <br/>
            </subsection>
        </section>

        <section name="Class enhancement">
			<a name="enhancement"/>
            <p>
                DataNucleus requires that all classes that are persisted implement 
                <a href="http://www.datanucleus.org/javadocs/core/4.0/org/datanucleus/enhancer/Persistable.html">Persistable</a>. 
                <b>Why should we do this, Hibernate/TopLink dont need it ?</b>. Well that's a simple question really
            </p>
            <ul>
                <li>DataNucleus uses this <i>Persistable</i> interface, and adds it using bytecode enhancement 
                    techniques so that you never need to actually change your classes. This means that you get
                    <b>transparent persistence</b>, and your classes always remain <i>your</i> classes.
                    ORM tools that use a mix of reflection and/or proxies are not totally transparent.</li>
                <li>DataNucleus' use of <i>Persistable</i> provides transparent change tracking. When any 
                    change is made to an object the change creates a notification to DataNucleus allowing it to be 
                    optimally persisted. ORM tools that dont have access to such change tracking have to use reflection
                    to detect changes. The performance of this process will break down as soon as you read a large 
                    number of objects, but modify just a handful, with these tools having to compare all object 
                    states for modification at transaction commit time.</li>
            </ul>
            <p>
                Why not also read <a href="http://blog.bolkey.com/2009/05/hibernate-datanucleus-r1/">this comparison</a>
                of bytecode enhancement, and proxies. It gives a clear enough comparison of the relative benefits.
            </p>
            <p>
                In the DataNucleus bytecode enhancement contract there are 3 categories of classes. 
                These are <i>Entity</i>, <i>PersistenceAware</i> and normal classes. 
                The Meta-Data defines which classes fit into these categories. To give an example, we have 3 classes. 
                The class <i>A</i> is to be persisted in the datastore. The class <i>B</i> directly updates the fields 
                of class <i>A</i> but doesn't need persisting. The class <i>C</i> is not involved in the persistence 
                process. We would define these classes as follows
            </p>
            <source><![CDATA[
@Entity
public class A
{
    String myField;
    ...
}

@org.datanucleus.api.jpa.annotations.PersistenceAware
public class B
{
    ...
}]]></source>
            <p>
                So our MetaData is mainly for those classes that are <i>Entity</i> (or MappedSuperclass/Embeddable) and are to be persisted 
                to the datastore. For <i>PersistenceAware</i> classes we simply notate that the class knows about 
                persistence. We don't define MetaData for any class that has no knowledge of persistence.
            </p>
            <p>
                JPA allows implementations to bytecode enhance persistable classes to implement some interface to provide
                them with change tracking etc.
                Users could manually make their classes implement this <i>Persistable</i> interface but this would impose work on them. 
                JPA permits the use of a byte-code enhancer that converts the users normal classes to implement this interface. 
                DataNucleus provides its own byte-code enhancer (in the <i>datanucleus-core.jar</i>). This section 
                describes how to use this enhancer with DataNucleus. 
            </p>
            <img src="../images/enhancer_persistable.gif" alt=""/><br/>
            <p>
                The example above doesn't show all <i>Persistable</i> methods, but demonstrates that all added 
                methods and fields are prefixed with "dn" to distinguish them from the users own methods and fields. 
                Also each persistent field of the class will be given a dnGetXXX, dnSetXXX method so that accesses 
                of these fields are intercepted so that DataNucleus can manage their "dirty" state.
            </p>
            <p>
                The MetaData defines which classes are required to be persisted, and also defines which aspects of 
                persistence each class requires. With JPA all classes are additionally detachable meaning they can be detached
                so the  class will be enhanced to also implement <i>Detachable</i>
                <a href="http://www.datanucleus.org/javadocs/core/4.0/org/datanucleus/enhancer/Detachable.html" target="_blank">
                <img src="../images/javadoc.gif" alt=""/></a>
            </p>
            <img src="../images/enhancer_detachable.gif" alt=""/><br/>
            <p>
                The main thing to know is that the detached state (object id of the datastore object, the version of the 
                datastore object when it was detached, and which fields were detached is stored in "dnDetachedState") is stored
                in the object when it is detached, and available to be merged later on.
            </p>
            <p>
                <b>If the MetaData is changed in any way during development, the classes should always be recompiled and re-enhanced afterwards.</b>
            </p>

            <subsection name="Byte-Code Enhancement Myths">
                <p>
                    Some groups (e.g Hibernate) perpetuated arguments against "byte-code enhancement" saying that 
                    it was somehow 'evil'. The most common were :-
                </p>
                <ul>
                    <li><i>Slows down the code-test cycle</i>. This is erroneous since you only need to enhance just 
                        before test and the provided plugins for Ant, Eclipse and Maven all do the enhancement job 
                        automatically and rapidly.</li>
                    <li><i>Is less "lazy" than the proxy approach since you have to load the object as soon as you get
                        a pointer to it</i>. In a 1-1 relation you <b>have to load</b> the object then since you would 
                        cause issues with null pointers otherwise. With 1-N relations you load the elements of the 
                        collection/map only when you access them and not the collection/map. Hardly an issue then is 
                        it!</li>
                    <li><i>Fail to detect changes to public fields unless you enhance your client code</i>. Firstly 
                        very few people will be writing code with public fields since it is bad practice in an OO 
                        design, and secondly, this is why we have "PersistenceAware" classes.</li>
                </ul>
                <p>
                    So as you can see, there are no valid reasons against byte-code enhancement, and the pluses are 
                    that runtime detection of dirty events on objects is much quicker, hence your persistence layer 
                    operates faster without any need for iterative reflection-based checks.
                    The fact is that Hibernate itself also now has a mode whereby you can do bytecode enhancement
                    although not the default mode of Hibernate. So maybe it wasn't so evil after all ?
                </p>
                <br/>
            </subsection>

            <subsection name="Decompilation">
                <p>
                    Many people will wonder what actually happens to a class upon bytecode enhancement. In
                    simple terms the necessary methods and fields are added so as to implement <i>Persistable</i>. 
                    If you want to check this, just use a Java decompiler such as <a href="http://jd.benow.ca/" target="_blank">JD</a>. 
                    It has a nice GUI allowing you to just select your class to decompile and shows you the source.
                </p>
            </subsection>
        </section>
    </body>
</document>
