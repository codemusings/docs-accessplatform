<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>JPA Entity Graphs</title>
    </properties>

    <body>
        <section name="JPA : Entity Graphs">
            <p>
                When an object is retrieved from the datastore by JPA typically not all fields are retrieved 
                immediately. This is because for efficiency purposes only particular field types are retrieved in the 
                initial access of the object, and then any other objects are retrieved when accessed (lazy loading).
                The group of fields that are loaded is called an <b>entity graph</b>.
                There are 3 types of "entity graphs" to consider
            </p>
            <ul>
                <li><a href="#default">"Default Entity Graph"</a> : implicitly defined in all JPA specs, 
                    specifying the <i>fetch</i> setting for each field/property (LAZY/EAGER).</li>
                <li><a href="#named">Named Entity Graphs</a> : a new feature in JPA 2.1 allowing the user to 
                    define <i>Named Entity Graphs</i> in metadata, via annotations or XML</li>
                <li><a href="#unnamed">Unnamed Entity Graphs</a> : a new feature in JPA 2.1 allowing the user to 
                    define Entity Graphs via the JPA API at runtime</li>
            </ul>
            <br/>

            <a name="default"/>
            <subsection name="Default Entity Graph">
                <p>
                    JPA provides an initial entity graph, comprising the fields that will be retrieved when an object 
                    is retrieved if the user does nothing to define the required behaviour. You define this "default"
                    by setting the <i>fetch</i> attribute in metadata for each field/property.
                </p>
                <br/>
            </subsection>

            <a name="named"/>
            <subsection name="Named Entity Graphs">
                <p>
                    You can predefine <b>Named Entity Graphs</b> in metadata which can then be used at runtime
                    when retrieving objects from the datastore (via find/query).
                    For example, if we have the following class
                </p>
                <source>
class MyClass
{
    String name;
    HashSet coll;
    MyOtherClass other;
}</source>
                <p>
                    and we want to have the option of the <i>other</i> field loaded whenever we load objects of this 
                    class, we define our annotations as
                </p>
                <source><![CDATA[
@Entity
@NamedEntityGraph(name="includeOther", attributeNodes={@NamedAttributeNode("other")})
public class MyClass
{
    ...
}]]></source>
                <p>
                    So we have defined an EntityGraph called "includeOther" that just includes the field with name 
                    <i>other</i>. We can retrieve this and then use it in our persistence code, as follows
                </p>
                <source><![CDATA[
EntityGraph includeOtherGraph = em.getEntityGraph("includeOther");

Properties props = new Properties();
props.put("javax.persistence.loadgraph", includeOtherGraph);
MyClass myObj = em.find(MyClass.class, id, props);]]></source>
                <p>
                    Here we have made use of the <i>EntityManager.find</i> method and provided the property
                    <b>javax.persistence.loadgraph</b> to be our EntityGraph. This means that it will fetch
                    all fields in the <i>default</i> EntityGraph, <b>plus</b> all fields in the <i>includeOther</i>
                    EntityGraph. If we had provided the property <b>javax.persistence.fetchgraph</b> set to our
                    EntityGraph it would have fetched just the fields defined in that EntityGraph.
                </p>
                <p>
                    Note that you can also make use of EntityGraphs when using the JPA Query API, specifying
                    the same properties above but as query <i>hints</i>.
                </p>
                <br/>
            </subsection>

            <a name="unnamed"/>
            <subsection name="Unnamed Entity Graphs">
                <p>
                    You can define <b>Entity Graphs</b> at runtime, programmatically.
                    For example, if we have the following class
                </p>
                <source>
class MyClass
{
    String name;
    HashSet coll;
    MyOtherClass other;
}</source>
                <p>
                    and we want to have the option of the <i>other</i> field loaded whenever we load objects of this 
                    class, we do the following
                </p>
                <source><![CDATA[
EntityGraph includeOtherGraph = em.createEntityGraph(MyClass.class);
includeOtherGraph.addAttributeNodes("other");
]]></source>
                <p>
                    So we have defined an EntityGraph that just includes the field with name <i>other</i>. 
                    We can then use this at runtime in our persistence code, as follows                
                </p>
                <source><![CDATA[
Properties props = new Properties();
props.put("javax.persistence.loadgraph", includeOtherGraph);
MyClass myObj = em.find(MyClass.class, id, props);]]></source>
                <p>
                    Here we have made use of the <i>EntityManager.find</i> method and provided the property
                    <b>javax.persistence.loadgraph</b> to be our EntityGraph. This means that it will fetch
                    all fields in the <i>default</i> EntityGraph, <b>plus</b> all fields in this EntityGraph. 
                    If we had provided the property <b>javax.persistence.fetchgraph</b> set to our
                    EntityGraph it would have fetched just the fields defined in that EntityGraph.
                </p>
                <p>
                    Note that you can also make use of EntityGraphs when using the JPA Query API, specifying
                    the same properties above but as query <i>hints</i>.
                </p>
                <br/>
            </subsection>
        </section>
    </body>
</document>