<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>JPA Identity</title>
    </properties>

    <body>
        <section name="JPA Identity">
            <p>
                All JPA-enabled persistable classes need to have an "identity" to be able to identify an object for retrieval and relationships. 
                In strict JPA there is only 1 type of identity - <i>application identity</i>, where you have a field or field(s) of the entity that are used to define the identity.
                With DataNucleus JPA we allow 2 additional types of identity. So your options are
            </p>
            <ul>
                <li><a href="#application">Application Identity</a> : a field, or several fields of the persistable type are assigned as being (part of) the primary key.</li>
                <li><a href="#datastore">Datastore Identity</a> : a surrogate column is added to the persistence of the persistable type, and objects of this type are identified by
                    the class plus the value in this surrogate column. <b>DataNucleus Extension</b></li>
                <li><a href="#nondurable">Nondurable Identity</a> : the persistable type has no identity as such, so the only way to lookup objects of this type would be
                    via query for values of specific fields. This is useful for storing things like log messages etc. <b>DataNucleus Extension</b></li>
            </ul>
            <p>
                A further complication is where you use <i>application identity</i> but one of the fields forming the primary key is a relation field. This is known
                as <a href="#derived">Derived Identity</a>.
            </p>
        </section>

        <section name="Application Identity">
            <a name="application"/>
            <p>
                With <b>application identity</b> you are taking control of the specification of id's to DataNucleus. 
                Application identity requires a primary key class <i>(unless using SingleFieldIdentity, where one is 
                provided for you)</i>, and each persistent capable class may define a different class for its primary 
                key, and different persistent capable classes can use the same primary key class, as appropriate. With
                <b>application identity</b> the field(s) of the primary key will be present as field(s) of the class 
                itself. To specify that a class is to use <b>application identity</b>, you add the following to the MetaData for the class.
            </p>
            <source><![CDATA[
<entity class="org.mydomain.MyClass">
    <id-class class="org.mydomain.MyIdClass"/>
    <attributes>
        <id name="myPrimaryKeyField"/>
    </attributes>
</entity>]]></source>
            <p>
                For JPA we specify the <b>id</b> field and <b>id-class</b>.
                Alternatively, if we are using annotations
            </p>
            <source><![CDATA[
@Entity
@IdClass(class=MyIdClass.class)
public class MyClass
{
    @Id
    private long myPrimaryKeyField;
}]]></source>
            <table class="infoTable">
                <tr>
                    <td><img src="../images/lightbulb.png" border="0"/></td>
                    <td>
                        <b>When you have an inheritance hierarchy, you should specify the identity type in the 
                        <u>base instantiable</u> class for the inheritance tree. This is then used for all persistent 
                        classes in the tree.</b> This means that you can have MappedSuperclass without any identity
                        fields/properties as superclass, and then the base instantiable class is the first persistable
                        class which has the identity field(s).
                    </td>
                </tr>
            </table>
            <p>See also :-</p>
                <ul>
                    <li><a href="metadata_xml.html#id">MetaData reference for &lt;id&gt; element</a></li>
                    <li><a href="annotations.html#Id">Annotations reference for @Id</a></li>
                </ul>
            <br/>

            <subsection name="Application Identity : Generating identities">
                <p>
                    By choosing <b>application identity</b> you are controlling the process of identity generation 
                    for this class. This does not mean that you have a lot of work to do for this. JPA1 defines many 
                    ways of generating these identities and DataNucleus supports all of these and provides some 
                    more of its own besides.
                </p>
                <p>See also :-</p>
                <ul>
                    <li><a href="value_generation.html">Identity Generation Guide</a> - strategies for generating ids</li>
                </ul>
                <br/>
            </subsection>

            <subsection name="Application Identity : Changing Identities">
                <p>
                    JPA doesn't define what happens if you change the identity (an identity field) of an object
                    once persistent. <b>DataNucleus doesn't currently support changes to identities.</b>
                </p>
                <br/>
            </subsection>

            <subsection name="Application Identity : Accessing objects by Identity">
                <p>
                    You access an object from its object class name and identity "value" as follows
                </p>
                <source>Object obj = em.find(MyClass.class, mykey);</source>
                <p>
                    If you have defined your own "IdClass" then the <i>mykey</i> is the toString() form of the identity of your PK class.
                </p>
                <br/>
            </subsection>

            <a name="application_primarykey"/>
            <subsection name="Primary Key">
                <p>
                    When you choose application identity you are defining which fields of the class are part of the primary key,
                    and you are taking control of the specification of id's to DataNucleus. Application identity requires a primary key (PK) class, 
                    and each persistent capable class may define a different class for its primary key, and different persistent capable classes can 
                    use the same primary key class, as appropriate. 
                    If you have only a single primary-key field then there are builtin PK classes so you can forget this section. Where you have more than 1 primary key field, 
                    you would define the PK class like this
                </p>
<source><![CDATA[
<entity class="MyClass">
    <id-class class="MyIdClass"/>
    ...
</entity>]]></source>
            <p>or using annotations</p>
            <source><![CDATA[
@Entity
@IdClass(class=MyIdClass.class)
public class MyClass
{
    ...
}]]></source>
                <p>
                    You now need to define the PK class to use. This is simplified for you because <b>if you have only 
                    one PK field then you dont need to define a PK class</b> and you only define it when you have a composite PK.
                </p>
                <p>
                    An important thing to note is that the PK can only be made up of fields of the following Java types
                </p>
                <ul>
                    <li>Primitives : <b>boolean</b>, <b>byte</b>, <b>char</b>, <b>int</b>, <b>long</b>, <b>short</b></li>
                    <li>java.lang : <b>Boolean</b>, <b>Byte</b>, <b>Character</b>, <b>Integer</b>, <b>Long</b>, <b>Short</b>, <b>String</b>, <b>Enum</b>, StringBuffer</li>
                    <li>java.math : <b>BigInteger</b></li>
                    <li>java.sql : <b>Date</b>, <b>Time</b>, <b>Timestamp</b></li>
                    <li>java.util : <b>Date</b>, Currency, Locale, TimeZone, UUID</li>
                    <li>java.net : URI, URL</li>
                    <li><i>persistable</i></li>
                </ul>
                <p>
                    Note that the types in <b>bold</b> are JPA standard types. Any others are DataNucleus extensions and,
                    as always, <a href="../datastores/index.html">check the specific datastore docs</a> to see what is supported for your datastore.
                </p>

                <p><u><b>Single PrimaryKey field</b></u></p>
                <p>
                    The simplest way of using <b>application identity</b> is where you have a single PK field, and in 
                    this case you use an inbuilt primary key class that DataNucleus provides, so you don't need to 
                    specify the <i>objectid-class</i>. Let's take an example</p>
<source><![CDATA[
public class MyClass
{
    long id;
    ...
}

<entity class="MyClass">
    <attributes>
        <id name="id"/>
        ...
    </attributes>
</entity>]]></source>
                <p>or using annotations</p>
<source><![CDATA[
@Entity
public class MyClass
{
    @Id
    long id;
    ...
}]]></source>
                <p>
                    So we didnt specify the JPA "id-class". You will, of course, have to give 
                    the field a value before persisting the object, either by setting it yourself, or by using a 
                    <a href="value_generation.html">value-strategy</a> on that field.
                </p>
                <br/>
            </subsection>

            <subsection name="PrimaryKey : Rules for User-Defined classes">
                <p>
                    If you wish to use <b>application identity</b> and don't want to use the "SingleFieldIdentity" 
                    builtin PK classes then you must define a Primary Key class of your own. You can't use classes 
                    like java.lang.String, or java.lang.Long directly. You must follow these rules when defining your primary key class.
                </p>
                <ul>
                    <li>the Primary Key class must be public</li>
                    <li>the Primary Key class must implement Serializable</li>
                    <li>the Primary Key class must have a public no-arg constructor, which might be the default 
                        constructor</li>
                    <li>The PrimaryKey class can have a constructor taking the primary key fields,
                        or can use Java bean setters/getters</li>
                    <li>the field types of all non-static fields in the Primary Key class must be serializable, 
                        and are recommended to be primitive, String, Date, or Number types</li>
                    <li>all serializable non-static fields in the Primary Key class can be public, but
                        package/protected/private should also be fine</li>
                    <li>the names of the non-static fields in the Primary Key class must include the names of the 
                        primary key fields in the Entity, and the types of the common fields must be identical</li>
                    <li>the equals() and hashCode() methods of the Primary Key class must use the value(s) of all 
                        the fields corresponding to the primary key fields in the JDO class</li>
                    <li>if the Primary Key class is an inner class, it must be static</li>
                    <li>the Primary Key class must override the toString() method defined in Object, and return a 
                        String that can be used as the parameter of a constructor</li>
                    <li>the Primary Key class must provide a String constructor that returns an instance that 
                        compares equal to an instance that returned that String by the toString() method.</li>
                    <li>the Primary Key class must be only used within a single inheritance tree.</li>
                </ul>
                <p>
                    Please note that if one of the fields that comprises the primary key is in itself
                    an entity then you have <a href="orm/derived_identity.html">Derived Identity</a>
                    and should consult the documentation for that feature which contains its own example.
                </p>
                <img src="../images/nucleus_extension.gif" alt=""/>
                <table class="infoTable"><tr>
                    <td><img src="../images/lightbulb.png" border="0"/></td>
                    <td>Since there are many possible combinations of primary-key fields it is impossible for JDO to provide a series of builtin composite primary key classes. 
                        However the <a href="enhancer.html">DataNucleus enhancer</a> provides a mechanism for auto-generating a primary-key class for a persistable class. 
                        It follows the rules listed below and should work for all cases. Obviously if you want to tailor the output of things like the PK toString() method 
                        then you ought to define your own. The enhancer generation of primary-key class is only enabled if you don't define your own class.</td>
                </tr></table>
                <br/>
            </subsection>

            <subsection name="PrimaryKey Example - Multiple Field">
                <p>
                    Here's an example of a composite (multiple field) primary key class
                </p>
                <source><![CDATA[
@Entity
@IdClass(ComposedIdKey.class)
public class MyClass
{
    @Id
    String field1;

    @Id
    String field2;
    ...
}

public class ComposedIdKey implements Serializable
{
    public String field1;
    public String field2;

    /**
     *  Default constructor.
     */
    public ComposedIdKey ()
    {
    }

    /**
     * Constructor accepting same input as generated by toString().
     */
    public ComposedIdKey(String value) 
    {
        StringTokenizer token = new StringTokenizer (value, "::");
        //field1
        this.field1 = token.nextToken ();
        //field2
        this.field2 = token.nextToken ();
    }

    public boolean equals(Object obj)
    {
        if (obj == this)
        {
            return true;
        }
        if (!(obj instanceof ComposedIdKey))
        {
            return false;
        }
        ComposedIdKey c = (ComposedIdKey)obj;

        return field1.equals(c.field1) && field2.equals(c.field2);
    }

    public int hashCode ()
    {
        return this.field1.hashCode() ^ this.field2.hashCode();
    }

    public String toString ()
    {
        // Give output expected by String constructor
        return "" + this.field1 + "::" + this.field2;
    }
}]]></source>
            </subsection>
        </section>

        <section name="Datastore Identity">
            <a name="datastore"/>
            <img src="../images/nucleus_extension.gif" border="0" alt=""/>
            <p>
                While JPA defines support for <a href="#application">application identity</a> only DataNucleus also provides support for <b>datastore identity</b>. 
                With <b>datastore identity</b> you are leaving the assignment of id's to DataNucleus and your class will <b>not</b> have a field 
                for this identity - it will be added to the datastore representation by DataNucleus. 
                It is, to all extents and purposes a <i>surrogate key</i> that will have its own column in the 
                datastore. To specify that a class is to use <b>datastore identity</b> with JPA, you define the metadata as follows
            </p>
<source><![CDATA[
<entity class="org.mydomain.MyClass">
    <datastore-id/>
    ...
</entity>]]></source>
                <p>
                    or using annotations, for example
                </p>
<source><![CDATA[
@Entity
@org.datanucleus.api.jpa.annotations.DatastoreIdentity
public class MyClass
{
    ...
}]]></source>
            <p>
                <i>Please note that since the JPA XML metadata is poorly designed it is not possible to specify datastore identity using XML, you have to use the annotations.</i>
            </p>
            <table class="infoTable"><tr>
                <td><img src="../images/lightbulb.png" border="0"/></td>
                <td>
                    <b>When you have an inheritance hierarchy, you should specify the identity type in the 
                    <u>base</u> class for the inheritance tree. This is then used for all persistent classes in the tree.</b>
                </td>
            </tr></table>
            <br/>

            <subsection name="Datastore Identity : Generating identities">
                <p>
                    By choosing <b>datastore identity</b> you are handing the process of identity generation to the 
                    DataNucleus. This does not mean that you haven't got any control over how it does this. 
                    JPA defines many ways of generating these identities and DataNucleus supports all of these and 
                    provides some more of its own besides.
                </p>
                <p>
                    Defining which one to use is a simple matter of adding a MetaData element to your classes 
                    definition, like this
                </p>
<source><![CDATA[
@Entity
@org.datanucleus.api.jpa.annotations.DatastoreIdentity(generationType=GenerationType.TABLE)
public class MyClass
{
    ...
}]]></source>
                <p>See also :-</p>
                <ul>
                    <li><a href="value_generation.html">Identity Generation Guide</a> - strategies for generating ids</li>
                    <li><a href="annotations.html#DatastoreIdentity">Annotations reference for @DatastoreIdentity</a></li>
                </ul>
                <br/>
            </subsection>

            <subsection name="Datastore Identity : Accessing the Identity">
                <p>
                    When using <b>datastore identity</b>, the class has no associated field so you can't just 
                    access a field of the class to see its identity - if you need a field to be able to access the 
                    identity then you should be using<a href="application_identity.html">application identity</a>. 
                    There are, however, ways to get the identity for the datastore identity case, if you have the
                    object.
                </p>
<source>
import org.datanucleus.api.jpa.NucleusJPAHelper;

Object idKey = NucleusJPAHelper.getDatastoreIdForEntity(obj);
</source>
                <p>
                    From this you can use the "find" method to retrieve the object
                </p>
                <source>Object obj = em.find(MyClass.class, idKey);</source>
                <br/>
            </subsection>
        </section>

        <section name="Nondurable Identity">
            <a name="nondurable"/>
            <img src="../images/nucleus_extension.gif" border="0" alt=""/>
            <p>
                JPA requires that all objects have an identity. DataNucleus provides a vendor extension that allows objects of a class to not have a unique identity in the datastore. 
                This type of identity is typically for log files, history files etc where you aren't going to access the object by key, but instead by a different parameter. 
                In the datastore the table will typically not have a primary key. 
                To specify that a class is to use <b>nondurable identity</b> with DataNucleus you would add the following to the MetaData for the class.
            </p>
<source><![CDATA[
<entity class="org.mydomain.MyClass">
    <nondurable-id/>
    ...
</entity>]]></source>
                <p>
                    or using annotations, for example
                </p>
<source>
@Entity
@org.datanucleus.api.jpa.annotations.NonDurableId
public class MyClass
{
    ...
}</source>
            <p>
                DataNucleus provides support for "nondurable" identity for some datastores only currently (RDBMS, Excel, ODF, MongoDB, HBase, Cassandra, Neo4j). 
                What this means for something like RDBMS is that the table of the class will not have a primary-key.
            </p>
        </section>

        <section name="Derived Identity Relationships">
            <a name="derived"/>
            <p>
                An derived identity relationship is a relationship between two objects of two classes in which the child object must coexist with the 
                parent object and where the primary key of the child includes the Entity object of the parent. So effectively the key aspect of this
                type of relationship is that the primary key of one of the classes includes a Entity field (hence why is is referred to as <i>Derived Identity</i>).
                This type of relation is available in the following forms
            </p>
            <ul>
                <li><a href="#derived_1_1_uni">1-1 unidirectional</a></li>
                <li><a href="#derived_1_N_coll_bi">1-N collection bidirectional using ForeignKey</a></li>
                <li><a href="#derived_1_N_map_bi">1-N map bidirectional using ForeignKey (key stored in value)</a></li>
            </ul>
            <table class="infoTable"><tr>
                <td><img src="../images/lightbulb.png" border="0"/></td>
                <td>Note that in pure JPA, if the entity that is part of the id of the derived entity has a single long field then you can put a <i>long</i>
                    field in the identity class of the derived entity. In DataNucleus you cannot do this currently, and should define the `@IdClass` of the 
                    entity being contained and use that type in the identity class of the derived entity.</td>
            </tr></table>
            <table class="infoTable"><tr>
                <td><img src="../images/lightbulb.png" border="0"/></td>
                <td>The persistable class that is contained cannot be using <i>datastore identity</i>, and must be using <i>application identity</i> with an objectid-class</td>
            </tr></table>
            <br/>

            <a name="derived_1_1_uni"/>
            <subsection name="1-1 Relationship">
                <p>
                    Lets take the same classes as we have in the <a href="one_to_one.html">1-1 Relationships</a>.
                    In the 1-1 relationships guide we note that in the datastore representation of the <b>User</b> and 
                    <b>Account</b> the <b>ACCOUNT</b> table has a primary key as well as a foreign-key to <b>USER</b>. 
                    In our example here we want to just have a primary key that is also a foreign-key to <b>USER</b>. 
                    To do this we need to modify the classes slightly and add primary-key fields and use 
                    "application-identity".
                </p>
                <br/>
                <img src="../images/orm/relationship_1_1_compound_class.jpg" border="0" alt=""/>
                <br/>
                <p>
                    In addition we need to define primary key classes for our <b>User</b> and <b>Account</b> classes
                </p>
                <source><![CDATA[
@Entity
public class User
{
    @Id
    long id;

    ... (remainder of User class)

    /**
     * Inner class representing Primary Key
     */
    public static class PK implements Serializable
    {
        public long id;

        public PK()
        {
        }

        public PK(String s)
        {
            this.id = Long.valueOf(s).longValue();
        }

        public String toString()
        {
            return "" + id;
        }

        public int hashCode()
        {
            return (int)id;
        }

        public boolean equals(Object other)
        {
            if (other != null && (other instanceof PK))
            {
                PK otherPK = (PK)other;
                return otherPK.id == this.id;
            }
            return false;
        }
    }
}

@Entity
public class Account
{
    @Id
    @OneToOne
    User user;

    ... (remainder of Account class)

    /**
     * Inner class representing Primary Key
     */
    public static class PK implements Serializable
    {
        public User.PK user; // Use same name as the real field above

        public PK()
        {
        }

        public PK(String s)
        {
            StringTokenizer token = new StringTokenizer(s,"::");

            this.user = new User.PK(token.nextToken());
        }

        public String toString()
        {
            return "" + this.user.toString();
        }

        public int hashCode()
        {
            return user.hashCode();
        }

        public boolean equals(Object other)
        {
            if (other != null && (other instanceof PK))
            {
                PK otherPK = (PK)other;
                return this.user.equals(otherPK.user);
            }
            return false;
        }
    }
}]]></source>
                <p>
                    To achieve what we want with the datastore schema we define the MetaData like this
                </p>
                <source><![CDATA[
<entity-mappings>
    <entity class="mydomain.User">
        <table name="USER"/>
        <id-class class="mydomain.User.PK"/>
        <attributes>
            <id name="id">
                <column name="USER_ID"/>
            </id>
            <basic name="login">
                <column name="LOGIN" length="20"/>
            </basic>
        </attributes>
    </entity>

    <entity class="mydomain.Account">
        <table name="ACCOUNT"/>
        <id-class class="mydomain.Account.PK"/>
        <attributes>
            <id name="user">
                <column name="USER_ID"/>
            </id>
            <basic name="firstName">
                <column name="FIRSTNAME" length="50"/>
            </basic>
            <basic name="secondName">
                <column name="LASTNAME" length="50"/>
            </basic>
            <one-to-one name="user"/>
        </attributes>
    </entity>
</entity-mappings>]]></source>
                <p>
                    So now we have the following datastore schema
                </p>
                <br/>
                <img src="../images/orm/relationship_1_1_compound_db.jpg" border="0" alt=""/>
                <br/>
                <p>
                    Things to note :-
                </p>
                <ul>
                    <li>In the child Primary Key class, you must have a field with the same name as the relationship in the 
                        child class, and the field in the child Primary Key class must be the same type as the Primary Key class of the parent</li>
                    <li>See also the <a href="#application_primarykey">general instructions for Primary Key classes</a></li>
                    <li>You can only have one "Account" object linked to a particular "User" object since the FK to the "User" is now the primary key of "Account". 
                        To remove this restriction you could also add a "long id" to  "Account" and make the "Account.PK" a composite primary-key</li>
                </ul>
                <br/>
            </subsection>

            <a name="derived_1_N_coll_bi"/>
            <subsection name="1-N Collection Relationship">
                <p>
                    Lets take the same classes as we have in the <a href="orm/one_to_many_collection.html#fk_bi">1-N Relationships (FK)</a>. 
                    In the 1-N relationships guide we note that in the datastore representation of the <b>Account</b> and <b>Address</b> classes the 
                    <b>ADDRESS</b> table has a primary key as well as a foreign-key to <b>ACCOUNT</b>. 
                    In our example here we want to have the primary-key to <b>ACCOUNT</b> to <i>include</i> the foreign-key. 
                    To do this we need to modify the classes slightly, adding primary-key fields to both classes, and use "application-identity" for both.
                </p>
                <br/>
                <img src="../images/orm/relationship_1_N_compound_class.jpg" border="0" alt=""/>
                <br/>
                <p>
                    In addition we need to define primary key classes for our <b>Account</b> and <b>Address</b> classes
                </p>
                <source><![CDATA[
@Entity
public class Account
{
    @Id
    long id;

    @OneToMany
    Set<Address> addresses = new HashSet<>();

    ... (remainder of Account class)

    /**
     * Inner class representing Primary Key
     */
    public static class PK implements Serializable
    {
        public long id;

        public PK()
        {
        }

        public PK(String s)
        {
            this.id = Long.valueOf(s).longValue();
        }

        public String toString()
        {
            return "" + id;
        }

        public int hashCode()
        {
            return (int)id;
        }

        public boolean equals(Object other)
        {
            if (other != null && (other instanceof PK))
            {
                PK otherPK = (PK)other;
                return otherPK.id == this.id;
            }
            return false;
        }
    }
}

@Entity
public class Address
{
    @Id
    long id;

    @Id
    @ManyToOne
    Account account;

    .. (remainder of Address class)

    /**
     * Inner class representing Primary Key
     */
    public static class PK implements Serializable
    {
        public long id; // Same name as real field above
        public Account.PK account; // Same name as the real field above

        public PK()
        {
        }

        public PK(String s)
        {
            StringTokenizer token = new StringTokenizer(s,"::");
            this.id = Long.valueOf(token.nextToken()).longValue();
            this.account = new Account.PK(token.nextToken());
        }

        public String toString()
        {
            return "" + id + "::" + this.account.toString();
        }

        public int hashCode()
        {
            return (int)id ^ account.hashCode();
        }

        public boolean equals(Object other)
        {
            if (other != null && (other instanceof PK))
            {
                PK otherPK = (PK)other;
                return otherPK.id == this.id && this.account.equals(otherPK.account);
            }
            return false;
        }
    }
}]]></source>
                <p>
                    To achieve what we want with the datastore schema we define the MetaData like this
                </p>
                <source><![CDATA[
<entity-mappings>
    <entity class="mydomain.Account">
        <table name="ACCOUNT"/>
        <id-class class="mydomain.Account.PK"/>
        <attributes>
            <id name="id">
                <column name="ACCOUNT_ID"/>
            </id>
            <basic name="firstName">
                <column name="FIRSTNAME" length="50"/>
            </basic>
            <basic name="secondName">
                <column name="LASTNAME" length="50"/>
            </basic>
            <one-to-many name="addresses" mapped-by="account"/>
        </attributes>
    </entity>

    <entity class="mydomain.Address">
        <table name="ADDRESS"/>
        <id-class class="mydomain.Address.PK"/>
        <attributes>
            <id name="id">
                <column name="ID"/>
            </id>
            <id name="account">
                <column name="ACCOUNT_ID"/>
            </id>
            <basic name="city">
                <column name="CITY"/>
            </basic>
            <basic name="street">
                <column name="STREET"/>
            </basic>
            <many-to-one name="account"/>
        </attributes>
    </entity>
</entity-mappings>]]></source>
                <p>
                    So now we have the following datastore schema
                </p>
                <br/>
                <img src="../images/orm/relationship_1_N_compound_db.jpg" border="0" alt=""/>
                <br/>
                <p>
                    Things to note :-
                </p>
                <ul>
                    <li>In the child Primary Key class, you must have a field with the same name as the relationship in the 
                        child class, and the field in the child Primary Key class must be the same type as the Primary Key
                        class of the parent</li>
                    <li>See also the <a href="#application_primarykey">general instructions for Primary Key classes</a></li>
                    <li>If we had omitted the "id" field from "Address" it would have only been possible to have one "Address"
                        in the "Account" "addresses" collection due to PK constraints. For that reason we have the "id" field 
                        too.</li>
                </ul>
                <br/>
            </subsection>
            
            <a name="derived_1_N_map_bi"/>
            <subsection name="1-N Map Relationship">
                <p>
                    Lets take the same classes as we have in the <a href="orm/one_to_many_map.html#fk_bi_key">1-N Relationships 
                    (FK)</a>. In this guide we note that in the datastore representation of the <b>Account</b> and 
                    <b>Address</b> classes the <b>ADDRESS</b> table has a primary key as well as a foreign-key to 
                    <b>ACCOUNT</b>. In our example here we want to have the primary-key to <b>ACCOUNT</b> to 
                    <i>include</i> the foreign-key. To do this we need to modify the classes slightly, adding primary-key 
                    fields to both classes, and use "application-identity" for both.
                </p>
                <br/>
                <img src="../images/orm/relationship_1_N_bi_map_fk_simple_pc_class.jpg" border="0" alt=""/>
                <br/>
                <p>
                    In addition we need to define primary key classes for our <b>Account</b> and <b>Address</b> classes
                </p>
                <source><![CDATA[
@Entity
public class Account
{
    @Id
    long id;

    @OneToMany
    Set<Address> addresses = new HashSet<>();

    ... (remainder of Account class)

    /**
     * Inner class representing Primary Key
     */
    public static class PK implements Serializable
    {
        public long id;

        public PK()
        {
        }

        public PK(String s)
        {
            this.id = Long.valueOf(s).longValue();
        }

        public String toString()
        {
            return "" + id;
        }

        public int hashCode()
        {
            return (int)id;
        }

        public boolean equals(Object other)
        {
            if (other != null && (other instanceof PK))
            {
                PK otherPK = (PK)other;
                return otherPK.id == this.id;
            }
            return false;
        }
    }
}

@Entity
public class Address
{
    @Id
    String alias;

    @Id
    @ManyToOne
    Account account;

    .. (remainder of Address class)

    /**
     * Inner class representing Primary Key
     */
    public static class PK implements Serializable
    {
        public String alias; // Same name as real field above
        public Account.PK account; // Same name as the real field above

        public PK()
        {
        }

        public PK(String s)
        {
            StringTokenizer token = new StringTokenizer(s,"::");
            this.alias = Long.valueOf(token.nextToken()).longValue();
            this.account = new Account.PK(token.nextToken());
        }

        public String toString()
        {
            return alias + "::" + this.account.toString();
        }

        public int hashCode()
        {
            return alias.hashCode() ^ account.hashCode();
        }

        public boolean equals(Object other)
        {
            if (other != null && (other instanceof PK))
            {
                PK otherPK = (PK)other;
                return otherPK.alias.equals(this.alias) && this.account.equals(otherPK.account);
            }
            return false;
        }
    }
}]]></source>
                <p>
                    To achieve what we want with the datastore schema we define the MetaData like this
                </p>
                <source><![CDATA[
<entity-mappings>
    <entity class="mydomain.Account">
        <table name="ACCOUNT"/>
        <id-class class="mydomain.Account.PK"/>
        <attributes>
            <id name="id">
                <column name="ACCOUNT_ID"/>
            </id>
            <basic name="firstName">
                <column name="FIRSTNAME" length="50"/>
            </basic>
            <basic name="secondName">
                <column name="LASTNAME" length="50"/>
            </basic>
            <one-to-many name="addresses" mapped-by="account">
                <map-key name="alias"/>
            </one-to-many>
        </attributes>
    </entity>

    <entity class="mydomain.Address">
        <table name="ADDRESS"/>
        <id-class class="mydomain.Address.PK"/>
        <attributes>
            <id name="account">
                <column name="ACCOUNT_ID"/>
            </id>
            <id name="alias">
                <column name="KEY"/>
            </id>
            <basic name="city">
                <column name="CITY"/>
            </basic>
            <basic name="street">
                <column name="STREET"/>
            </basic>
            <many-to-one name="account"/>
        </attributes>
    </entity>
</entity-mappings>]]></source>
                <p>
                    So now we have the following datastore schema
                </p>
                <br/>
                <img src="../images/orm/relationship_1_N_compound_map_db.jpg" border="0" alt=""/>
                <br/>
                <p>
                    Things to note :-
                </p>
                <ul>
                    <li>In the child Primary Key class, you must have a field with the same name as the relationship in the 
                        child class, and the field in the child Primary Key class must be the same type as the Primary Key class of the parent</li>
                    <li>See also the <a href="#application_primarykey">general instructions for Primary Key classes</a></li>
                    <li>If we had omitted the "alias" field from "Address" it would have only been possible to have one 
                        "Address" in the "Account" "addresses" collection due to PK constraints. For that reason we have the "alias" field too as part of the PK.</li>
                </ul>
                <br/>
            </subsection>
        </section>
    </body>
</document>
