<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>Entity Manager</title>
    </properties>

    <body>
        <section name="JPA : Entity Manager">
            <p>
                As you read in the guide for <a href="emf.html">EntityManagerFactory</a>, to control the persistence of your objects
                you will require at least one <i>EntityManagerFactory</i>. Once you have obtained this object you then use
                this to obtain an <i>EntityManager</i>. An <i>EntityManager</i> provides access to the operations for persistence
                of your objects. This short guide will demonstrate some of the more common operations.
            </p>
            <p>
                <b>Important : An <i>EntityManagerFactory</i> is designed to be thread-safe. An <i>EntityManager</i> is not</b>
            </p>
            <p>
                You obtain an <i>EntityManager</i>
                <a href="http://docs.oracle.com/javaee/7/api/javax/persistence/EntityManager.html" target="_blank"><img src="../images/javadoc.gif" alt=""/></a>
                from an <i>EntityManagerFactory</i> as follows
            </p>
            <source>EntityManager em = emf.createEntityManager();</source>
            <p>
                In the case of using container-managed JavaEE, you would instead obtain the
                <i>EntityManager</i> by injection
            </p>
<source><![CDATA[
@PersistenceContext(unitName="myPU")
EntityManager em;
]]></source>
            <p>
                In general you will be performing all operations on a <i>EntityManager</i> within a transaction, whether your
                transactions are controlled by your JavaEE container, by a framework such as Spring, or by locally defined transactions.
                In the examples below we will omit the transaction demarcation for clarity.
            </p>
            <br/>

            <subsection name="Persisting an Object">
                <p>
                    The main thing that you will want to do with the data layer of a JPA-enabled application is persist your objects
                    into the datastore. As we mentioned earlier, a <i>EntityManagerFactory</i> represents the datastore where the
                    objects will be persisted. So you create a normal Java object in your application, and you then persist this as follows
                </p>
                <source>em.persist(obj);</source>
                <p>
                    This will result in the object being persisted into the datastore, though clearly it will not be persistent until
                    you commit the transaction. The LifecycleState of the object changes from <i>Transient</i> to <i>PersistentClean</i>
                    (after persist()), to <i>Hollow</i> (at commit).
                </p>
            </subsection>

            <subsection name="Persisting multiple Objects in one call">
                <img src="../images/nucleus_extension.gif" alt=""/>
                <p>
                    When you want to persist multiple objects with standard JPA you have to call <i>persist</i> multiple
                    times. Fortunately DataNucleus extends this to take in a Collection or an array of entities, so
                    you can do
                </p>
                <source>em.persist(coll);</source>
                <p>
                    As above, the objects are persisted to the datastore. The LifecycleState of the objects change from 
                    <i>Transient</i> to <i>PersistentClean</i> (after persist()), to <i>Hollow</i> (at commit).
                </p>
            </subsection>

            <subsection name="Finding an object by its identity">
                <p>
                    Once you have persisted an object, it has an "identity". This is a unique way of identifying it.
                    When you specify the persistence for the class you specified an id class so you can create the
                    identity from that.
                    So what ? Well the identity can be used to retrieve the object again at some other part in your 
                    application. So you pass the identity into your application, and the user clicks on some button on a 
                    web page and that button corresponds to a particular object identity. You can then go back to your 
                    data layer and retrieve the object as follows
                </p>
                <source>Object obj = em.find(cls, id);</source>
                <p>
                    where <i>cls</i> is the class of the object you want to find, and <i>id</i> is the identity.
                    Note that the first argument could be a base class and the real object could be an instance of
                    a subclass of that.
                    Note that the second argument is either the value of the single primary-key field (when it has only
                    one primary key field), or is the value of the <i>object-id-class</i> (when it has multiple
                    primary key fields).
                </p>
                <br/>
            </subsection>

            <subsection name="Deleting an Object">
                <p>
                    When you need to delete an object that you had previous persisted, deleting it is simple.
                    Firstly you need to get the object itself, and then delete it as follows
                </p>
                <source>
Object obj = em.find(cls, id);  // Retrieves the object to delete
em.remove(obj);</source>
                <br/>
            </subsection>

            <subsection name="Deleting multiple Objects">
                <img src="../images/nucleus_extension.gif" alt=""/>
                <p>
                    When you want to delete multiple objects with standard JPA you have to call <i>remove</i> multiple
                    times. Fortunately DataNucleus extends this to take in a Collection or an array of entities, so
                    you can do
                </p>
                <source>
Collection objsToRemove = new HashSet();
objsToRemove.add(obj1);
objsToRemove.add(obj2);
em.remove(objsToRemove);</source>
                <br/>
            </subsection>

            <subsection name="Modifying a persisted Object">
                <p>
                    To modify a previously persisted object you take the object and update it in your code. When you are
                    ready to persist the changes you do the following
                </p>
                <source>
Object updatedObj = em.merge(obj)</source>
                <br/>
            </subsection>

            <subsection name="Modifying multiple persisted Objects">
                <img src="../images/nucleus_extension.gif" alt=""/>
                <p>
                    When you want to attach multiple modified objects with standard JPA you have to call <i>merge</i> 
                    multiple times. Fortunately DataNucleus extends this to take in a Collection or an array of entities, so
                    you can do
                </p>
                <source>
Object updatedObj = em.merge(coll)</source>
                <br/>
            </subsection>

            <subsection name="Refreshing a persisted Object">
                <p>
                    When you think that the datastore has more up-to-date values than the current values in a retrieved
                    persisted object you can refresh the values in the object by doing the following
                </p>
                <source>em.refresh(obj)</source>
                <p>
                    This will do the following
                </p>
                <ul>
                    <li>Refresh all fields that are to be eagerly fetched from the datastore</li>
                    <li>Unload all loaded fields that are to be lazily fetched.</li>
                </ul>
                <p>
                    If the object had any changes they will be thrown away by this step, and replaced by
                    the latest datastore values.
                </p>
                <br/>
            </subsection>

            <subsection name="Getting EntityManager for an object">
                <img src="../images/nucleus_extension.gif" border="0" alt=""/>
                <p>
                    JPA doesn't provide a method for getting the EntityManager of an object as such. Fortunately
                    DataNucleus provides the following
                </p>
                <source>EntityManager em = NucleusJPAHelper.getEntityManager(obj);</source>
                <br/>
            </subsection>

            <a name="level1_cache"/>
            <subsection name="Level 1 Cache">
                <p>
                    Each EntityManager maintains a cache of the objects that it has encountered (or have been
                    "enlisted") during its lifetime. This is termed the <b>Level 1 Cache</b>. It is enabled by default
                    and you should only ever disable it if you really know what you are doing.
                    There are inbuilt types for the Level 1 (L1) Cache available for selection.
                    DataNucleus supports the following types of L1 Cache :-
                </p>
                <ul>
                    <li><i>weak</i> - uses a weak reference backing map. If JVM garbage collection clears 
                        the reference, then the object is removed from the cache.</li>
                    <li><i>soft</i> - uses a soft reference backing map. If the map entry value object is 
                        not being actively used, then garbage collection <i>may</i> garbage collect the reference, 
                        in which case the object is removed from the cache.</li>
                    <li><i>strong</i> - uses a normal HashMap backing. With this option all references are 
                        strong meaning that objects stay in the cache until they are explicitly removed by calling 
                        remove() on the cache.</li>
                </ul>
                <p>
                    You can specify the type of L1 Cache by providing the persistence property 
                    <b>datanucleus.cache.level1.type</b>. You set this to the value of the type required. 
                    If you want to remove all objects from the L1 cache programmatically you should use 
                    <i>em.clear()</i> but bear in mind the other things that this will impact on.
                </p>
                <p>
                    Objects are placed in the L1 Cache (and updated there) during the course of the transaction.
                    This provides rapid access to the objects in use in the users application and is used to
                    guarantee that there is only one object with a particular identity at any one time
                    for that EntityManager. When the EM is closed the cache is cleared.
                </p>
                <p>
                    <a href="http://www.datanucleus.org/extensions/level1_cache.html"><img src="../images/nucleus_plugin.gif" border="0" alt=""/></a>
                    The L1 cache is a DataNucleus plugin point allowing you to provide your own cache
                    where you require it.
                </p>
                <br/>
            </subsection>
        </section>
    </body>
</document>