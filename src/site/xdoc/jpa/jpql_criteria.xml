<?xml version="1.0" encoding="iso-8859-1"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
    <properties>
        <title>JPQL : Criteria</title>
    </properties>

    <body>
        <section name="JPA : JPQL Criteria Queries">
            <p>
                In JPA there is a query API referred to as "criteria". This is really an API allowing
                the construction of queries expression by expression, and optionally making it type-safe.
                It provides two ways of specifying a field/property. The first way is using Strings, and the second
                using a <a href="#metamodel">MetaModel</a>. The advantage of the MetaModel is that it means that 
                your queries are refactorable if you rename a field. Each example will be expressed in both ways 
                where appropriate so you can see the difference.
            </p>

            <subsection name="Creating a Criteria query">
                <p>
                    To use the JPA Criteria API, firstly you need to create a <i>CriteriaQuery</i> object for the
                    candidate in question, and set the candidate, its alias, and the result to be of the candidate 
                    type
                </p>
                <source><![CDATA[
CriteriaBuilder cb = emf.getCriteriaBuilder();
CriteriaQuery<Person> crit = cb.createQuery(Person.class);
Root<Person> candidateRoot = crit.from(Person.class);
candidateRoot.alias("p");

crit.select(candidateRoot);]]></source>
                <p>
                    So what we have there equates to
                </p>
                <source>SELECT p FROM mydomain.Person p</source>
                <p>
                    For a complete list of all methods available on CriteriaBuilder, refer to
                    <a href="http://java.sun.com/javaee/6/docs/api/javax/persistence/criteria/CriteriaBuilder.html" target="_blank"><img src="../images/javadoc.gif" alt=""/></a>
                    For a complete list of all methods available on CriteriaQuery, refer to
                    <a href="http://java.sun.com/javaee/6/docs/api/javax/persistence/criteria/CriteriaQuery.html" target="_blank"><img src="../images/javadoc.gif" alt=""/></a>
                </p>
                <br/>
            </subsection>

            <subsection name="JPQL equivalent of the Criteria query">
                <img src="../images/nucleus_extension.gif" border="0" alt=""/>
                <p>
                    If you ever want to know what is the equivalent JPQL string-based query for your Criteria,
                    just print out <i>criteriaQuery.toString()</i>.
                    This is <b>not</b> part of the JPA spec, but something that we feel is very useful so is 
                    provided as a DataNucleus vendor extension. So, for example, the criteria query above would
                    result in the following from <i>crit.toString()</i>
                </p>
                <source><![CDATA[
SELECT p FROM mydomain.Person p]]></source>
                <br/>
            </subsection>

            <subsection name="Criteria API : Result clause">
                <p>
                    The basic Criteria query above is fine, but you may want to define a result other than the
                    candidate. To do this we need to use the Criteria API.
                </p>
                <source><![CDATA[
Path nameField = candidateRoot.get("name");
crit.select(nameField);]]></source>
                <p>
                    which equates to
                </p>
                <source><![CDATA[SELECT p.name]]></source>
                <p>
                    Note that here we accessed a field by its name (as a String). We could easily have accessed
                    it via the <a href="#metamodel">Criteria MetaModel</a> too.
                </p>
                <br/>
            </subsection>

            <subsection name="Criteria API : From clause joins">
                <p>
                    The basic Criteria query above is fine, but you may want to define some explicit joins.
                    To do this we need to use the Criteria API.
                </p>
                <source><![CDATA[
Metamodel model = emf.getMetamodel();
ManagedType personType = model.type(Person.class);
Attribute addressAttr = personType.getAttribute("address");
Join addressJoin = candidateRoot.join((SingularAttribute)addressAttr);
addressJoin.alias("a");]]></source>
                <p>
                    which equates to
                </p>
                <source><![CDATA[FROM mydomain.Person p JOIN p.address a]]></source>
                <br/>
            </subsection>

            <subsection name="Criteria API : Filter">
                <p>
                    The basic Criteria query above is fine, but in the majority of cases we want to
                    define a filter. To do this we need to use the Criteria API.
                </p>
                <source><![CDATA[
String-based:
Predicate nameEquals = cb.equal(candidateRoot.get("name"), "First");
crit.where(nameEquals);

MetaModel-based:
Predicate nameEquals = cb.equal(candidateRoot.get(Person_.name), "First");
crit.where(nameEquals);]]></source>
                <p>
                    You can also invoke methods, so a slight variation on this clause would be
                </p>
                <source><![CDATA[
String-based:
Predicate nameUpperEquals = cb.equal(cb.upper(candidateRoot.get("name")), "FIRST");

MetaModel-based:
Predicate nameUpperEquals = cb.equal(cb.upper(candidateRoot.get(Person_.name)), "FIRST");]]></source>
                <p>
                    which equates to
                </p>
                <source><![CDATA[WHERE (UPPER(p.name) = 'FIRST')]]></source>
                <br/>
            </subsection>

            <subsection name="Criteria API : Ordering">
                <p>
                    The basic Criteria query above is fine, but in many cases we want to define ordering.
                    To do this we need to use the Criteria API.
                </p>
                <source><![CDATA[
String-based:
Order orderFirstName = cb.desc(candidateRoot.get("name"));
crit.orderBy(orderFirstName);

MetaModel-based:
Order orderFirstName = cb.desc(candidateRoot.get(Person_.name));
crit.orderBy(orderFirstName);]]></source>
                <p>
                    which equates to
                </p>
                <source><![CDATA[ORDER BY p.name DESC]]></source>
                <br/>
            </subsection>

            <subsection name="Criteria API : Parameters">
                <p>
                    Another common thing we would want to do is specify input parameters.
                    To do this we need to use the Criteria API. Let's take an example of a filter with parameters.
                </p>
                <source><![CDATA[
String-based:
ParameterExpression param1 = cb.parameter(String.class, "myParam1");
Predicate nameEquals = cb.equal(candidateRoot.get("name"), param1);
crit.where(nameEquals);

MetaModel-based:
ParameterExpression param1 = cb.parameter(String.class, "myParam1");
Predicate nameEquals = cb.equal(candidateRoot.get(Person_.name), param1);
crit.where(nameEquals);]]></source>
                <p>
                    which equates to
                </p>
                <source><![CDATA[WHERE (p.name = :myParam)]]></source>
                <p>
                    Don't forget to set the value of the parameters before executing the query!
                </p>
                <br/>
            </subsection>

            <subsection name="Criteria API : Result as Tuple">
                <p>
                    You sometimes need to define a result for a query.
                    You can define a result class just like with normal JPQL, but a special case is where you don't have a particular
                    result class and want to use the <i>built-in</i> JPA standard <b>Tuple</b> class.
                </p>
                <source><![CDATA[
CriteriaQuery<Tuple> crit = cb.createTupleQuery();
]]></source>
                <br/>
            </subsection>

            <subsection name="Executing a Criteria query">
                <p>
                    Ok, so we've seen how to generate a Criteria query. So how can we execute it ?
                    This is simple; convert it into a standard JPA query, set any parameter values and execute it.
                </p>
                <source><![CDATA[
Query query = em.createQuery(crit);
List<Person> results = query.getResultList();]]></source>
                <br/>
            </subsection>

            <subsection name="Criteria API : UPDATE query">
                <p>
                    So the previous examples concentrated on SELECT queries. Let's now do an UPDATE
                </p>
                <source><![CDATA[
String-based:
CriteriaUpdate<Person> crit = qb.createCriteriaUpdate(Person.class);
Root<Person> candidate = crit.from(Person.class);
candidate.alias("p");
crit.set(candidate.get("firstName"), "Freddie");
Predicate teamName = qb.equal(candidate.get("firstName"), "Fred");
crit.where(teamName);
Query q = em.createQuery(crit);
int num = q.executeUpdate();

MetaModel-based:
CriteriaUpdate<Person> crit = qb.createCriteriaUpdate(Person.class);
Root<Person> candidate = crit.from(Person.class);
candidate.alias("p");
crit.set(candidate.get(Person_.firstName), "Freddie");
Predicate teamName = qb.equal(candidate.get(Person.firstName), "Fred");
crit.where(teamName);
Query q = em.createQuery(crit);
int num = q.executeUpdate();]]></source>
                <p>
                    which equates to
                </p>
                <source><![CDATA[UPDATE Person p SET p.firstName = 'Freddie' WHERE p.firstName = 'Fred']]></source>
                <br/>
            </subsection>

            <subsection name="Criteria API : DELETE query">
                <p>
                    So the previous examples concentrated on SELECT queries. Let's now do a DELETE
                </p>
                <source><![CDATA[
String-based:
CriteriaDelete<Person> crit = qb.createCriteriaDelete(Person.class);
Root<Person> candidate = crit.from(Person.class);
candidate.alias("p");
Predicate teamName = qb.equal(candidate.get("firstName"), "Fred");
crit.where(teamName);
Query q = em.createQuery(crit);
int num = q.executeUpdate();

MetaModel-based:
CriteriaDelete<Person> crit = qb.createCriteriaDelete(Person.class);
Root<Person> candidate = crit.from(Person.class);
candidate.alias("p");
Predicate teamName = qb.equal(candidate.get(Person.firstName), "Fred");
crit.where(teamName);
Query q = em.createQuery(crit);
int num = q.executeUpdate();]]></source>
                <p>
                    which equates to
                </p>
                <source><![CDATA[DELETE FROM Person p WHERE p.firstName = 'Fred']]></source>
                <br/>
            </subsection>

            <a name="metamodel"/>
            <subsection name="MetaModel">
                <p>
                    As we mentioned at the start of this section, there is a MetaModel allowing refactorability.
                    In JPA the MetaModel is a <i>static metamodel</i> of generated classes that mirror the applications 
                    persistable classes and have persistable fields marked as <i>public</i> and <i>static</i> so that 
                    they can be accessed when generating the queries. In the examples above you saw reference to a class
                    with name with suffix "_". This is a metamodel class. It is defined below.
                </p>
                <p>
                    The JPA spec contains the following description of the static metamodel.
                    <br/>
                    <i>For every managed class in the persistence unit, a corresponding metamodel class is produced
                    as follows:</i>
                </p>
                <ul>
                    <li>For each managed class X in package p, a metamodel class X_ in package p is created.</li>
                    <li>The name of the metamodel class is derived from the name of the managed class by appending 
                            "_" to the name of the managed class.</li>
                    <li>The metamodel class X_ must be annotated with the javax.persistence.StaticMetamodel 
                            annotation</li>
                    <li>If class X extends another class S, where S is the most derived managed class (i.e., 
                            entity or mapped superclass) extended by X, then class X_ must extend class S_, where 
                            S_ is the meta-model class created for S.</li>
                    <li>For every persistent non-collection-valued attribute y declared by class X, where the 
                            type of y is Y, the metamodel class must contain a declaration as follows:
                            <pre>public static volatile SingularAttribute&lt;X, Y&gt; y;</pre></li>
                    <li>For every persistent collection-valued attribute z declared by class X, where the element 
                            type of z is Z, the metamodel class must contain a declaration as follows:
                        <ul>
                            <li>if the collection type of z is java.util.Collection, then 
                                <pre>public static volatile CollectionAttribute&lt;X, Z&gt; z;</pre></li>
                            <li>if the collection type of z is java.util.Set, then
                                <pre>public static volatile SetAttribute&lt;X, Z&gt; z;</pre></li>
                            <li>if the collection type of z is java.util.List, then
                                <pre>public static volatile ListAttribute&lt;X, Z&gt; z;</pre></li>
                            <li>if the collection type of z is java.util.Map, then
                                <pre>public static volatile MapAttribute&lt;X, K, Z&gt; z;</pre>
                                where K is the type of the key of the map in class X</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    Let's take an example, for the following class
                </p>
                <source><![CDATA[
package org.datanucleus.samples.jpa2.metamodel;

import java.util.*;
import javax.persistence.*;

@Entity
public class Person
{
    @Id
    long id;

    String name;

    @OneToMany
    List<Address> addresses;
}]]></source>
                <p>the static metamodel class will be</p>
                <source><![CDATA[
package org.datanucleus.samples.jpa2.metamodel;

import javax.persistence.metamodel.*;

@StaticMetamodel(Person.class)
public class Person_ 
{
    public static volatile SingularAttribute<Person, Long> id;
    public static volatile SingularAttribute<Person, String> name;
    public static volatile ListAttribute<Person, Address> addresses;
}
]]></source>
                <br/>
                <p>
                    <b>So how do we generate this metamodel definition for our query classes?</b>
                    DataNucleus provides an <i>annotation processor</i> in the jar <b>datanucleus-jpa-query</b>
                    that can be used when compiling your model classes to generate the static metamodel classes.
                    What this does is when the compile is invoked, all classes that have persistence annotations
                    will be passed to the annotation processor and a Java file generated for its metamodel. Then
                    all classes (original + metamodel) are compiled.
                </p>
                <p>
                    To enable this in Maven you would need the above jar, plus <i>persistence-api.jar</i> to be in the CLASSPATH at compile
                </p>
                <source><![CDATA[
<plugin>
    <artifactId>maven-compiler-plugin</artifactId>
    <configuration>
        <source>1.7</source>
        <target>1.7</target>
    </configuration>
</plugin>]]></source>
                <br/>
                <p>
                    To enable this in Eclipse you would need to do the following
                </p>
                <ul>
                    <li>Go to <i>Java Compiler</i> and make sure the compiler compliance level is 1.7 or above (needed for DN 4.0+ anyway)</li>
                    <li>Go to <i>Java Compiler -> Annotation Processing</i> and enable the project specific settings and enable annotation processing</li>
                    <li>Go to <i>Java Compiler -> Annotation Processing -> Factory Path</i>, enable the project 
                        specific settings and then add the following jars to the list: <i>datanucleus-jpa-query.jar</i>, <i>persistence-api.jar</i>
                    </li>
                </ul>
            </subsection>
        </section>
    </body>
</document>