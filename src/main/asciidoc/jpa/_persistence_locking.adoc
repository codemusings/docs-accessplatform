[[locking]]
= Locking
:_basedir: ../
:_imagesdir: images/

Within a transaction it is very common to require some form of locking of objects so that you can guarantee the integrity of data that is committed.
There are the following locking types for a transaction.

* Lock specific records in a datastore and keep them locked until commit of the changes. 
These are known as link:#locking_pessimistic[Pessimistic (or datastore) Locking].
* Assume that things in the datastore will not change until they are ready to commit, not lock any records and 
then just before committing make a check for changes. This is known as link:#locking_optimistic[Optimistic Locking].


[[locking_pessimistic]]
== Pessimistic (Datastore) Locking

*Pessimistic* locking isn't the default behaviour with JPA but can be configured.
It is suitable for short lived operations where no user interaction is taking place and so it is possible to block access to datastore entities for the duration of the transaction.
Such locking is best employed on specific objects, rather as a global process applying to all retrieved objects.

To enable pessimistic locking globally you would add the persistence property *datanucleus.Optimistic* as _false_. 
Additionally, for RDBMS, to lock ALL retrieved objects you would also set the persistence property *datanucleus.rdbms.useUpdateLock* to _true_. 

Any object that has a pessimistic lock will result in (for RDBMS) all "SELECT ... FROM ..." retrieval statements being changed to be "SELECT ... FROM ... FOR UPDATE"; 
this will be applied only where the underlying RDBMS supports the "FOR UPDATE" syntax.

With pessimistic locking DataNucleus will grab a datastore connection at the first operation, and maintain it for the duration of the transaction. 
A single connection is used for the transaction (with the exception of any link:mapping.html#value_generation[Value Generation] operations which need datastore 
access, so these can use their own connection).

The JPA EntityManager allows control over locking with several methods. For example

[source,java]
-----
Person person = em.find(Person.class, 1, LockModeType.PESSIMISTIC_READ);
-----
will retrieve the _Person_ object with identity 1, and will lock it until the end of the transaction.

You can additionally perform an explicit lock on a specific object like this

[source,java]
-----
em.lock(person, LockModeType.PESSIMISTIC_READ);
-----

which will lock the object from that point in the transaction.

If you wanted to lock all objects affected by a query, you can set the lock mode of the query, like this

[source,java]
-----
Query q = em.createQuery("SELECT p FROM Person p WHERE p.lastName = 'Smith'");
q.setLockMode(LockModeType.PESSIMISTIC_READ);
List<Person> results = q.getResultList();
-----
which will add a pessimistic lock on all _Person_ objects with surname _Smith_.



In terms of the process of pessimistic (datastore) locking, we demonstrate this below.

[cols="1,3,3", options="header"]
|===
|Operation
|DataNucleus process
|Datastore process

|Start transaction
|
|

|Persist object
|Prepare object (1) for persistence
|*Open connection.*
Insert the object (1) into the datastore

|Update object
|Prepare object (2) for update
|Update the object (2) into the datastore

|Persist object
|Prepare object (3) for persistence
|Insert the object (3) into the datastore

|Update object
|Prepare object (4) for update
|Update the object (4) into the datastore

|Flush
|No outstanding changes so do nothing
|

|Perform query
|Generate query in datastore language
|Query the datastore and return selected objects

|Persist object
|Prepare object (5) for persistence
|Insert the object (5) into the datastore

|Update object
|Prepare object (6) for update
|Update the object (6) into the datastore

|Commit transaction
|
|*Commit connection*
|===

So here whenever an operation is performed, DataNucleus pushes it straight to the datastore.
Consequently any queries will always reflect the current state of all objects in use.
This mode of operation has no version checking of objects and so, if they were updated by external processes in the meantime then, they will overwrite those changes. This is
where the locking statements for particular objects is crucial, preventing them being updated externally.


It should be noted that DataNucleus provides two persistence properties that allow an amount of control over when flushing happens with pessimistic locking

* _datanucleus.flush.mode_ when set to MANUAL will try to delay all datastore operations until commit/flush.
* _datanucleus.datastoreTransactionFlushLimit_ represents the number of dirty objects before a flush is performed. This defaults to 1.



[[locking_optimistic]]
== Optimistic Locking

Optimistic locking is suitable for longer lived operations maybe where user interaction is taking place and where it would be undesirable to block access to 
datastore entities for the duration of the transaction. The assumption is that data altered in this transaction will not be updated by 
other transactions during the duration of this transaction, so the changes are not propagated to the datastore until commit()/flush(). 
The data is checked just before commit to ensure the integrity in this respect. 
The most convenient way of checking data for updates is to maintain a column on each table that handles optimistic locking data to store a version. 


Rather than placing version columns on all user datastore tables, JPA allows the user to notate particular classes as requiring *optimistic* treatment. 
This is performed by specifying in MetaData or annotations the details of the field/column to use for storing the version - see link:mapping.html#versioning[versioning]. 
With JPA you must have a field in your class ready to store the version. With DataNucleus we also allows a version to be stored in a surrogate column
hence not requiring a field in the actual class.



In terms of the process of optimistic locking, we demonstrate this below.

[cols="1,3,3a", options="header"]
|===
|Operation
|DataNucleus process
|Datastore process

|Start transaction
|
|

|Persist object
|Prepare object (1) for persistence
|

|Update object
|Prepare object (2) for update
|

|Persist object
|Prepare object (3) for persistence
|

|Update object
|Prepare object (4) for update
|

|Flush
|Flush all outstanding changes to the datastore
|* *Open connection*
* Version check of object (1)
* Insert the object (1) in the datastore.
* Version check of object (2)
* Update the object (2) in the datastore.
* Version check of object (3)
* Insert the object (3) in the datastore.
* Version check of object (4)
* Update the object (4) in the datastore.

|Perform query
|Generate query in datastore language
|Query the datastore and return selected objects

|Persist object
|Prepare object (5) for persistence
|

|Update object
|Prepare object (6) for update
|

|Commit transaction
|Flush all outstanding changes to the datastore
|* Version check of object (5)
* Insert the object (5) in the datastore
* Version check of object (6)
* Update the object (6) in the datastore.
* *Commit connection*
|===

Here no changes make it to the datastore until the user either commits the transaction, or they invoke flush(). 
The impact of this is that when performing a query, by default, the results may not contain the modified objects unless they are flushed 
to the datastore before invoking the query. 
Depending on whether you need the modified objects to be reflected in the results of the query governs what you do about that. 
If you invoke flush() just before running the query the query results will include the changes. The obvious benefit of optimistic locking is that
all changes are made in a block and version checking of objects is performed before application of changes, hence this mode copes better with external processes updating the objects.

Please note that for some datastores (e.g RDBMS) the version check followed by update/delete is performed in a single statement.

See also :-

* link:metadata_xml.html#version[JPA MetaData reference for <version> element]
* link:annotations.html#Version[JPA Annotations reference for @Version]
